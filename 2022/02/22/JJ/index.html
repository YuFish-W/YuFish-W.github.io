<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>有书有酒</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java 1. 入门 编译时使用javac+文件名，c代表compile，这个文件名是编写好的源文件文件名，需要后缀（Hello.java)  在用DOS运行时属性里的“当前代码页”有规定了格式（GBK），编译文件中有中文的时候如果不先将程序转换成GBK编码可能编译无效（切换编码后需要保存才能生效） ，不会出现.class文件(不在DOS里运行基本都是UTF-8编码)       在运行时的时候使">
<meta property="og:type" content="article">
<meta property="og:title" content="有书有酒">
<meta property="og:url" content="http://example.com/2022/02/22/JJ/index.html">
<meta property="og:site_name" content="有书有酒">
<meta property="og:description" content="Java 1. 入门 编译时使用javac+文件名，c代表compile，这个文件名是编写好的源文件文件名，需要后缀（Hello.java)  在用DOS运行时属性里的“当前代码页”有规定了格式（GBK），编译文件中有中文的时候如果不先将程序转换成GBK编码可能编译无效（切换编码后需要保存才能生效） ，不会出现.class文件(不在DOS里运行基本都是UTF-8编码)       在运行时的时候使">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211208084158425.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211208091927202.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211210085849263.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211216092013689.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211220163657420.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211220190754830.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211220192504580.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221092728909.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221203412974.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221203701691.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221212105452.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211222110208515.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224075334189.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211223123006507.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211223190354498.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224102202345.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224132531769.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224144607999.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224145317808.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224152941442.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224155620210.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224155630592.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224162909475.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224162839850.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211225164912044.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211225164957297.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211225200549401.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227102313115.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227102330994.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227105623856.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227105828235.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229121724738.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229144219171.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229145539319.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150013202.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150753465.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150806901.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150824407.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229160140935.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229160158820.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229161523669.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229164019649.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229164045931.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229171953279.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229172659570.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229173357181.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229174008141.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230155030868.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230223422063.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230223438994.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231101447632.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231102137519.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231110556926.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123513536.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123529853.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123546280.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123555134.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231192708828.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231205302723.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231205450925.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231205318623.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155207964.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155213887.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155226196.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173153957.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173204267.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173208585.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173212442.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101194552893.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101200841410.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101205910404.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101220142246.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101220703015.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101222054912.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101222753151.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114034690.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114118342.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114400602.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114410291.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114447001.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102144809463.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102144920581.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102152857427.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102154542865.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102154604190.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102155824897.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102155846580.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102160517251.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102164006487.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102162046341.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102164413213.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102170505782.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102170648800.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102172129733.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102172139168.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102185506856.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102185512682.png">
<meta property="og:image" content="c:/Users/%E5%90%B4%E5%AE%87/AppData/Roaming/Typora/typora-user-images/image-20220102200349175.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102200519291.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102200525182.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102200812679.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102202023034.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103093841127.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211112611.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211256998.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211745526.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211950716.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102212556359.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102213318272.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103092438800.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103092635917.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103093338669.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103095112120.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103095118917.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103095327324.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103212135653.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103212903120.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103222304693.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103224726268.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103224800723.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104131911414.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104132210285.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104133030046.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104133256295.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104142407252.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104153603185.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104165321379.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220108102129267.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104172114749.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104172126309.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220108101336971.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220108102310753.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109182224949.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109183518910.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109183525252.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109184158045.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109184927445.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109192403303.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109192409874.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109192544481.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123105036233.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123114115175.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123182854676.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123182957730.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124105744662.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124105904572.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124110256510.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124110434940.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124110624403.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124111310294.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124114646341.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124114752627.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124124620017.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124125521375.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124170225581.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124170311551.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124173839183.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124190124073.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124194309747.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125114338098.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125134933858.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125141752593.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125141556302.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125195133444.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220126161218339.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127150113869.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127150156886.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127173529338.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127174231666.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127175402831.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127181520835.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127214126750.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127215109811.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128114328320.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128114407747.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128121516292.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152455290.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152530666.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152538592.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152548035.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152559189.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128210352703.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128210414360.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128210437584.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129110020434.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129110046015.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221056884.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221153736.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221348465.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221447818.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211224059980.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211224223346.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212000055365.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212170606391.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212170646465.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212171041483.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212180115375.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212180250016.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212180709930.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212182559066.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212202310002.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212202423428.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212202430918.png">
<meta property="og:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230161148251.png">
<meta property="article:published_time" content="2022-02-22T14:29:51.320Z">
<meta property="article:modified_time" content="2022-02-22T13:09:58.079Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211208084158425.png">
  
    <link rel="alternate" href="/atom.xml" title="有书有酒" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">有书有酒</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学习记录</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JJ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/02/22/JJ/" class="article-date">
  <time class="dt-published" datetime="2022-02-22T14:29:51.320Z" itemprop="datePublished">2022-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java</p>
<h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h2><ul>
<li><p><strong>编译时</strong>使用<code>javac+文件名</code>，c代表compile，这个文件名是编写好的源文件文件名，<strong>需要后缀</strong>（Hello.java)</p>
</li>
<li><p>在用DOS运行时<strong>属性</strong>里的“当前代码页”有规定了格式（GBK），编译文件中有<strong>中文</strong>的时候如果不先将程序<strong>转换成GBK编码</strong>可能编译无效（切换编码后需要保存才能生效） ，不会出现.class文件(不在DOS里运行基本都是UTF-8编码)</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211208084158425.png" alt="image-20211208084158425">    </p>
</li>
<li><p>在<strong>运行时</strong>的时候使用<code>java+文件名</code>，但是这个文件名<strong>不用带后缀</strong>，如<code>java Hello</code>，因为它在运行的时候<strong>找的是Hello这个主类</strong>，如果用<code>java Hello.class</code>代表着你要运行名字叫做<code>Hello.class</code>的类，而其实类名是<code>Hello</code></p>
</li>
<li><p>在使用<code>java</code>指令（这个指令对应的是java.exe这是程序，但是使用的时候没必要吧后缀带上，javac也是用的javac.exe程序，同样不用后缀）运行的时候，本质就是将<code>.class</code>文件装载到对应的<strong>虚拟机</strong>里面执行</p>
</li>
<li><p>.java文件叫<strong>源文件</strong>，.class文件叫<strong>字节码文件</strong>，对源文件<em>修改</em>后要<strong>重新编译</strong>才能正确运行</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211208091927202.png" alt="image-20211208091927202"></p>
</li>
<li><p>编译后源文件里<strong>每一个类都会</strong>生成一个.class文件，非public类都会生成.class文件，且源文件里最多只能包含一个public类（其他类个数不限），如果源文件里有public类，那么文件名就必须是这个类的名字</p>
</li>
<li><p>其他<strong>非public类中也可以定义main方法</strong>，每个类都会生成.class文件，运行时用**<code>java+对应的类名</code>**就可以运行这个非public类</p>
</li>
<li><p>在输出时候<code>\r</code>表示<strong>回车</strong>，例如<code>System.out.println(&quot;天天向上\r屈服&quot;)</code>，表示在天天向上后回车，<strong>光标</strong>会回到天天向上前面，这个时候输入后面的屈服，会从头替换，最终输出<code>屈服向上</code></p>
</li>
<li><p>一些<strong>错误提示</strong>，例如：</p>
<blockquote>
<p>**”非法字符”**，一般是含杂这中文字符或者GBK等编码格式</p>
<p>**”找不到符号”**，一般是写的单词或者方法拼写错误</p>
</blockquote>
</li>
<li><p><u><strong>配置环境变量path及其作用</strong></u></p>
<blockquote>
<ol>
<li>环境变量的作用是为了在dos的任意目录，可以去使用java 和 javac命令</li>
<li>先配置 JAVA_HOME = 指向jdk安装的主目录</li>
<li>编辑path环境变量，增加 %JAVA_HOME%\bin (这个% %相当于引用JAVA_HOME代表的目录，直接打出此目录也行，但是这样引用后如果有多个命令需要用到此目录，当此目录位置发生改变时，只需改变JAVA_HOME代表的地址即可，不用每个都改)</li>
</ol>
</blockquote>
</li>
<li><p>常量不是单单指数字，”hello“这种字符串也是常量，<strong>常量指具体的值</strong></p>
</li>
</ul>
<h2 id="2-基本数据类型"><a href="#2-基本数据类型" class="headerlink" title="2. 基本数据类型"></a>2. 基本数据类型</h2><h3 id="2-1-赋值时需注意"><a href="#2-1-赋值时需注意" class="headerlink" title="2.1 赋值时需注意"></a>2.1 赋值时需注意</h3><h4 id="2-1-1-整形"><a href="#2-1-1-整形" class="headerlink" title="2.1.1 整形"></a>2.1.1 整形</h4><ul>
<li><p>声明<strong>整型</strong>时整数在赋值给变量的时候<strong>默认是int类型</strong>，要<strong>声明long型</strong>变量的时候常量后面须加**”l”或者”L”**。例如<code>long m = 55L</code>,使用<code>int m = 55L</code>是错误的，因为声明m为int类型，后面55l代表long类型，会造成精度损失</p>
</li>
<li><p><code>byte n1 = 1</code>是可以的，虽然1默认是int类型，但是编译器会先判断数值是否在byte的范围内，如果在范围内就可以，这里是<strong>具体数字的赋值</strong>，如果是<strong>变量赋值</strong>，就会先检查类型，例如下面这样会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> n1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">n1 = n2;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-2-浮点型"><a href="#2-1-2-浮点型" class="headerlink" title="2.1.2 浮点型"></a>2.1.2 浮点型</h4><ul>
<li><strong>浮点型</strong>常量<strong>默认为double型</strong>，声明<strong>float型</strong>变量的时候后面需要<strong>加”f”或”L”</strong>(虽然默认为double类型，但是也可以在数字后+<strong>“d”或”D”<strong>来表示</strong>double类型</strong>，可以用于<strong>声明整数是double</strong>,例如<code>double i = 45d</code>)。例如可以用<code>float num1 = 1.1f</code>，使用<code>float num1 = 1.1</code>是错误的，因为后面的1.1默认为double型，会造成精度损失。(如果<strong>不会造成精度损失</strong>，例如<code>double num1 = 1.1F</code>，这样是对的，因为double类型精度高于float)</li>
<li>如果不清楚浮点类型具体是多少，可以用double，精度更高</li>
<li>如果方法中<strong>返回类型是double</strong>，但是又要判断输入数据不合规时用什么返回值，可以将返回类型改为<strong>Double，它可以兼容接收double，同时它还可以接收null，不合规就返回null</strong>。</li>
</ul>
<h4 id="2-1-2-字符型"><a href="#2-1-2-字符型" class="headerlink" title="2.1.2 字符型"></a>2.1.2 字符型</h4><ul>
<li><p><strong>字符类型char</strong>可以存放单个字符，也可以<strong>直接存放数字</strong>，但是输出的时候会<strong>输出</strong>这个数字代表的**<u>unicode码</u><strong>。例如，<code>char num = 97</code>，输出的时候会出a这个字母。</strong>相反**，想要输出字符代表的数字，在输出语句的变量前面使用<code>(int)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">97</span>;</span><br><span class="line">System.out.println(c1); <span class="comment">// 输出a</span></span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">System.out.println((<span class="keyword">int</span>)c2);<span class="comment">//输出&#x27;a&#x27; 对应的 数字</span></span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;韩&#x27;</span>;</span><br><span class="line">System.out.println((<span class="keyword">int</span>)c3);<span class="comment">//输出 38889</span></span><br><span class="line"><span class="keyword">char</span> c4 = <span class="number">38889</span>;</span><br><span class="line">System.out.println(c4);<span class="comment">//输出 韩</span></span><br></pre></td></tr></table></figure>

<p>因此，**<u>char的本质是一个数字，可以进行运算</u>**，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>); <span class="comment">/*会输出107（我的理解：因为混合计算结果的类型会提</span></span><br><span class="line"><span class="comment">升为最大操作数的类型，因此这里转化成int类型，直接输出这个结果，即输出了数字（int型））*/</span></span><br><span class="line"><span class="keyword">char</span> num = <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;         <span class="comment">/*我的理解：这里表达式结果也是int型，但是这个结果赋</span></span><br><span class="line"><span class="comment">给了字符型变量num，因此会先检查这个数字的值是否超过了此变量上限（字符型占2字节），因此</span></span><br><span class="line"><span class="comment">这里等价于char num = 107，可以正确赋值。*/</span></span><br><span class="line">System.out.println(num);    <span class="comment">//会输出&#x27;k&#x27;</span></span><br><span class="line">======================================================================</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">ch = ch + <span class="number">1</span>;				<span class="comment">/*错误，虽然和上面&#x27;a&#x27;+1一样转换成数字98赋给char类型，但是如果有变量参与计算，不论是字符是变量还是数字是变量的形式，都会优先把结果当做变量来看待，这里就会自动转换成最大的操作数类型，即int型，把结果优先当做变量，会先检查类型是否匹配而不是先检查数字值是否超过上限*/</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">44</span>;</span><br><span class="line"><span class="keyword">char</span> ch = i + <span class="number">1</span>;		<span class="comment">/*错误，虽然可以赋数字给char,但是i是变量，因此计算得出的45会当做int类型来赋值而不是数字，而int无法自动转化到char */</span></span><br><span class="line"><span class="keyword">char</span> ch = <span class="number">44</span> + <span class="number">1</span>;		<span class="comment">//正确，没有变量参与，优先当做数字检查是否超过上限</span></span><br></pre></td></tr></table></figure>

<p><strong>可以这么理解</strong>：当用<code>char</code>定义一个字符变量的时候，<strong>不管</strong>给他赋什么值，<strong>赋数字</strong>也好<strong>赋字母也</strong>好，本质上<strong>都是赋给了它一个数字</strong>（这个数字用<strong>二进制存储</strong>在计算机中），在<strong>输出</strong>这个字符变量的时候输出这个<strong>数字</strong>（现将内存中存储的二进制值<strong>转化为十进制</strong>）<strong>对应的uicode码</strong>值。</p>
</li>
<li><p><strong>ASCII码</strong>用一个字节表示，可以表示<strong>128</strong>个字符，但实际一个字节可以表示256个字符，只是英文字母不需要使用这么多</p>
</li>
</ul>
<h4 id="2-1-3-Boolean类型"><a href="#2-1-3-Boolean类型" class="headerlink" title="2.1.3 Boolean类型"></a>2.1.3 Boolean类型</h4><ul>
<li>在Java里布尔类型的值只有true和false，不像其他语言例如c可以用0和非0等</li>
</ul>
<h3 id="2-2-科学计数法"><a href="#2-2-科学计数法" class="headerlink" title="2.2 科学计数法"></a>2.2 科学计数法</h3><ul>
<li><p>5.12e2＝5.12*10²  （5.12E2）</p>
<blockquote>
<p>如果输出5.12e2结果会是512.0，因为还是浮点型(double)</p>
</blockquote>
</li>
</ul>
<h3 id="2-3-小数陷阱"><a href="#2-3-小数陷阱" class="headerlink" title="2.3 小数陷阱"></a>2.3 小数陷阱</h3><ul>
<li><code>double num1 = 8.1 / 3</code>计算机得出的结果是一个接近2.7的小数，并不是2.7，以为计算机不知道8.1后面还有没有需要除的(8.100001)，所以得到的会是一个近似值。因此<strong>直接判断小数是否相等</strong>的语句(<code>if( num1 == num2)</code>)是<strong>很危险</strong>的，应该<strong>判断他们差值的绝对值是否在某一个精度范围内</strong>(<u><code>if(Math.abs(num1 - num2) &lt; 0.0001)</code></u>)。</li>
</ul>
<h3 id="2-4-基本数据类型转换"><a href="#2-4-基本数据类型转换" class="headerlink" title="2.4 基本数据类型转换"></a>2.4 基本数据类型转换</h3><ul>
<li><p>在进行赋值或者运算时，<strong>精度小</strong>的可以自动转换为<strong>精度大</strong>的类型，这叫做**<u>自动类型转换</u>**</p>
<blockquote>
<p>可以有一下两种转换路线：**<u>（得记住）</u>**</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211210085849263.png" alt="image-20211210085849263"></p>
</blockquote>
</li>
<li><p><strong>char,byte,short之间不能自动转换</strong>，例如<code>byte b1 = 1;char a1 = b1</code>是错误的。</p>
<ul>
<li>但是他们之间<strong>可以进行运算</strong>，在运算的时候首先<strong>转换为int类型</strong>，例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> s2 = s1 + b2;  <span class="comment">//会报错，因为s1+b2会运算会自动转化为int类型</span></span><br><span class="line"><span class="keyword">int</span> a = s1 + b2;   <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//特别注意</span></span><br><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = b1 + b2;  </span><br><span class="line"><span class="comment">//也是错的，虽然b2和b2都是byte类型，但是只要char，byte,short参与了运算，就会转换精度成int类型</span></span><br><span class="line"><span class="comment">//与此同时：</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">a = <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;		<span class="comment">//是对的，输出变量a结果是b</span></span><br><span class="line">a = a + <span class="number">1</span>;			<span class="comment">//是错的，提示int不能自动转为char</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​          （**<u>注意上边的特别注意</u>**）</p>
<ul>
<li><p>在基本数据类型中<strong>布尔类型</strong>不参与转换，也无法与基本数据类型计算，但是与字符串（加法时有字符串就是拼接）可以，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = <span class="number">100</span> + <span class="keyword">true</span>;   <span class="comment">//错误</span></span><br><span class="line">String n2 = <span class="string">&quot;n&quot;</span> + <span class="keyword">true</span>;  <span class="comment">//正确，等于 ntrue</span></span><br></pre></td></tr></table></figure></li>
<li><p>将<strong>字符串强制转换</strong>成基本数据类型的时候要<strong>注意</strong>转换过的结果需要能被正确接收。例如：”RTX“不能强转成int型赋值给int变量</p>
<ul>
<li>字符串转成字符的时候不是在前面使用(char)，没有这种方法，而是在字符串后面加<code>.charAt()</code>,例如：<code>char ch = &quot;abc&quot;.charAt(0);</code>，将接收字符串的第一个字符。</li>
</ul>
</li>
</ul>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><h3 id="3-1-取模（余）运算："><a href="#3-1-取模（余）运算：" class="headerlink" title="3.1 取模（余）运算："></a>3.1 取模（余）运算：</h3><ul>
<li><p><code>a % b = a - a / b * b</code>，例如<code>-10 / 3 = -1</code>。</p>
<ul>
<li><p>上面是公式，即标准做法，这里可以<strong>换做一种理解方法</strong>：</p>
<ul>
<li><u><strong>Python</strong></u>中整除运算是<strong>向下圆整</strong>，即小数会圆整比自己<strong>更小</strong>的整数，例如**<code>10 / 3 = 3 (3 &lt; 3.333);-10 / 3 = -4 (-4 &lt; -3.3333)</code><strong>。因此在取模的时候例如：<code>-10 % 3 = 2</code>,可以理解为整除结果是-4，而3 * -4 = -12，因此</strong>余数是2**。</li>
<li><strong><u>Java</u><strong>中</strong>可以理解为向0圆整</strong>，例如**<code>10 / 3 = 3 (3.333向0靠近是3);-10 / 3 = -3( -3.3333向0靠近是-3)</code><strong>。因此在取模的时候例如：<code>-10 % 3 = -1</code>,可以理解为整除结果是-3，而3 * -3 = -9，因此</strong>余数是-1。**</li>
<li>当<code>a % b</code>有<strong>小数</strong>时，公式是<code>a % b = a - (int)a / b * b </code>，相当于在求整除结果的时候只看a的整数部分a’，然后看 和a差了多少。例如：<code>-10.5 % 3 = -1.5 </code>  (-10/3=3,3*-3=-9,余-1.5)。**<u>但是这里要注意，有小数参与的计算得到的结果是近似值，有可能返回的并不是手算的结果。</u>**</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-自增"><a href="#3-2-自增" class="headerlink" title="3.2 自增"></a>3.2 自增</h3><ul>
<li><p>例如<code>int i = i++;</code>，会分为三步（运用了临时变量temp）：(1) temp = i;(2) i = i + 1;(3)i = temp；意思是<strong>先把值赋给了临时变量</strong>，因此最后输出i是1。</p>
</li>
<li><p>例如<code>int i = ++i;</code>，它和上一步区别是<strong>先自增</strong>，再把值赋给临时变量temp，因此输出i 的值是2。</p>
</li>
<li><p>```java<br>int i = 44;<br>System.out.println(++i+i);        //=45+45=90</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 3.3 逻辑与(&amp;)和短路与(&amp;&amp;)</span><br><span class="line"></span><br><span class="line">+ 两者都是同时为真才为真，否则为假</span><br><span class="line">+ **逻辑与&amp;**在判断的时候会将左右的条件**全部判断**</span><br><span class="line">+ **短路与&amp;&amp;**在判断的时候如果第一个条件为假，**后面的条件将不再判断**，直接得假，效率高</span><br><span class="line"></span><br><span class="line">**例如：**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">int a = 5,b = 7;</span><br><span class="line">if(a &lt; 1 &amp; ++b &lt; 50)          //这里会执行++b的操作，判断过后b等于8</span><br><span class="line">if(a &lt; 1 &amp;&amp; ++b &lt; 50)		  //这里不会执行++b的操作，判断过后b还是等于7</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>开发中</strong>基本使用短路与&amp;&amp;，效率高</li>
</ul>
<h3 id="3-4-短路或-和逻辑或"><a href="#3-4-短路或-和逻辑或" class="headerlink" title="3.4 短路或||和逻辑或|"></a>3.4 短路或||和逻辑或|</h3><ul>
<li>有一个为真就为真</li>
<li><strong>短路或||<strong>在第一个为真时第二个</strong>不再判断</strong></li>
<li>**逻辑或|**都判断</li>
<li><strong>开发中</strong>基本使用短路或||</li>
</ul>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5 赋值运算符"></a>3.5 赋值运算符</h3><ul>
<li><p>运算顺序<strong>从右向左</strong>，例如<code>int num = a + b + c</code>会先计算a+b+c</p>
</li>
<li><p><strong>复合运算符</strong>，<code>a += b</code>等价于<code>a = a + b</code>，<code>a -= b</code>等价于<code>a = a - b</code>，<code>b++</code>等价于<code>b = b + 1</code></p>
<ul>
<li><p>复合赋值运算符会进行<strong>类型转换</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b += <span class="number">3</span>;			<span class="comment">//它等价于b = (byte)(b + 3)，编译不会报错</span></span><br><span class="line"><span class="keyword">byte</span> b = b + <span class="number">3</span>;			<span class="comment">//编译会报错</span></span><br><span class="line">b++;					<span class="comment">//等价于b = (byte)(b + 1)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-6-三元运算符"><a href="#3-6-三元运算符" class="headerlink" title="3.6 三元运算符"></a>3.6 三元运算符</h3><ul>
<li><p>形式为：<u>条件表达式 ? 表达式1 : 表达式2;</u></p>
<ul>
<li><p>如果条件为真，则<strong>返回</strong>表达式1的值(此时<strong>表达式2</strong>并<strong>不执行</strong>)，否则<strong>返回</strong>表达式2的值，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> result = a &gt; b ? a++ : b--;</span><br><span class="line"><span class="comment">// 解读</span></span><br><span class="line"><span class="comment">// 1. a &gt; b 为 false</span></span><br><span class="line"><span class="comment">// 2. 返回 b--, 先返回 b的值,然后在 b - 1</span></span><br><span class="line"><span class="comment">// 3. 返回的结果是99 </span></span><br><span class="line">System.out.println(<span class="string">&quot;result=&quot;</span> + result);  <span class="comment">//输出99</span></span><br><span class="line">System.out.println(<span class="string">&quot;a=&quot;</span> + a);			<span class="comment">//输出10，因为表达式1不执行</span></span><br><span class="line">System.out.println(<span class="string">&quot;b=&quot;</span> + b);			<span class="comment">//输出98</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意细节：</p>
<ul>
<li><p>表达式1和表达式2要为可以赋给接收变量的类型(或可以自动转换/或者强制转换)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> c = a &gt; b ? <span class="number">1.1</span> : <span class="number">3.4</span>;				<span class="comment">//不可以，因为double不能赋给int</span></span><br><span class="line"><span class="keyword">int</span> c = a &gt; b ? (<span class="keyword">int</span>)<span class="number">1.1</span> : (<span class="keyword">int</span>)<span class="number">3.4</span>;	<span class="comment">//可以的</span></span><br><span class="line"><span class="keyword">double</span> d = a &gt; b ? a : b + <span class="number">3</span>;			<span class="comment">//可以的，满足 int -&gt; double</span></span><br></pre></td></tr></table></figure></li>
<li><p>三元运算符的<strong>本质</strong>是一个<strong>if else语句</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-键盘输入"><a href="#4-键盘输入" class="headerlink" title="4. 键盘输入"></a>4. 键盘输入</h2><ul>
<li>在程序开始要先导入<code>Scanner</code>:<code>import java.util.Scanner; </code><ul>
<li>然后要用<code>Scanner</code>定义方法：<code>Scanner 方法名 = new Scanner(System.in);</code></li>
</ul>
</li>
</ul>
<h3 id="4-1-input-next-："><a href="#4-1-input-next-：" class="headerlink" title="4.1 input.next()："></a>4.1 input.next()：</h3><ul>
<li>输入语句返回的类型是<strong>字符串</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入姓名： &quot;</span>);</span><br><span class="line">String name = scanner.next();			<span class="comment">//name定义的是String类型，看可以接收</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入年龄： &quot;</span>);</span><br><span class="line"><span class="keyword">int</span> age = scanner.nextInt();			<span class="comment">//age定义的是int类型，要用.nextInt()</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入成绩： &quot;</span>);</span><br><span class="line"><span class="keyword">double</span> grade = scanner.nextDouble();	<span class="comment">//同样要用.nextDouble()</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-接收字符的方法："><a href="#4-2-接收字符的方法：" class="headerlink" title="4.2 接收字符的方法："></a>4.2 接收<strong>字符</strong>的方法：</h3><ul>
<li><code>char gender = scanner.next().charAt(0);</code>，用返回的字符串进行强转。</li>
</ul>
<h3 id="4-3-判断字符串是否相等："><a href="#4-3-判断字符串是否相等：" class="headerlink" title="4.3 判断字符串是否相等："></a>4.3 判断字符串是否相等：</h3><ul>
<li><p>在键盘输入的时候如果<strong>输入的是字符串</strong>，那么<strong>两次输入赋值</strong>给两个变量的时候<strong>即使输入是一样的</strong>，在两变量<strong>仍然会判断为不相等</strong>，<strong>输入</strong>赋值的是<strong>int类型便不会</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String a = <span class="string">&quot;旺季&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;旺季&quot;</span>;</span><br><span class="line">String c = scanner.next();			<span class="comment">//输入旺季</span></span><br><span class="line">String d = scanner.next();			<span class="comment">//输入旺季</span></span><br><span class="line"><span class="keyword">int</span> num1 = scanner.nextInt();		<span class="comment">//输入5</span></span><br><span class="line"><span class="keyword">int</span> num2 = scanner.nextInt();		<span class="comment">//输入5</span></span><br><span class="line">System.out.println(a == b);			<span class="comment">//TRUE，正常赋值可以正确判断</span></span><br><span class="line">System.out.println(c == d);			<span class="comment">//FALSE</span></span><br><span class="line">System.out.println(num1 == num2);	<span class="comment">//TRUE</span></span><br><span class="line">System.out.println(a == c);			<span class="comment">//FALSE，即使是直接定义的String与赋值定义的判断也是相等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：可以将c和d的值赋值给新的字符串变量，新赋值的两个变量也不会相等，例如</span></span><br><span class="line">String e = c;</span><br><span class="line">String f = d;</span><br><span class="line">System.out.println(e);				<span class="comment">//输出： 旺季</span></span><br><span class="line">System.out.println(f);				<span class="comment">//输出： 旺季</span></span><br><span class="line">System.out.println(e == f);			<span class="comment">//同样是FALSE</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>“==”</strong>是看两个对象是否是同一个对象，也就是两个对象引用是否指向同一个对象,比较的是它们在<strong>内存中的存放地址</strong>；scanner读取的字符串就是生成的<strong>新对象</strong>，c,d只是内容相同，但是是不同的对象，地址不同，因此结果是false。</p>
</li>
<li><p><strong>equals()<strong>是比较两个对象的</strong>内容</strong>是否相等；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c.equals(d));  	<span class="comment">//true,他们内容相同</span></span><br><span class="line">System.out.println(c.equals(<span class="string">&quot;旺季&quot;</span>));		<span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;旺季&quot;</span>.equals(c));		<span class="comment">//true，一般选用这种比较方法而不是上一种，可以避免空指针！！</span></span><br><span class="line">System.out.println(e == c);			<span class="comment">//true,他们指向同一个对象，地址相同</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5. 位运算"></a>5. 位运算</h2><h3 id="5-1-原码反码补码"><a href="#5-1-原码反码补码" class="headerlink" title="5.1 原码反码补码"></a>5.1 原码反码补码</h3><ul>
<li><strong>正数</strong>的原码、反码、补码都都一样（三码合一）</li>
<li>负数的反码＝符号位不变，其他位置取反</li>
<li><strong>负数</strong>的<strong>补码</strong>=负数的反码+1，负数的反码=负数的补码-1</li>
<li><strong>0</strong>的反码和补码都是0</li>
<li><strong>计算机运算</strong>的时候都是以<strong>补码</strong>的方式来运算的**<u><em>（因为补码可以将正数负数统一起来）</em></u>**<ul>
<li><strong>计算步骤</strong>：<ol>
<li>先得出数字的原码</li>
<li>然后算出它的补码</li>
<li><strong>用补码操作运算</strong>完了过后，最后要<strong>转回原码</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="5-2-位移运算"><a href="#5-2-位移运算" class="headerlink" title="5.2 位移运算"></a>5.2 位移运算</h3><ul>
<li><strong>&gt;&gt;<strong>叫</strong>算术右移</strong> <ul>
<li>计算方法：例如-5&gt;&gt;2，先求出-5的<strong>补码</strong>（别忘了任何运算都是补码），然后整体右移2位，符号位不变，用符号为补溢出的高位。</li>
</ul>
</li>
<li><strong>&lt;&lt;<strong>叫</strong>算术左移</strong><ul>
<li>计算方法：同样先求出<strong>补码</strong>，然后符号位不变，低位补0</li>
</ul>
</li>
<li>在计算<strong>正数</strong>的时候由于<strong>三码合一</strong>，因此相当于直接对原码进行左移右移操作，而二进制逢2进位，因此<strong>右移一位</strong>相当于整体<strong>除以2</strong>，<strong>左移一位</strong>相当于整体<strong>乘以2</strong>。例如：5&gt;&gt;2=5/2/2=1</li>
<li><strong>&gt;&gt;&gt;<strong>叫</strong>无符号右移</strong>(没有无符号左移)</li>
</ul>
<h2 id="6-程序控制结构"><a href="#6-程序控制结构" class="headerlink" title="6. 程序控制结构"></a>6. 程序控制结构</h2><ul>
<li>嵌套<strong>不要超过3层</strong>，可读性不好</li>
</ul>
<h3 id="6-1-switch"><a href="#6-1-switch" class="headerlink" title="6.1 switch"></a>6.1 switch</h3><ul>
<li>switch(<strong>表达式</strong>){case <strong>常量</strong>；case <strong>常量</strong>…}<ul>
<li>case后面必须是<strong>常量</strong>（或者常量表达式，例如1+1），<strong>表达式</strong>里的之计算出来必须<strong>是常量</strong>，对照执行相应的case(<strong>在java中有值返回的就是表达式</strong>，单个字符也是，例如可以switch(‘a’))<ul>
<li><p>表达式返回值必须是：<strong>byte,short,int,char,enum,String</strong>这几种类型</p>
</li>
<li><p>表达式的<strong>数据类型</strong>应该和case后面的常量类型<strong>一致</strong>，或者是可以<strong>自动转换</strong>(指case后面的常量能自动转成表达式的类型<strong>或者</strong>表达式的类型能转成case后常量的类型)成可以比较的类型</p>
</li>
<li><p>不同case的常量<strong>不能相同</strong></p>
</li>
<li><p>case里面的执行语句可以为空。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> :</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span> :</span><br><span class="line">System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211216092013689.png" alt="image-20211216092013689"><ul>
<li>如果执行了第一个case但是它没有break，那么将直接执行<strong>第二个case而不需要判断</strong>是否满足第二个case（<strong>穿透现象</strong>），以此类推。如果满足了第一个case，但是所有的case都没有break语句，那么将执行所有语句。</li>
<li>由上图得知，<strong>执行default语句</strong>的情况是：<ol>
<li>最后一个case的<strong>判断条件不满足</strong></li>
<li><strong>进入了</strong>最后一个case的执行语句（有可能是满足case条件进入的，也有可能是上一个case没有break语句直接进入的），<strong>没有break语句</strong><ul>
<li>执行完default就结束，不管它有没有break</li>
<li>可以没有default语句，此时所有case都不满足就无事发生</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>switch和if的选用</strong>：在判断的具体数值不多，而且符合<strong>byte,short,int,char,enum,String</strong>这6种类型的时候建议使用switch;其他情况比如区间判断，使用if。</li>
</ul>
<h4 id="6-1-1-switch配合枚举"><a href="#6-1-1-switch配合枚举" class="headerlink" title="6.1.1 switch配合枚举"></a>6.1.1 switch配合枚举</h4><ul>
<li><p>```java<br>enum Color{</p>
<pre><code>RED(255,0,0),BLUE(0,0,255),BLACK(0,0,0),
YELLOW(255,255,0),GREEN(0,255,0);
private int redValue;
private int greenValue;
private int blueValue;
Color(int redValue, int greenValue, int blueValue) &#123;
    this.redValue = redValue;
    this.greenValue = greenValue;
    this.blueValue = blueValue;
&#125;
</code></pre>
<p>}</p>
<p>switch (Color.RED){</p>
<pre><code>case BLACK://这里不用带上 Color 类名，直接写里面的常量名
    System.out.println(&quot;en&quot;);
    break;
case RED:
    System.out.println(&quot;gg&quot;);
    break;//所有枚举类里面创建的枚举对象都可以写上，这里做个样子不写了
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **`switch`后面括号里放入枚举类里面创建的对象实例，case匹配创建的各个常量**。</span><br><span class="line"></span><br><span class="line">### 6.2 for循环</span><br><span class="line"></span><br><span class="line">+ **循环变量的初始化以及迭代不是必须写在括号里**，例如：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  int i = 1;</span><br><span class="line">  for( ; i &lt;= 5 ; )&#123;</span><br><span class="line">      System.out.println();</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>适用于有可能在其他地方也要用到i，使i的<strong>作用域变大</strong></p>
</li>
<li><p><strong>注意</strong>：</p>
<ul>
<li><p>从这里可以看出：<strong>在for循环之前声明的全局变量</strong>对for循环内部同样生效。如果在<strong>for循环之前</strong>声明了<code>int i = 0</code>，for循环可以直接使用这个i，如果for循环初始化的时候也进行<code>int i = 0</code>，那么<strong>变量重复声明，编译错误</strong>。</p>
</li>
<li><p>但是<strong>for循环内部声明的变量</strong>便只作用于for循环自己，如果如果是<strong>for循环<u>里面</u><strong>声明的变量例如<code>int k = 0</code>，那么在这个k的作用域便只是在for循环里面，在</strong>for循环之后</strong>的代码中可以再次声明<code>int k </code>而不会报错。</p>
</li>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &gt; <span class="number">4</span>; i++)&#123;				<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">6</span>;								<span class="comment">//正确</span></span><br><span class="line">System.out.println(k);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>中间的条件判断不管写的多复杂，返回值必须是<strong>true或false</strong></p>
</li>
<li><p><code>for(;;)</code>表示<strong>无限循环</strong></p>
</li>
<li><p>循环变量初始化可以有<strong>多条初始化语句</strong>，但是<strong>类型必须一样，中间用逗号隔开</strong>；循环变量迭代也可以有<strong>多条变量迭代语句，中间用逗号隔开</strong>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j= <span class="number">0</span>; i &lt; <span class="number">44</span>; i++,j--)</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>对于for循环<strong>里面的循环体</strong>而言，<strong>for循环外面</strong>定义的变量和<strong>for循环开始时初始化定义的变量</strong>都是<strong>“全局变量”</strong>，**<u>即不论执行多少次循环这个变量的变化都可以被每一次不同的循环感知</u><strong>。但是如果</strong>在for循环里面的循环体处定义变量<strong>，他的作用范围是当前的<code>&#123;&#125;</code>，每次循环结束退出<code>&#123;&#125;</code>然后判断是否满足循环条件，满足条件则重新进入<code>&#123;&#125;</code>，因此这种变量</strong>只针对当此循环生效<strong>，在下一次循环的时候仍然可以重新声明而</strong>不会提示重复定义变量的错误**，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;				<span class="comment">//正确，循环体定义的变量仅针对此次循环，不会重复</span></span><br><span class="line">    System.out.println(j);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;				<span class="comment">/*错误,循环初始化变量时定义了k，这个k对于循环体而言是“全局”的，不可重复*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-break"><a href="#6-3-break" class="headerlink" title="6.3 break"></a>6.3 break</h3><h4 id="6-3-1-标签"><a href="#6-3-1-标签" class="headerlink" title="6.3.1 标签"></a>6.3.1 标签</h4><ul>
<li><p><strong>break语句</strong>出现在多层嵌套循环中时，可以通过<strong>标签</strong><u>指定要退出哪一层循环</u>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label <span class="number">1</span>:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">lable <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span> lable1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>标签</strong>用来给每一层循环添加标识符，<strong>不一定要用lable 1 / lable 2</strong>，可以使用任意符合规范的命名，例如abc1 / abc2也可以</li>
<li>break后面指定哪个label就退出此label对应的那一层</li>
<li>实际开发中<strong>尽量不要使用标签</strong>，可读性会变差</li>
<li>如果不指定标签，则<strong>默认指定最近的循环体</strong></li>
</ul>
</li>
<li><p><strong>continue语句</strong>的标签用法和break一样</p>
</li>
</ul>
<h3 id="6-4-return"><a href="#6-4-return" class="headerlink" title="6.4 return"></a>6.4 return</h3><ul>
<li><p>当<strong>return用在方法时，表示跳出方法，如果使用在主方法main，则表示退出程序</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">3</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;韩顺平教育 &quot;</span>+i);</span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">/*当return用在方法时，表示跳出方法，如果使用在main,表示退出程</span></span><br><span class="line"><span class="comment">			序*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;go on..&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  此处输出结果为：Hello World!</span></span><br><span class="line"><span class="comment">				Hello World!</span></span><br><span class="line"><span class="comment">				韩顺平教育 3</span></span><br><span class="line"><span class="comment">	不会输出后面的 go on，因为return不是退出循环，是退出方法，此处退出主方法即程序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1 概念"></a>7.1 概念</h3><ul>
<li><p><code>数组名.length</code>得到数组长度</p>
</li>
<li><p>同一数组只能放<strong>相同数据类型</strong>，或者满足<strong>自动类型转化</strong></p>
<ul>
<li>数组的元素可以是任何数据类型，基本数据类型和引用类型（数组、接口等），只是不能混用</li>
</ul>
</li>
<li><p><code>int[] a = new int[5]</code>和<code>int a[] = new int[5]</code>等价,表示创建一个名叫a的数组，长度为5，放入的是Int类型的数据，<strong>不指定默认是0</strong>(double是0.0，<strong>具体看是什么类型</strong>)</p>
<ul>
<li>**<u>默认值</u>**：<img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211220163657420.png" alt="image-20211220163657420"></li>
<li>**<code>int a[] = &#123;1,2,5,6,7&#125;</code>**同样也是创建数组，适用于事先知道了元素的具体值并且值不多</li>
</ul>
</li>
<li><p><strong>基本类型的变量</strong>如果是临时变量，只要定义了，就会分配内存空间，不管是否被赋值；如果是作为对象的属性出现，只要该对象<strong>不实例化</strong>，就不会分配内存空间。</p>
<blockquote>
<p>可以先<code>int a[]</code>声明数组，它不会占用内存，这时a是null，不能存放数据。然后a = new int[5]，分配内存，可以存放数据</p>
</blockquote>
</li>
<li><p><strong>数组是引用类型</strong>，本质是<strong>对象</strong></p>
<ul>
<li><strong>因此如果在递归调用中修改了数组，那么即使递归返回到上一层，该数组也不会恢复原状，因为数组是引用类型</strong>。</li>
</ul>
</li>
</ul>
<h3 id="7-2-数组赋值"><a href="#7-2-数组赋值" class="headerlink" title="7.2 数组赋值"></a>7.2 数组赋值</h3><ul>
<li><p><strong>基本数据类型</strong>赋值时<strong>值拷贝</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b = <span class="number">3</span>;			<span class="comment">//此时b的值是3，a的值还是2，这个赋值仅仅是拷贝了a的值</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>数组</strong>在默认情况下是<strong>引用传递</strong>，<strong>赋的是地址</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = a;</span><br><span class="line">b[<span class="number">1</span>] = <span class="number">4</span>;			<span class="comment">//此时b数组是&#123;1,4,3&#125;，同时a数组也是&#123;1,4,3&#125;，因为a,b指向同一个地址，数组的赋值和基本数据类型赋值不一样</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211220190754830.png" alt="image-20211220190754830"></p>
</li>
<li><p><strong>数组拷贝</strong>需要先为新数组<strong>创建一个新的空间</strong>，再<strong>遍历原数组</strong>把值拷贝过去，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[] = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length];			<span class="comment">//开辟一个新空间，长度和原数组一致</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">	arr2[i] = arr1[i];						<span class="comment">//每个元素逐一拷贝</span></span><br><span class="line">&#125;</span><br><span class="line">arr2[<span class="number">0</span>] = <span class="number">100</span>;			<span class="comment">//此时arr2[]=&#123;100,20,30&#125;，arr1[]=&#123;10,20,30&#125;，因为他们指向的是不同的地址</span></span><br><span class="line"></span><br><span class="line">==================================</span><br><span class="line">arr1 = arr2;			<span class="comment">//此时arr1指向arr2的地址，arr1原本地址空间的数据没人指向，这片空间会被jvm机回收销毁</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211220192504580.png" alt="image-20211220192504580"></p>
</li>
<li><p>```java<br>String c[] = {“a”,”b”,”c”};                //正确<br>String c[] = new String{“a”,”b”,”c”};    //错误，</p>
<p>String c[] = new String[]{“a”,”b”,”c”};    //正确，表示给c开辟空间然后逐一赋值，但是不能指定数组长度，因为系统不知道要赋多少个值<br>String c[] = new String[3]{“a”,”b”,”c”};    //错误，不能指定长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **特别注意，先声明长度再赋值时只能逐一赋值，例如**</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  String c[] = new String[3];</span><br><span class="line">  c = &#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;&#125;			//错误，只能逐一赋值,其他类型也一样,系统不知道会赋多少个值</span><br><span class="line">  </span><br><span class="line">  String c[] = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;	//这种写法相当于由系统自动根据长度开辟等长空间</span><br><span class="line">  String c[] = new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;; //这里和上面一个意思，由系统根据长度开辟空间，不能指定长度</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-二维数组"><a href="#7-3-二维数组" class="headerlink" title="7.3 二维数组"></a>7.3 二维数组</h3><ul>
<li><p>创建：<code>类型[][] 数组名 = new 类型[大小][大小]</code>,第一个大小代表<strong>有多少个一位数组</strong>，第二个大小代表每个一位数组有多少元素 </p>
<ul>
<li><p><strong>等价的声明方式</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr;</span><br><span class="line"><span class="keyword">int</span> arr[][];</span><br><span class="line"><span class="keyword">int</span>[] arr[];		<span class="comment">//这三种等价，可以理解为创建一个一维数组，但是这个一维数组的每个元素是数组，即创建二维数组</span></span><br><span class="line">==========================================</span><br><span class="line"><span class="keyword">int</span>[] x,y[];		<span class="comment">//这里意思是创建一维数组x，二维数组y</span></span><br></pre></td></tr></table></figure></li>
<li><p>但是<strong>每个一维数组有多少元素可以不一致</strong>，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];	<span class="comment">//表示有两个一位数组，每个数组有三个元素</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">====================================</span><br><span class="line"><span class="keyword">int</span> arr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];	<span class="comment">/*表示有两个一位数组，每个数组元素不确定,此处相当于只开辟了存放两个一位数组空间，并没有开辟存放数据的空间，这两个一位数组并没有指向存放数据的地址，索引是空的（null）*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    arr1[i] = <span class="keyword">new</span> <span class="keyword">int</span>[i + <span class="number">1</span>];	<span class="comment">//此处给每个以为数组开辟存放数据的空间，这个new很重要，不然无法存放数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>也可<strong>先声明再new</strong>：<code>int arr[][];  arr = new int[2][3];</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-3-1-二维数组存在形式"><a href="#7-3-1-二维数组存在形式" class="headerlink" title="7.3.1 二维数组存在形式"></a>7.3.1 二维数组存在形式</h4><ul>
<li>二维数组可以看成元素是数组的以为数组，所以可以看成栈中的引用地址指向堆中的一个一位数组空间，这个空间存放的元素是数组，因此存放的是地址，这个地址再指向真正的数据空间</li>
</ul>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221092728909.png" alt="image-20211221092728909"></p>
<h2 id="8-类与对象"><a href="#8-类与对象" class="headerlink" title="8. 类与对象"></a>8. 类与对象</h2><ul>
<li>类是<strong>数据类型</strong>，对象是是具体的实例</li>
<li>既然类是数据类型，那么就可以用它来声明变量</li>
</ul>
<h3 id="8-1-创建对象"><a href="#8-1-创建对象" class="headerlink" title="8.1 创建对象"></a>8.1 创建对象</h3><ul>
<li><p>先声明再创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat;		<span class="comment">//创建了cat变量名，存放的地址是null</span></span><br><span class="line">cat = <span class="keyword">new</span> Cat(); <span class="comment">//开辟Cat()空间，将这个空间的地址赋给cat</span></span><br></pre></td></tr></table></figure></li>
<li><p>直接创建：<code>Cat cat = new Cat();</code></p>
</li>
</ul>
<h3 id="8-2-对象在内存中的存在形式"><a href="#8-2-对象在内存中的存在形式" class="headerlink" title="8.2 对象在内存中的存在形式"></a>8.2 对象在内存中的存在形式</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221203412974.png" alt="image-20211221203412974"></li>
<li><strong>类是引用类型</strong>，<strong>存放地址</strong>，而它定义了<strong>三个属性</strong>（也叫<strong>成员变量</strong>/<strong>字段</strong>field），则在这个地址指向的内存堆中开辟三块；cat.name是字符串类型，<strong>字符串是引用类型，因此同样存放地址</strong>，但不过它的<strong>地址指向的是方法区中的常量池</strong>，cat.age是<strong>基本数据类型，直接存放</strong>。</li>
</ul>
<h4 id="8-2-1-类创建过程"><a href="#8-2-1-类创建过程" class="headerlink" title="8.2.1 类创建过程"></a>8.2.1 类创建过程</h4><ul>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.name = <span class="string">&quot;小白&quot;</span>;</span><br><span class="line">cat.age = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>创建类</strong>的时候<strong>首先</strong>会把它的<strong>类信息加载到方法区</strong>，这是第一步。包括<strong>属性信息</strong>和<strong>行为（方法信息）</strong>。然后才是在堆里开空间，<strong>每个属性</strong>也会有一个小框框，<strong>赋默认值</strong>，然后把这个空间的<strong>地址赋给变量名cat</strong>，即这个变量就指向了这片空间。<ul>
<li>在执行<code>cat.name = &quot;小白&quot;</code>的时候，他是字符串常量，<strong>字符串常量会放到方法区里的常量池</strong>，从cat变量名出发由地址找到<code>.name</code>属性的位置，将它原本的<strong>默认值null</strong>改为常量池里面”小白”的<strong>地址</strong>。</li>
<li>在执行<code>cat.age = 12</code>的时候，他是<strong>基本数据类型</strong>（直接修改，不引用），从cat变量名存放的地址出发找到对应空间里的.age属性的位置，将它的<strong>默认值0修改为12</strong>。</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221203701691.png" alt="image-20211221203701691"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-3-属性-成员变量-字段"><a href="#8-3-属性-成员变量-字段" class="headerlink" title="8.3 属性/成员变量/字段"></a>8.3 属性/成员变量/字段</h3><ul>
<li><strong>属性可以是基本数据类型也可以是引用类型</strong></li>
<li><strong>属性如果不赋值，会有默认值，规则和数组一致</strong></li>
</ul>
<h3 id="8-4-java内存的结构"><a href="#8-4-java内存的结构" class="headerlink" title="8.4 java内存的结构"></a>8.4 java内存的结构</h3><ol>
<li><p><strong>栈</strong>： 一般存放基本数据类型(局部变量)</p>
</li>
<li><p><strong>堆</strong>： 存放对象(Cat cat , 数组等)</p>
</li>
<li><p><strong>方法区</strong>：常量池(常量，比如字符串)， <strong>类加载信息(类信息只会加载一次，如果再创建此类，不会再加载)</strong></p>
</li>
<li><p><strong>示意图</strong>：</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211221212105452.png" alt="image-20211221212105452"></p>
</li>
</ol>
<h3 id="8-5-成员方法"><a href="#8-5-成员方法" class="headerlink" title="8.5 成员方法"></a>8.5 成员方法</h3><ul>
<li><strong>方法里面不能再定义方法</strong></li>
</ul>
<h4 id="8-5-1-方法调用机制"><a href="#8-5-1-方法调用机制" class="headerlink" title="8.5.1 方法调用机制"></a>8.5.1 方法调用机制</h4><ul>
<li><p>程序执行到调用方法会<strong>开辟一个<u>独立</u>的栈空间</strong>，没有名字，这里是为了理解写的名字</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211222110208515.png" alt="image-20211222110208515"></p>
</li>
<li><p>方法调用完成后return一个值给了<code>int returnRes</code>，此时<strong>方法执行结束，它的栈空间会被销毁</strong></p>
</li>
<li><p>方法执行完后继续执行主程序里的代码<code>System..</code>，这句执行完后主程序里的代码全部执行结束，<strong>main栈也被销毁</strong>，程序退出</p>
</li>
</ul>
<ul>
<li><p><strong>同一个类中的方法在调用对方时可以直接调用</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        System.out.print(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print(<span class="number">10</span>);				<span class="comment">//这里直接调用即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>不同类中的方法在调用对方时，要先创建对象</strong>，然后用<code>对象名.方法名</code>调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;B中的方法bb被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B use = <span class="keyword">new</span> B();</span><br><span class="line">        use.bb();			<span class="comment">//输出 &quot;B中的方法bb被调用&quot;</span></span><br><span class="line">        System.out.print(<span class="string">&quot;继续执行aa方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>跨类方法调用涉及到访问修饰符和包</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="8-5-2-访问修饰符"><a href="#8-5-2-访问修饰符" class="headerlink" title="8.5.2 访问修饰符"></a>8.5.2 访问修饰符</h4><ul>
<li>访问修饰符的作用是控制方法使用的范围<ul>
<li><p>有四种(public,protected,private,默认)，如果不写就是<strong>默认访问</strong></p>
<ol>
<li><p><strong>公开级别</strong>：用<strong>public</strong>修饰，对外公开</p>
</li>
<li><p><strong>受保护级别</strong>：用<strong>protected</strong>修饰，对子类和同一个包中的类公开</p>
</li>
<li><p><strong>默认级别</strong>：<strong>没有修饰符号</strong>，向同一个包的类公开，不对子类公开</p>
</li>
<li><p><strong>私有级别</strong>：用<strong>private</strong>修饰，只有类本身可以访问，不对外公开</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224075334189.png" alt="image-20211224075334189"></p>
</li>
</ol>
</li>
<li><p>访问修饰符可以修饰<strong>属性，方法，类</strong>。但是只有 <strong>public和默认</strong> 修饰符<strong>可以修饰类</strong>。</p>
</li>
<li><p>这里的默认修饰符在子类不能访问指的是子类与父类不在同一个包的时候不能访问，在同一个包不同类中只有private不能访问。</p>
</li>
</ul>
</li>
</ul>
<h4 id="8-5-3-返回值"><a href="#8-5-3-返回值" class="headerlink" title="8.5.3 返回值"></a>8.5.3 返回值</h4><ol>
<li><strong>一个方法最多只有一个返回值</strong>，如果要返回多个值，可以返回数组。</li>
<li>返回类型可以是<strong>任意类型</strong>，包括<strong>数组，对象</strong>。</li>
<li>返回值类型不是viod就必须要return一个值，否则<strong>可以没有</strong>或者**光<code>return;</code>**。<ul>
<li><strong>返回值类型</strong>和<code>return</code><strong>返回的类型</strong>必须兼容（<strong>自动转化</strong>）</li>
</ul>
</li>
</ol>
<h4 id="8-5-4-参数列表"><a href="#8-5-4-参数列表" class="headerlink" title="8.5.4 参数列表"></a>8.5.4 参数列表</h4><ul>
<li>实参的<strong>顺序</strong>和<strong>个数</strong>都必须和形参一致，而且<strong>类型要兼容</strong></li>
<li><strong>形参如果是基本数据类型</strong>，那么无论他在方法里如何变化，方法结束后实参不变<ul>
<li>因为执行方法的时候开辟一个<strong>新栈</strong>，而<strong>基本数据类型</strong>是<strong>直接存放在栈里</strong>的，所以这个新栈里如何对参数操作都对实参没影响</li>
</ul>
</li>
<li><strong>形参如果是引用类型</strong>(数组，对象)，那么方法里参数的变化会影响实参结果<ul>
<li><strong>虽然是两个不同的栈</strong>，但引用类型存放的是地址，他们会<strong>指向堆空间的同一个地址</strong></li>
</ul>
</li>
</ul>
<h4 id="8-6-递归调用"><a href="#8-6-递归调用" class="headerlink" title="8.6 递归调用"></a>8.6 递归调用</h4><ul>
<li><p>在递归需要一个返回值的时候，如果递归使用在<code>if-else if</code>中，那么如果没有<code>else</code>语句或者<code>else</code>语句里面没有<code>return</code>，就会被判断缺少<code>return</code>语句，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">number</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n = <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> number(n-<span class="number">1</span>) + number(n-<span class="number">2</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;						<span class="comment">//会提示在这里缺少return</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">number</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n = <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number(n-<span class="number">1</span>) + number(n-<span class="number">2</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;						<span class="comment">//这时编译正确</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-7-方法重载（overload）"><a href="#8-7-方法重载（overload）" class="headerlink" title="8.7 方法重载（overload）"></a>8.7 方法重载（overload）</h4><ul>
<li><p>同一个类中<strong>可以有很多个<u>方法同名</u><strong>（</strong>不重名不构成重载</strong>），但是要求他们的<strong>形参列表不一致</strong>，包括<strong>参数个数，对应位置上的参数类型</strong>不完全相同(跟<strong>形参名</strong>与<strong>返回类型</strong>无关)，就可以构成重载，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">say(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">say(<span class="keyword">int</span> a, <span class="keyword">double</span> b);</span><br><span class="line">say(<span class="keyword">double</span> a, <span class="keyword">int</span> b);</span><br><span class="line">say(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c);</span><br></pre></td></tr></table></figure>

<p>上述四个方法构成重载</p>
</li>
<li><p>如果传入的实参与形参<strong>类型不一致</strong>，若此时实参类型满足自动转换成形参类型，则可以匹配</p>
<p>但如果此时有另有一个方法<strong>类型都一致</strong>，则会<strong>优先匹配</strong>此方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, <span class="keyword">int</span> n3)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> n1, <span class="keyword">double</span> n2, <span class="keyword">double</span> n3)</span></span>;</span><br><span class="line">max(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);			<span class="comment">//匹配第一个</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-8-可变参数"><a href="#8-8-可变参数" class="headerlink" title="8.8 可变参数"></a>8.8 可变参数</h4><ul>
<li><p><strong>方法名称相同，功能相同, 参数个数不同</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;<span class="comment">//2个数的和</span></span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3)</span> </span>&#123;<span class="comment">//3个数的和</span></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 + n3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, <span class="keyword">int</span> n3, <span class="keyword">int</span> n4)</span> </span>&#123;<span class="comment">//4个数的和</span></span><br><span class="line">    <span class="keyword">return</span> n1 + n2 + n3 + n4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. int... 表示接受的是可变参数，类型是int ,即可以接收多个int(0-多) </span></span><br><span class="line">	<span class="comment">//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组</span></span><br><span class="line">	<span class="comment">//3. 遍历 nums 求和即可</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可变参数的<strong>形参如果接收的是int</strong>，<strong>实参</strong>可以为<strong>int类型的数组</strong>,但<strong>只能是一个数组</strong>，如果需要用<strong>可变参数接收多个数组</strong>，**形参的类型要用int[]**，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] arr1 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		T t1 = <span class="keyword">new</span> T();</span><br><span class="line">		t1.f1(arr,arr1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>[]... nums)</span> </span>&#123;		<span class="comment">//int[]... 代表可以接受多个int[],此时nums相当于二维数组</span></span><br><span class="line">		System.out.println(nums[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(String str, <span class="keyword">double</span>... nums)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>一个形参列表中只能出现一个可变参数</strong></p>
</li>
</ul>
<h4 id="8-9-作用域"><a href="#8-9-作用域" class="headerlink" title="8.9 作用域"></a>8.9 作用域</h4><ul>
<li><p>对于<strong>一个类</strong>来说<strong>属性就是全局变量</strong>，作用于类中的所有区域，同时<strong>其他类通过对象调用也可以使用到它</strong>。<strong>除了属性之外</strong>的变量叫<strong>局部变量</strong>，例如<strong>成员方法中定义的变量就是局部变量（还有代码块中的变量）</strong>，只作用于这个方法。</p>
<ul>
<li><p><strong>属性可以加修饰符，局部变量不可以加修饰符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">10</span>;		<span class="comment">//正确，属性可以加修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">5</span>;		<span class="comment">//错误，局部变量不能加修饰符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**属性可以不赋值，因为属性<u>有默认值</u>，局部变量必须赋值后才能使用，它<u>没有默认值</u>**，直接使用会提示没有初始化。</p>
</li>
<li><p><strong>属性跟局部变量可以重名，使用的时候遵循就近原则。</strong>同一个成员方法中局部变量便不能重名。</p>
</li>
</ul>
<h3 id="8-6-匿名对象"><a href="#8-6-匿名对象" class="headerlink" title="8.6 匿名对象"></a>8.6 匿名对象</h3><ul>
<li><p><strong>在new的时候不把它的地址赋给变量</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> a().say();		<span class="comment">//匿名对象,这里表示创建后马上调用方法say(),这条语句过后被销毁</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>匿名对象只能用一次，因为没有引用，使用一次后会被销毁</strong>。</p>
</li>
</ul>
<h2 id="9-构造器"><a href="#9-构造器" class="headerlink" title="9. 构造器"></a>9. 构造器</h2><h3 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义"></a>9.1 定义</h3><ul>
<li><strong>构造方法又叫构造器(constructor)<strong>，是类的一种特殊方法，主要作用是完成对</strong>新对象</strong>的<strong>初始化</strong>（并非创建对象）。<ol>
<li><p>构造器的<strong>修饰符</strong>可以默认， 也可以是 public protected private</p>
</li>
<li><p>构造器<strong>没有返回值</strong>，也不能写<code>void</code>。</p>
</li>
<li><p><strong>方法名 和 类名 必须一样</strong>。</p>
</li>
<li><p>参数列表和成员方法一样的规则</p>
</li>
<li><p><strong>构造器的调用, 由系统完成</strong>，即在<strong>创建对象时</strong>，系统<strong>自动调用</strong>对应类的构造器<strong>完成</strong>对象的<strong>初始化</strong>。</p>
</li>
<li><p><strong>构造器可以有多个，构成重载</strong>。</p>
</li>
<li><p>在<strong>没有定义构造器</strong>的时候，系统会给类自动生成一个<strong>默认无参构造器</strong>，<strong>修饰符是默认类型</strong>（即不写），参数列表是空，例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">God</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	默认构造器：</span></span><br><span class="line"><span class="comment">    	God()&#123;		//形参列表为空，访问修饰符默认</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    	&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">God mid = <span class="keyword">new</span> God();	<span class="comment">//之所以new一个没有构造器的新对象时后面要加小括号，就是因为有默认构造器，是空的参数列表</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以通过<strong>javap</strong>对字节码文件进行<strong>反汇编</strong>，<code>javap God.class</code>就可以<strong>看到</strong>字节码文件中有没有生成<strong>默认构造器</strong>，也可以不写.class，即<code>javap God</code>，会自动识别。</li>
<li><strong>自己定义构造器后默认无参构造器就被覆盖，不能<code>new God()</code>这样创建新对象，除非显式的再定义无参构造器，即两个构成重载</strong>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="9-2-考虑构造器后的对象创建流程"><a href="#9-2-考虑构造器后的对象创建流程" class="headerlink" title="9.2 考虑构造器后的对象创建流程"></a>9.2 考虑构造器后的对象创建流程</h3><ul>
<li><p>对象创建流程，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">90</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Person (String pname, <span class="keyword">int</span> page)&#123;</span><br><span class="line">        name = pname;</span><br><span class="line">        age = page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;导演&quot;</span>,<span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>第一步在<strong>方法区加载类信息，只会加载一次</strong>。</li>
<li><ul>
<li><strong>先是默认初始化</strong>：在堆空间开辟对象的空间，开辟了就有地址，此时<strong>两个属性</strong>age,name也被创建，他们的值<strong>首先是默认值</strong>，即首先是<code>age = 0; name = null;</code>，</li>
<li><strong>然后是显式初始化</strong>：会将属性定义的时候自己设置的值赋给属性，即<strong>此时age = 90，name还是默认值</strong>；</li>
<li><strong>最后构造器初始化</strong>：此时<code>name</code>的值变成了<code>&quot;导演&quot;</code>,<code>age</code>的值变成了<code>50</code>。</li>
</ul>
</li>
<li>此时把对象的地址返回给p，此时p才指向对象</li>
</ol>
</li>
</ul>
<h3 id="9-3-this关键字"><a href="#9-3-this关键字" class="headerlink" title="9.3 this关键字"></a>9.3 this关键字</h3><ul>
<li><p>如果想创建<strong>构造器的时候形参直接用属性名字</strong>，会出问题，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        name = name;</span><br><span class="line">        age = age;			<span class="comment">/*此时由于属性和局部变量可以重名，遵循就近原则，那么</span></span><br><span class="line"><span class="comment">        这里的name = name的两个name都是局部变量，不影响属性，则起不到初始化属性的作用*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;bin&quot;</span>,<span class="number">15</span>);</span><br><span class="line">System.out.print(p.age + <span class="string">&quot; &quot;</span> + p.name);	<span class="comment">/*输出0 null,因为属性没被初始化，构造</span></span><br><span class="line"><span class="comment">器里面的都是局部变量，不影响属性*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以使用<code>this</code>关键字解决问题，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;		<span class="comment">//this代表本对象的属性</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;bin&quot;</span>,<span class="number">15</span>);</span><br><span class="line">System.out.print(p.age + <span class="string">&quot; &quot;</span> + p.name);	</span><br></pre></td></tr></table></figure></li>
<li><p>可以把this看成一个<strong>隐藏的属性，他指向自己这个对象的地址</strong>，<code>this.age</code>则表示从这个地址出取<code>age</code>。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211223123006507.png" alt="image-20211223123006507"></p>
</li>
</ul>
</li>
</ul>
<h4 id="9-3-1-hashcode"><a href="#9-3-1-hashcode" class="headerlink" title="9.3.1 hashcode"></a>9.3.1 hashcode</h4><ul>
<li><p>由 Object 类定义的 hashCode 方法确实会<strong>针对不同的对象返回不同的整数</strong>。（这一般是通过将该对象的<strong>内部地址转换成一个整数</strong>来实现的（java是跑在虚拟机上的，无法得到地址，c可以，它是更底层的语言 ），但是 JavaTM 编程语言不需要这种实现技巧。） </p>
<ul>
<li><p><strong>hashcode不是真正的地址</strong>，但是可以当作地址使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;		</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.hashCode());<span class="comment">//此处输出的hashCode和下面输出的一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;bin&quot;</span>,<span class="number">15</span>);</span><br><span class="line">System.out.print(p.hashCode());		<span class="comment">//这里输出的和上面一致</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从这里两个hashCode值相同可以判断<strong>this和p存放了的相同的地址</strong>，即都是此对象的引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-3-2-this细节"><a href="#9-3-2-this细节" class="headerlink" title="9.3.2 this细节"></a>9.3.2 this细节</h4><ul>
<li><p><strong>在一个类中不同方法里调用另一个方法有两种方式</strong></p>
</li>
<li><p><strong>this可以访问构造器（称为构造器复用）</strong>，但是只能在一个<strong>构造器中去访问另一个构造器</strong>，不能在普通方法中使用，同时这种调用语句必须放在构造器方法里的第一条。</p>
</li>
<li><p><strong>this不能再类定义的外部使用，只能在类定义的方法中使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;bin&quot;</span>,<span class="number">38</span>);		<span class="comment">//在这个构造器中访问下面那个构造器，这条语句必须放在第一条，这是规定</span></span><br><span class="line">        System.out.print(<span class="string">&quot;无参构造器被调用&quot;</span>);	<span class="comment">//这条要在后面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">T</span><span class="params">(String tname, <span class="keyword">int</span> tage)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一种，可以直接调用</span></span><br><span class="line">        f1();</span><br><span class="line">        <span class="comment">//第二种，使用this,区别在于继承</span></span><br><span class="line">        <span class="keyword">this</span>.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T a = <span class="keyword">new</span> T();</span><br><span class="line">a.<span class="keyword">this</span>.f1();	<span class="comment">//错误，不能再外部使用this</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-包"><a href="#10-包" class="headerlink" title="10. 包"></a>10. 包</h2><ul>
<li>包的<strong>本质</strong>实质上就是<strong>创建不同的文件夹/目录来保存类文件</strong>。</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211223190354498.png" alt="image-20211223190354498"></li>
<li><strong><code>import java.util.*</code>表示导入<code>java.util</code>下的全部类</strong></li>
<li><code>package</code>的作用是<strong>声明当前类所在的包</strong>，需要放在<strong>类的最上面</strong>，一个类中最多<strong>只有一句</strong><code>package</code>。<ul>
<li><strong><code>import</code>需要放在<code>package</code>和类定义之间</strong>。</li>
</ul>
</li>
</ul>
<h2 id="11-封装、继承、多态"><a href="#11-封装、继承、多态" class="headerlink" title="11. 封装、继承、多态"></a>11. 封装、继承、多态</h2><h3 id="11-1-封装"><a href="#11-1-封装" class="headerlink" title="11.1 封装"></a>11.1 封装</h3><ul>
<li><p><strong>好处</strong></p>
<ol>
<li><p><strong>隐藏实现细节</strong></p>
</li>
<li><p><strong>可以对数据进行验证，保证安全合理</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">p.age = <span class="number">1200</span>;		<span class="comment">//人不可能活这么长，这种不封装的不能保证合理</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>封装的实现步骤</p>
<ol>
<li><strong>属性私有化</strong></li>
<li><strong>公共的set方法</strong>，可以设置属性，同时验证保证数据安全合理</li>
<li><strong>公共的get方法</strong>，可以得到属性，同时检验权限是否可被得到</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary; 	<span class="comment">//对每个属性设置公开的get和set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>在对属性设置get和set方法的时候使用快捷键alt+insert一键生成</strong>，生成后根据要求完善</p>
</li>
<li><p>在使用set对属性进行保护后，如果需要<strong>使用构造器，应该将set方法放在构造器里面</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        set();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="11-2-继承"><a href="#11-2-继承" class="headerlink" title="11.2 继承"></a>11.2 继承</h3><h4 id="11-2-1-继承概念"><a href="#11-2-1-继承概念" class="headerlink" title="11.2.1 继承概念"></a>11.2.1 继承概念</h4><ul>
<li><p>通过 <strong>extends</strong> 关键字来声明继承父类</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224102202345.png" alt="image-20211224102202345"></p>
</li>
<li><p>子类<strong>继承了所有的属性和方法（私有的也继承了，只是不能直接访问），非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问</strong>。</p>
</li>
<li><p> <strong>子类在创建的时候必须调用父类的构造器， 完成父类的初始化</strong>。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dad被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*super();  此句默认有，被隐藏了，写不写都一样。括号里空代表匹配父类的没有参数的那个构造器，如果父类有多个构造器也可加上参数指定匹配，写上后默认的被覆盖，默认匹配无参的*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;son被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son son = <span class="keyword">new</span> Son(); <span class="comment">/*在执行这句的时候会输出&quot;Dad被调用&quot;和&quot;son被调用&quot;（有先后顺序，先调用父类的），因为这里默认调用了父类的无参构造器，隐藏了super()语句*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Son son = <span class="keyword">new</span> Son(); <span class="comment">/*这里也会输出&quot;Dad被调用&quot;，因为Son有默认无参构造器，它调用的时候也会调用父类无参构造器*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当创建子类对象时，<strong>不管使用子类的哪个构造器</strong>，<strong>默认情况下</strong>总会去调用<strong>父类的无参构造器</strong>，如果<strong>父类没有提供无参构造器</strong>，则<strong>必须在子类的构造器中用 super 去指定</strong>使用<strong>父类的哪个构造器</strong>完成对<strong>父类的初始化</strong>工作，否则，编译不会通过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dad被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son有参构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son son = <span class="keyword">new</span> Son(<span class="string">&quot;aboluo&quot;</span>); <span class="comment">/*输出&quot;Dad被调用&quot;和&quot;son有参构造器被调用&quot;（有先后顺序）*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dad</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dad有参构造器被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;must use&quot;</span>);	<span class="comment">/*父类没有无参构造器，这里必须使用super()指定使用父类的哪个构造器，否则编译无法通过。因此如果父类没有无参构造器，子类就必须使用有参/无惨构造器，因为不使用就是默认无参构造器，而默认无参构造器里面不包括super()语句，无法通过编译。*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;son被调用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>因此如果父类没有无参构造器，子类就必须使用有参/无惨构造器，因为不使用就是默认无参构造器，而默认无参构造器里面不包括super()语句，无法通过编译</strong>。<ul>
<li>此时子类如果有<strong>多个构造器</strong>，那么<strong>每一个都要使用super()指定</strong>。</li>
<li>super()指定父类构造器的方法就是直接super(参数列表)，这个参数列表去匹配父类构造器</li>
</ul>
</li>
</ul>
</li>
<li><p>**super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)**。</p>
</li>
<li><p><strong>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</strong>。</p>
<ul>
<li><strong><u>注意</u><strong>：是不能显式的使用super()还要使用this()，如果不显式的使用super()，则可以使用this()，此时</strong>默认的super()会被忽略</strong>，因为可以使用this指代的构造器里面的super()来初始化父类。<ul>
<li>**如果使用了this()**那么就会先执行this()指代的其它构造器，然后在那个构造器中如果还有就继续找下去，如果没有就会从被指代的构造器处开始执行super()语句，然后执行完该被指代的构造器，然后在返回最初的构造器执行this()之后的语句</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Object是所有类的基类</strong>。</p>
</li>
<li><p>**父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)**。</p>
<ul>
<li><strong>即在子类构造器中spuer()会从最顶级的父类开始往下依次初始化所有父类</strong>。</li>
</ul>
</li>
<li><p>**子类最多只能继承一个父类(指直接继承)**，即 java 中是单继承机制。<br>思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】</p>
</li>
<li><p><strong>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</strong>。</p>
<ul>
<li>Cat is a Animal 可以，Music is a Person 不行</li>
</ul>
</li>
</ul>
<h4 id="11-2-2-继承的本质"><a href="#11-2-2-继承的本质" class="headerlink" title="11.2.2 继承的本质"></a>11.2.2 继承的本质</h4><ul>
<li><p>new子类的<strong>内存布局</strong></p>
<ol>
<li>首先加载类信息，从顶级父类开始加载</li>
<li>然后在内存中开辟空间，这片空间里依次存放每个父类的属性直到自己</li>
<li>返回内存地址</li>
</ol>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224132531769.png" alt="image-20211224132531769"></p>
</li>
<li><p>在<strong>访问属性</strong>的时候</p>
<ol>
<li><strong>首先看子类是否有该属性</strong></li>
<li>如果<strong>子类有</strong>这个属性，并且<strong>可以访问</strong>，则返回信息</li>
<li> 如果<strong>子类没有这个属性，就看父类有没有这个属性</strong>(如果父类有该属性，并且<strong>可以访问</strong>，就返回信息..)</li>
<li> 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object…</li>
</ol>
<ul>
<li><strong>注意：如果某一个父类有此属性，但是该属性是私有的，即使更上层的父类有公有的同名属性，仍会报错，因为已经在这个父类查找到了，只是不能访问</strong>。</li>
</ul>
</li>
</ul>
<h4 id="11-2-3-super关键字"><a href="#11-2-3-super关键字" class="headerlink" title="11.2.3 super关键字"></a>11.2.3 super关键字</h4><ul>
<li><p>super 代表<strong>父类的引用</strong>，用于 <strong>访问父类的属性、方法、构造器</strong>。</p>
<ul>
<li>super访问构造器只能在构造器中使用</li>
</ul>
</li>
<li><p><strong>在子类中调用方法</strong></p>
<ol>
<li><p><strong>和父类不重名</strong></p>
<ul>
<li><p>(1)先找本类，如果有，则调用</p>
</li>
<li><p>(2)如果没有，则找父类(如果有，<strong>并可以调用</strong>，则调用)</p>
</li>
<li><p> (3)如果父类没有，则继续找父类的父类，直到 Object 类</p>
</li>
<li><p>提示：如果查找方法的过程中，<strong>找到了，但是不能访问， 则报错</strong>, cannot access<br> 如果查找方法的过程中，<strong>没有找到，则提示方法不存在</strong></p>
</li>
<li><p><strong><code>super.方法</code>直接从父类开始找，跳过找本类</strong>，之后一样</p>
</li>
<li><p><strong><code>this.方法</code><strong>等价于直接</strong><code>方法</code></strong></p>
</li>
<li><p><strong>方法从</strong>最开始方法区中加载的<strong>类信息里面依次找</strong></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224144607999.png" alt="image-20211224144607999"></p>
</li>
<li><p><strong>属性查找规则和方法一样</strong>，但是<strong>属性从堆中依次找</strong></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224145317808.png" alt="image-20211224145317808"></p>
</li>
</ul>
</li>
<li><p><strong>和父类有重名</strong>方法或者属性</p>
<ul>
<li><p>此时需要使用<code>spuer.方法</code>来指定从父类开始找</p>
<ul>
<li>如果要找同名但是更高层的父类，可以使用特定方法返回</li>
</ul>
</li>
<li><p>此时找到<strong>第一个就停止，即使找到了不能访问也不再继续</strong>。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="11-2-4-方法重写-覆盖-override"><a href="#11-2-4-方法重写-覆盖-override" class="headerlink" title="11.2.4 方法重写/覆盖(override)"></a>11.2.4 方法重写/覆盖(override)</h4><ul>
<li><p>如果子类中有一个方法 <strong>方法名、返回类型、形参列表</strong> 和父类都完全相同，这个<strong>子类的方法就覆盖了父类的方法</strong>。</p>
<ul>
<li><p>其中如果<strong>返回类型不完全相同，但是子类的返回类型是父类的子类</strong>，也构成覆盖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getinfo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getinfo</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">//String是Object的子类，构成覆盖</span></span><br><span class="line"></span><br><span class="line">==============================</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//父类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> A <span class="title">getinfo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">getinfo</span><span class="params">()</span></span>&#123;&#125;	<span class="comment">//也构成覆盖，B是A的子类</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**如果返回类型不是父类的子类，则会<u>报错</u>**。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果**子类访问权限小于父类，则会<u>报错</u>**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>&#123;&#125;		<span class="comment">//错误，public &gt; protected &gt; 默认 &gt; private</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>&#123;&#125;			<span class="comment">//正确，构成覆盖</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>public &gt; protected &gt; 默认 &gt; private</strong></li>
</ul>
</li>
</ul>
<h4 id="11-2-5-重写和重载的区别"><a href="#11-2-5-重写和重载的区别" class="headerlink" title="11.2.5 重写和重载的区别"></a>11.2.5 重写和重载的区别</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224152941442.png" alt="image-20211224152941442"></li>
</ul>
<h3 id="11-3-多态"><a href="#11-3-多态" class="headerlink" title="11.3 多态"></a>11.3 多态</h3><ul>
<li>多态是指方法或者对象具有多种形态，堕胎是建立在封装和继承基础之上的</li>
</ul>
<h4 id="11-3-1-方法的多态"><a href="#11-3-1-方法的多态" class="headerlink" title="11.3.1 方法的多态"></a>11.3.1 方法的多态</h4><ul>
<li><strong>重写和重载就体现多态</strong></li>
</ul>
<h4 id="11-3-2-对象的多态"><a href="#11-3-2-对象的多态" class="headerlink" title="11.3.2 对象的多态"></a>11.3.2 对象的多态</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224155620210.png" alt="image-20211224155620210"></li>
</ul>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224155630592.png" alt="image-20211224155630592"></p>
<ul>
<li><strong>多态的前提：两个对象（类）存在继承关系</strong></li>
</ul>
<h5 id="11-3-2-1-向上转型"><a href="#11-3-2-1-向上转型" class="headerlink" title="11.3.2.1 向上转型"></a>11.3.2.1 向上转型</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224162909475.png" alt="image-20211224162909475"></p>
</li>
<li><p>向上转型的本质：<strong>父类的引用指向子类的对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Dog();</span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//都是向上转型</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编译的时候<strong>可以调用父类中的所有成员，不能调用子类的特有成员</strong>，这是由编译器决定的（<code>javac</code>），<strong>编译阶段能调用哪些成员是由它的编译类型决定的</strong>。编译的时候它的编译类型是Animal，所以它就不能调用子类的特有成员。</li>
<li><strong>运行的时候看运行类型</strong>，因为运行的时候是由<code>java</code>这个来运行的，它看你的运行类型，<strong>从运行类型开始找这个方法，找不到就往上找，规则和之前一致</strong>。</li>
</ul>
</li>
</ul>
<h5 id="11-3-2-2-向下转型"><a href="#11-3-2-2-向下转型" class="headerlink" title="11.3.2.2 向下转型"></a>11.3.2.2 向下转型</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211224162839850.png" alt="image-20211224162839850"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.say();	<span class="comment">//可以，此时编译类型是A，运行类型是B，完成向上转型，编译的时候只能调用sayA(),不能调用sayB()</span></span><br><span class="line">B b = (B) a;	<span class="comment">//a的编译类型是A，强转成B让B接收</span></span><br><span class="line">b.sayB();		<span class="comment">//可以</span></span><br><span class="line">b.syaA();		<span class="comment">//此时b可以同时使用A B的方法，因为B继承了A，可以通过编译</span></span><br><span class="line">A a0 = (C) b;	<span class="comment">//错误，b现在是B类，B和C都是A的子类，但是B和C没关系，即使A类型可以指向C的对象完成向上引用，但是(C)b这个强转无法完成</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> B(); <span class="comment">//编译正确，Object是所有类的父类，可以完成向上转型，但是由于只能调用父类的成员，而Object没有这几个方法，因此obj一个都调用不了</span></span><br><span class="line">A a1 = (B) obj;	<span class="comment">//编译正确，A是B的父类，可以向上转型，同样只能调用sayA()</span></span><br><span class="line">B b0 = (B) a1;	<span class="comment">//编译正确，a1指向的就是B类型，此时可以使用sayA()和sayB()</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>特别注意，属性没有重写一说，访问属性的时候直接看它的编译类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">System.out.print(a.a);<span class="comment">//此时输出4，属性只看编译类型，它的编译类型是A</span></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">System.out.print(a.a);<span class="comment">//此时输出5，它的编译类型是B</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="11-3-2-3-instanceof-比较操作符"><a href="#11-3-2-3-instanceof-比较操作符" class="headerlink" title="11.3.2.3 instanceof 比较操作符"></a>11.3.2.3 instanceof 比较操作符</h5><ul>
<li>判断对象的<strong>运行类型</strong>是否为XX类型或XX类型的<strong>子类型</strong>，返回一个布尔值<ul>
<li>也就是真正比较的时候还是<strong>比较这个引用指向的地址处的对象</strong>，<strong>而不是这引用本身</strong>。</li>
<li><code>a instanceof b</code>这样用</li>
</ul>
</li>
</ul>
<h4 id="11-3-3-java的动态绑定机制（重要）"><a href="#11-3-3-java的动态绑定机制（重要）" class="headerlink" title="11.3.3 java的动态绑定机制（重要）"></a>11.3.3 java的动态绑定机制（重要）</h4><ul>
<li><p><strong>在调用一个对象的方法的时候，该方法会和该对象的内存地址(即运行类型)绑定</strong>。</p>
</li>
<li><p><strong>在调用对象的属性的时候，没有动态绑定机制，哪里声明，哪里使用</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicBinding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> B();<span class="comment">//向上转型</span></span><br><span class="line">        System.out.println(a.sum());		<span class="comment">/*输出40，如果注销子类的sum()方法，则会调用</span></span><br><span class="line"><span class="comment">        父类的sum()，父类的sum()里面调用了方法getI(),调用方法会动态绑定到运行类型，</span></span><br><span class="line"><span class="comment">        因此调动的是子类的getI(),结果是20+10=30；*/</span></span><br><span class="line">        System.out.println(a.sum1());		<span class="comment">/*输出30，如果注销子类的sum1()方法，则会调用父类</span></span><br><span class="line"><span class="comment">        的sum1()方法，父类的sum1()方法中（return i + 10）这个i是属性，不会动态绑定到运行类型，因</span></span><br><span class="line"><span class="comment">        此输出结果是10+10=20*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;<span class="comment">//父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;<span class="comment">//子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> i + <span class="number">20</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从这里也可看出，如果在<strong>编译的时候使用的是父类的引用指向子类对象，想要调用子类特有的方法</strong>的话可以<strong>在父类也添加一个同名的方法</strong>，这样就编译正确</li>
</ul>
</li>
</ul>
<h4 id="11-3-4-多态数组"><a href="#11-3-4-多态数组" class="headerlink" title="11.3.4 多态数组"></a>11.3.4 多态数组</h4><ul>
<li><p><strong>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</strong>。</p>
<blockquote>
<p><strong>应用实例</strong>:现有一个继承结构如下：要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组中，并调用每个对象say 方法.<br>应用实例升级：如何调用子类特有的方法，比如<br>Teacher 有一个 teach , Student 有一个 study<br>怎么调用？</p>
<p>答：在遍历数组的时候<strong>增加一个<code>if(  isstanceof )</code>判断类型</strong>，如果是Student或者Teacher就使用<strong>强制转换</strong>，使它的编译类型变成运行类型，即<strong>向下转型</strong>，这样就可以访问子类特有方法。</p>
<p>**强转和调用强转后子类的方法可以一步完成   <code>(强转).方法名()</code>**。在idea中直接用<code>对象名.方法名</code>后会有提示直接生成这个强转调用。</p>
</blockquote>
</li>
<li><p><strong>多态参数</strong></p>
<ul>
<li>即用父类形参接收子类实参</li>
</ul>
</li>
</ul>
<h2 id="12-Object类"><a href="#12-Object类" class="headerlink" title="12 Object类"></a>12 Object类</h2><ul>
<li>Object类在<code>java.lang</code>包里，lang包自动导入，可以直接用</li>
</ul>
<h3 id="12-1-equals方法-和-运算符"><a href="#12-1-equals方法-和-运算符" class="headerlink" title="12.1 equals方法 和 == 运算符"></a>12.1 equals方法 和 == 运算符</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211225164912044.png" alt="image-20211225164912044"></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211225164957297.png" alt="image-20211225164957297"></p>
</li>
<li><p>```java<br>public boolean equals(Object obj) {</p>
<pre><code>    return (this == obj);
&#125;
</code></pre>
<p>//这是Object里面的equals方法，其他类继承后一般都会改写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  int a = 5;</span><br><span class="line">  double b = 5.0;</span><br><span class="line">  a == b;//为真，基本数据类型看值</span><br><span class="line">  </span><br><span class="line">  int m = 65;</span><br><span class="line">  char ch = &#x27;A&#x27;;</span><br><span class="line">  m == ch;//true，字符的本质是数字</span><br><span class="line">  </span><br><span class="line">  &quot;hello&quot; == new java.sql.Date();//编译报错，字符串类型和右边没关系，无法比较</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-2-hashCode方法"><a href="#12-2-hashCode方法" class="headerlink" title="12.2 hashCode方法"></a>12.2 hashCode方法</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211225200549401.png" alt="image-20211225200549401"></li>
</ul>
<ol>
<li><strong>提高具有哈希结构的容器的效率！</strong></li>
<li>两个引用，如果指向的是同一个对象，则哈希值<strong>肯定</strong>是一样的！</li>
<li>两个引用，如果指向的是不同对象，则哈希值是不一样的（不是肯定不一样，但是几乎不会错）</li>
<li>哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。</li>
</ol>
<h3 id="12-3-toString-方法"><a href="#12-3-toString-方法" class="headerlink" title="12.3  toString 方法"></a>12.3  toString 方法</h3><ul>
<li><p><strong>全类名+@+哈希值的十六进制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>子类往往重写 toString 方法，用于返回对象的属性信息</strong>，用快捷键alt+insert一键生成</li>
</ul>
</li>
<li><p><strong>当直接输出一个对象时，toString 方法会被默认的调用</strong>, 比如 <code>System.out.println(monster)</code></p>
<p>就会默认调用<code>monster.toString()</code>。</p>
</li>
</ul>
<h3 id="12-4-finalize方法"><a href="#12-4-finalize方法" class="headerlink" title="12.4 finalize方法"></a>12.4 finalize方法</h3><ol>
<li><p><strong>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</strong></p>
</li>
<li><p><strong>什么时候被回收</strong>：当某个<strong>对象没有任何引用时</strong>，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在<strong>销毁该对象前，会先调用 finalize 方法</strong>。</p>
</li>
</ol>
<ul>
<li><strong>可以自己重写该方法</strong></li>
<li><strong>此时如果没有重写该方法，就会调用Object类的finalize，即默认处理</strong></li>
<li><strong>不是说有对象变成垃圾，就立马回收，它有一个自己的算法GC</strong></li>
</ul>
<ol start="3">
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 <strong>System.gc() 主动触发</strong>垃圾回收机制</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;垃圾回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========================================================</span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car = <span class="keyword">null</span>;	<span class="comment">//此时new出来的Car对象没人引用，被当成垃圾回收</span></span><br><span class="line">System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line"><span class="comment">/*此时执行只会输出&quot;程序结束&quot;，finalize还没被执行，因为他有自己的算法，不是对象变成垃圾就立马回收*/</span></span><br><span class="line">=========================================================</span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car = <span class="keyword">null</span>;	</span><br><span class="line">System.gc(); 		<span class="comment">/*这样主动运行垃圾回收器，运行过后会先输出&quot;程序结束&quot;然后再输出&quot;垃圾回收&quot;，但也不一定马上就回收，是大概率*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="13-断点调试"><a href="#13-断点调试" class="headerlink" title="13. 断点调试"></a>13. 断点调试</h2><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227102313115.png" alt="image-20211227102313115"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227102330994.png" alt="image-20211227102330994"></p>
</li>
</ul>
<h3 id="13-1-断点调试的快捷键"><a href="#13-1-断点调试的快捷键" class="headerlink" title="13.1 断点调试的快捷键"></a>13.1 断点调试的快捷键</h3><blockquote>
<p>F7(跳入)   F8(跳过)   shift+F8(跳出)   F9(resume,执行到下一个断点)<br>F7：跳入方法内<br>F8: 逐行执行代码.<br>shift+F8: 跳出方法</p>
</blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227105623856.png" alt="image-20211227105623856"></p>
<ul>
<li><p><strong>F7进入方法源码，shift+F8跳出，一层一层</strong></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211227105828235.png" alt="image-20211227105828235"></p>
</li>
<li><p><strong>F9 resum</strong>直接运行到下一个断点的地方</p>
<ul>
<li>可以动态下断点，<strong>可以在自己的代码上也可以在jdk源码上动态下</strong>，然后F9执行到那处</li>
<li>如果<strong>断点在循环里，F9一次如果循环没结束那么下一次断点还会在本身</strong>。</li>
<li>如果用F7进入了方法的JDK源码里面下了断点，同时main里面这个方法下面也有断点，如果源码里面没有下一个断点那么下一个断点就是main里的这个，F9后可以<strong>从里面执行回到main</strong>。<ul>
<li><strong>到底能不能进入断点还得看正常运行能不能运行到那一步（业务逻辑），例如if条件判断为真，断点设在假的分支里，就不会进入这个断点</strong>，此时如果这个断点是物理上的下一个断点，运行F9会<strong>跳过这断点</strong>直接执行它的下一个。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="14-类变量和类方法"><a href="#14-类变量和类方法" class="headerlink" title="14.  类变量和类方法"></a>14.  类变量和类方法</h2><h3 id="14-1-类变量"><a href="#14-1-类变量" class="headerlink" title="14.1 类变量"></a>14.1 类变量</h3><ul>
<li><p>用<code>static</code>修饰的变量叫<strong>类变量/静态变量</strong></p>
<ul>
<li>所有对象共享这个变量，即<strong>每个对象</strong>都可以访问它，它的变化也会被所有对象感知</li>
<li>可以用对象名.变量名来访问，每个对象访问到的相同，也可以<strong>直接用类名</strong>而不用对象名<strong>来访问</strong>，<code>Person.count</code>这样（推荐）<ul>
<li><strong><code>访问修饰符 static 数据类型 变量名</code>（推荐）</strong></li>
<li><strong><code>static 访问修饰符 数据类型 变量名</code></strong></li>
</ul>
</li>
<li><strong>在方法区加载类信息的时候就会在堆中加载一个class实例，这个class里就包含有静态变量</strong>。因此静态变量是在类加载的时候就初始化了，不用创建对象就能直接用类名访问。</li>
<li><strong>内部类不能有静态声明</strong>。</li>
</ul>
</li>
<li><p><strong>静态变量存放位置</strong></p>
<ul>
<li><p>jdk8以前静态变量存放在<strong>方法区</strong>中的静态域中</p>
</li>
<li><p>jdk8开始会放在每个<strong>类</strong>(不是对象)在<strong>堆</strong>中的class实例的尾部，每个类都有</p>
<ul>
<li><p><strong>即使没有new一个对象，也可以直接用类名.变量名访问</strong>。因为它是随着类的加载而创建的，并不依赖于对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.a;</span><br><span class="line">A k = <span class="keyword">new</span> A();</span><br><span class="line">k.a;	<span class="comment">//两种访问方法都可以</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229121724738.png" alt="image-20211229121724738"></p>
</li>
<li><p><strong>访问的时候同样要遵守访问权限</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="14-2-类方法"><a href="#14-2-类方法" class="headerlink" title="14.2 类方法"></a>14.2 类方法</h3><ul>
<li><p>形式和类变量一致</p>
</li>
<li><p>不用创建对象就可以通过类名调用</p>
</li>
<li><p>访问时需要遵守访问权限</p>
</li>
<li><p>同样是<strong>随着类的加载而加载</strong>。</p>
</li>
<li><p><strong>类方法中没有this参数，普通方法中隐含着this参数</strong>，类方法可以直接用<code>类名.</code>代替<code>this.</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        Stu.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/* public static void setA(int a) &#123;	</span></span><br><span class="line"><span class="comment">        this.a = a;  错误，类方法中没有this</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>类方法中不能使用super关键字（super和this都是和对象实例相关的，都不能使用）</strong>。</p>
<ul>
<li>也可以这样想：<strong>super和this使用势必可以访问普通方法</strong>，而<strong>普通方法必须创建对象后才能调用</strong>，<strong>static</strong>方法如果使用 <strong>类名调用</strong> 那么此时<strong>并未创建对象</strong>，如果在此static方法中贸然调用普通方法定然出错。</li>
</ul>
</li>
<li><p><strong>静态方法直接访问本类成员的时候只能访问静态变量和静态方法</strong>。<strong>想要访问非静态的必须先new一个对象实例，通过对象访问</strong>。很好理解，静态的比非静态的更早初始化而且可以通过类名访问，如果通过类名访问的时候存在非静态的成员，但此时非静态成员还未初始化，它们要new对象的时候才开始初始化，这不被允许。</p>
</li>
<li><p><strong>非静态方法可以访问非静态成员，同时也可以访问静态成员</strong>。</p>
</li>
<li><p><strong>静态方法没有动态绑定机制，</strong>即如果在父类的普通方法里调用父类和子类共有的静态方法，在调动父类该普通方法时执行到调用静态方法这步，会调用父类中的静态方法。</p>
</li>
<li><p><strong>静态方法无法和非静态方法互相重写</strong>，不论是将<strong>父类中的非静态方法在子类中加上static声明还是将父类中的静态方法去掉static</strong>，都将报错；</p>
<ul>
<li><p>但不过父类中的静态方法在子类中使用static修饰该方法便不会报错，但按照重写的规定声明后，<strong>实质上并没有构成重写</strong>，只不过是两个看起来是重写了的两个静态方法，调用时按照<strong>编译类型</strong>来调用重名的静态方法，这点和<strong>普通方法按照运行类型</strong>调用不同，需特别注意。（<strong>我的理解</strong>是：静态方法和静态变量一样存在于类而不是实例对象中，即子类继承父类并且<strong>创建对象后，子类普通方法和父类普通方法都位于这个对象实例中</strong>，因此有重写一说，而<strong>静态方法并不在对象实例中，没有重写一说，且重名也不会报错，因为这是两个空间</strong>，因此调用静态方法的时候就得<strong>找静态方法所处位置</strong>，它在用来声明对象的类里面，因此<strong>使用静态方法的时候看是谁声明的这个对象实例变量</strong>，即从<strong>编译类型开始找，而不是从运行类型开始找</strong>，只是开始找的地方和普通方法不一样，如果<strong>没找到则会和普通方法一样一层一层往上找</strong>。即如果编译类型上面还有父类，此时如果编列类型的类里面也没有此静态方法，此时就会找编译类型的父类里有没有该静态方法，如果有多个父类都有该静态方法，则调用最近的父类的）例如：（**<u>上面括号里的我的理解很重要</u>**）</p>
<ul>
<li><strong>讲这么多，要知道的是属性没有重写一说，非静态属性是哪里声明哪里调用，如果本类有此非静态属性就直接调用，如果没有就往上找</strong>。<strong>静态属性和非静态属性搜索方法一致，从编译类型开始搜索，一直往上，不同的是静态属性和静态方法一样存在于类而不是存在于对象实例，同时也不要忘了，类只加载一次</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;	<span class="comment">//静态方法say</span></span><br><span class="line">        System.out.print(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say3</span><span class="params">()</span></span>&#123;			<span class="comment">//普通方法say3()</span></span><br><span class="line">        say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;	<span class="comment">//静态方法say()</span></span><br><span class="line">        System.out.print(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span></span>&#123;			<span class="comment">//普通方法say1()</span></span><br><span class="line">        System.out.print(<span class="string">&quot;00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say2</span><span class="params">()</span></span>&#123;			<span class="comment">//静态方法say2()</span></span><br><span class="line">        System.out.print(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a = <span class="keyword">new</span> B();</span><br><span class="line">a.say();	<span class="comment">//这里输出 &quot;aa&quot;，静态方法没有重载，调用的时候按编译类型查找，即静态方法调用的时候没有动态绑定机制</span></span><br><span class="line">a.say1();	<span class="comment">//报错，编译类型是A，不能调用子类特有方法</span></span><br><span class="line">a.say2();	<span class="comment">//报错，编译类型是A，无论子类特有方法是否静态，都无法调用</span></span><br><span class="line">a.say3();	<span class="comment">//输出 &quot;aa&quot;，同样可以看出调用静态方法的时候无动态绑定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">b.say();	<span class="comment">//这里则输出 &quot;bb&quot;</span></span><br><span class="line">b.say1();	<span class="comment">//输出 &quot;00&quot;</span></span><br><span class="line">b.say3();	<span class="comment">//输出 &quot;aa&quot;，即使b的运行类型是B，还是调用的A的say()方法，由此可见静态方法和属性一样就近调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kk</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aaa</span> <span class="keyword">extends</span> <span class="title">Kk</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say3</span><span class="params">()</span></span>&#123;			<span class="comment">//普通方法say3()</span></span><br><span class="line">        say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Aaa</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;	<span class="comment">//静态方法say()</span></span><br><span class="line">        System.out.print(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Aaa a = <span class="keyword">new</span> B();</span><br><span class="line">a.say(); 	<span class="comment">//此时会输出 &quot;KK&quot;，再次证明静态方法是从编译类型开始网上搜索</span></span><br><span class="line">a.say3();	<span class="comment">//输出 &quot;KK&quot;,可以在子类普通方法中直接调用父类静态方法，同样可看出静态方法没有动态绑定</span></span><br></pre></td></tr></table></figure>



<ul>
<li>由上可知，<strong>静态方法是在随着类而不是随着对象实例(new)的，并不存在与对象实例中</strong>。否则应该按照运行类型执行。</li>
</ul>
</li>
<li><p><strong>虽然静态方法中更无法使用super调用父类方法，但在子类中的非静态方法中却可以通过super调用父类的静态方法（非静态也行）</strong>。</p>
</li>
<li><p>上面已经讲的比较透彻，理解后都好想通。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aa</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        say11();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bb</span> <span class="keyword">extends</span> <span class="title">Aa</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say11</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.say11();</span><br><span class="line">        <span class="keyword">this</span>.say11();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> bb().say();  	<span class="comment">//这里会依次输出 &quot;1&quot; &quot;4&quot; &quot;2&quot;，即普通方法可以super调用父类的静态方法，静态方法中不能使用super和this。也就是普通方法能使用的时候静态方法必定随着类加载已经可以调用了，而静态方法不new则普通方法无法使用，因此这般。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="14-3-何时适合用静态"><a href="#14-3-何时适合用静态" class="headerlink" title="14.3 何时适合用静态"></a>14.3 何时适合用静态</h3><ul>
<li>想要将不创建实力即可调用方法，即<strong>将方法当工具用</strong>时很适合</li>
</ul>
<h2 id="15-main方法"><a href="#15-main方法" class="headerlink" title="15.  main方法"></a>15.  main方法</h2><h3 id="15-1-谁调用main方法"><a href="#15-1-谁调用main方法" class="headerlink" title="15.1 谁调用main方法"></a>15.1 谁调用main方法</h3><ul>
<li><p>main方法时<strong>java虚拟机来调用</strong>的</p>
</li>
<li><p>java虚拟机和main方法不在同一个包，<strong>必须用public修饰main</strong>才能运行</p>
</li>
<li><p>java虚拟机在执行main()方法的时候不必创建对象，所以<strong>main()方法必须是static</strong>。</p>
</li>
<li><p><code>public static void main(String[] args)</code>定义时的参数是字符串数组，这些参数是在执行java命令的时候在后面写上的参数，这些参数会被当成字符串数组传入</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229144219171.png" alt="image-20211229144219171"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            System.out.print(args[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java Test				<span class="comment">//这样执行不会有任何输出</span></span><br><span class="line">java Test ab abc abcd 	<span class="comment">//这样执行会输出ab abc abcd</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229145539319.png" alt="image-20211229145539319"></p>
<ul>
<li><p><strong>在命令行这样操作就可以传入</strong>。</p>
</li>
<li><p><strong>在idea中这样传入</strong>。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150013202.png" alt="image-20211229150013202"></p>
</li>
</ul>
</li>
</ul>
<h3 id="15-2-main注意事项"><a href="#15-2-main注意事项" class="headerlink" title="15.2 main注意事项"></a>15.2 main注意事项</h3><ul>
<li><p><strong>main方式是静态方法，只能访问本类中的静态成员，如果要访问非静态成员，需要先创建对象</strong>，通过对象来引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = a;			<span class="comment">//a是静态的可以直接访问</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="keyword">new</span> Test().b;	<span class="comment">//b是非静态成员，要创建对象才能访问b</span></span><br><span class="line">        <span class="comment">//a,b都是私有的，此处是在本类，可以使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="16-代码块"><a href="#16-代码块" class="headerlink" title="16.  代码块"></a>16.  代码块</h2><h3 id="16-1-入门"><a href="#16-1-入门" class="headerlink" title="16.1 入门"></a>16.1 入门</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150753465.png" alt="image-20211229150753465"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150806901.png" alt="image-20211229150806901"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229150824407.png" alt="image-20211229150824407"></p>
<ul>
<li><p><strong>不管调用哪个构造器，创建对象，都会先调用代码块的内容</strong>。</p>
</li>
<li><p><strong>代码块调用的顺序优先于构造器</strong>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="16-2-代码块细节"><a href="#16-2-代码块细节" class="headerlink" title="16.2 代码块细节"></a>16.2 代码块细节</h3><ul>
<li><p><strong>static代码块</strong>称为静态代码块，它随着<strong>类的加载</strong>而执行（不用创建对象），并且<strong>只会执行一次</strong>。<strong>普通代码块</strong>每创建一个对象就会执行一次。</p>
<ul>
<li><p>类在什么时候加载<strong>（重要！！！！！）</strong></p>
<ul>
<li><p><strong>在创建对象实例(new)的时候</strong></p>
</li>
<li><p><strong>创建子类对象实例，父类也会被加载</strong></p>
<blockquote>
<p><strong>创建对象的时候第一步是加载类信息</strong>，加载子类的时候会<strong>优先加载父类的信息，从顶级父类依次加载</strong>。（注意：是先从顶级父类依次加载完类信息后再依次从顶级父类开始调用构造器）</p>
</blockquote>
</li>
<li><p><strong>使用类的静态成员时（静态属性，静态方法）</strong></p>
<blockquote>
<p>这里普通代码块不会执行，因为直接使用<code>类名.静态变量</code>的时候类会被加载(<strong>如果这是个子类则会优先加载完父类（从顶级父类开始往下加载），父类中如果有static代码块此时就会先于子类执行</strong>)，<strong>此时</strong>类加载，因此<strong>静态代码块执行</strong>，而<strong>普通代码块不会执行</strong>（可以理解为普通代码块随着构造器的调用而执行，执行用类名访问静态成员并不会调用构造器）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>由于类只会被加载一次，所以<code>static</code>代码块只会执行一次</strong>。</p>
</li>
<li><p><strong>如果一个类中既有普通代码块又有静态代码块，创建对象实例的时候会优先执行静态代码块，然后是普通代码块</strong>。</p>
<blockquote>
<p><strong>可以理解为普通代码块在调用构造器的时候执行，而静态代码块在类加载的时候执行</strong>，创建对象的时候<strong>首先加载类</strong>信息，所以最先执行静态代码块再执行普通代码块。</p>
</blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229160140935.png" alt="image-20211229160140935"></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229160158820.png" alt="image-20211229160158820"></p>
<ul>
<li><p>这里隐藏的<strong>第二步不止调用普通代码块，还有非静态属性初始化</strong>，普通代码块和普通属性初始化先后顺序看定义顺序，他们优先级一样。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229161523669.png" alt="image-20211229161523669"></p>
<ul>
<li>**<u>可以理解为创建一个子类的时候先加载全部的类信息，而类信息又是由顶级父类开始加载，所以会先执行父类的静态属性初始化和静态代码块，然后是加载子类信息，所以又执行子类的静态属性初始化和静态代码块，然后走到构造器里面super()上去到顶级父类开始父类的普通代码块和普通属性初始化，最后回到子类执行子类的普通代码块和普通属性初始化，最后是构造方法</u>**。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="17-单例模式"><a href="#17-单例模式" class="headerlink" title="17 . 单例模式"></a>17 . 单例模式</h2><h3 id="17-1-什么是设计模式"><a href="#17-1-什么是设计模式" class="headerlink" title="17.1 什么是设计模式"></a>17.1 什么是设计模式</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229164019649.png" alt="image-20211229164019649" style="zoom:67%;" /></li>
</ul>
<h3 id="17-2-什么是单例模式"><a href="#17-2-什么是单例模式" class="headerlink" title="17.2  什么是单例模式"></a>17.2  什么是单例模式</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229164045931.png" alt="image-20211229164045931"></li>
</ul>
<h4 id="17-2-1-饿汉式单例模式"><a href="#17-2-1-饿汉式单例模式" class="headerlink" title="17.2.1 饿汉式单例模式"></a>17.2.1 饿汉式单例模式</h4><ul>
<li>因为可能在使用该类别的静态成员的时候还不需要用到该对象，但是由于该对象是静态创建的，那么此时就已经创建了该对象，还不需要用就创建了，饿汉式。<ul>
<li><strong>创建步骤</strong>（三步）<ol>
<li> <strong>将构造器私有化（防止new一个对象）</strong></li>
<li><strong>在类的内部直接创建对象(该对象是 static)</strong></li>
<li><strong>提供一个公共的 static 方法（这样可以不用创建对象就调用该方法），返回 gf 对象</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//为了能够在静态方法中，返回 gf 对象，需要将其修饰为 static</span></span><br><span class="line">    <span class="comment">//對象，通常是重量級的對象, 餓漢式可能造成創建了對象，但是沒有使用.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GirlFriend gf = <span class="keyword">new</span> GirlFriend(<span class="string">&quot;小红红&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GirlFriend</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;構造器被調用.&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建了但可能没有用，造成资源浪费</strong>。</li>
</ul>
<h4 id="17-2-2-懒汉式单例模式"><a href="#17-2-2-懒汉式单例模式" class="headerlink" title="17.2.2 懒汉式单例模式"></a>17.2.2 懒汉式单例模式</h4><ul>
<li><p>步骤</p>
<ol>
<li><strong>构造器私有化</strong></li>
<li><strong>定义一個 static 静态属性对象</strong>（不创建对象，只是定义此对象类型的变量）</li>
<li><strong>提供一個 public 的 static 方法，可以返回一個 Cat 对象</strong>（返回给上一步声明的变量）</li>
<li><strong>懒汉式，只有当用戶使用 getInstance 时，才返回 cat 对象, 后面再次调用时，会返回上次创建的 cat 对象</strong><ul>
<li>从而保证了单例</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n1 = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat ; <span class="comment">//默认是 null</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Cat</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器调用...&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="keyword">null</span>) &#123;<span class="comment">//如果还没有创建 cat 對象</span></span><br><span class="line">            cat = <span class="keyword">new</span> Cat(<span class="string">&quot;小可愛&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="17-3-饿汉式VS懒汉式"><a href="#17-3-饿汉式VS懒汉式" class="headerlink" title="17.3 饿汉式VS懒汉式"></a>17.3 饿汉式VS懒汉式</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229171953279.png" alt="image-20211229171953279"></li>
</ul>
<h2 id="18-final关键字"><a href="#18-final关键字" class="headerlink" title="18.  final关键字"></a>18.  final关键字</h2><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229172659570.png" alt="image-20211229172659570"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229173357181.png" alt="image-20211229173357181"></p>
<ul>
<li><strong>常量变量名应大写</strong>。</li>
<li>final修饰的静态属性如果在构造器里面赋值，则第一步加载类信息的时候静态属性就会初始化，静态属性初始化后才执行构造器，此时该静态常量仍未赋值，但是静态初始化已经结束，<strong>因此不能再构造器中赋值</strong>。</li>
</ul>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211229174008141.png" alt="image-20211229174008141"></p>
<ul>
<li>关于<strong>final和static一起使用</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;静态代码块被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;静态代码块被执行 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.print(B.b);		<span class="comment">//此时输出  静态代码块被执行 5</span></span><br><span class="line">System.out.print(A.a); 		<span class="comment">//此时只输出 5	即final和static一起使用不会进行类加载</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="19-抽象类"><a href="#19-抽象类" class="headerlink" title="19.  抽象类"></a>19.  抽象类</h2><h3 id="19-1-概念"><a href="#19-1-概念" class="headerlink" title="19.1 概念"></a>19.1 概念</h3><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230155030868.png" alt="image-20211230155030868"></p>
<ul>
<li><p><strong>父类有一些方法不能确定</strong>时，可以将该方法定义为抽象方法，即该<strong>方法没有方法体</strong>。</p>
<ul>
<li>```java<br>public abstract int print();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 声明方法的时候加上`abstract`就是**抽象方法**，含有抽象方法的类必须改为**抽象类**，即class前面加上`abstract`。</span><br><span class="line"></span><br><span class="line">    + 抽象类**不能被实例化**，即不能`new`。</span><br><span class="line">      + **抽象类虽然不能new，但是可以用来声明变量，藉由此法可以指向子类的对象（即向上转型）**。</span><br><span class="line">    + **抽象类不一定要包含抽象方法**，包含抽象方法的类必须是抽象类。</span><br><span class="line">    + `abstract`**只能修饰方法和类，不能修饰属性**。</span><br><span class="line">    + 抽象类可以有任意成员，可以有非抽象方法，构造器，静态属性等等（类可以有什么它就可以有什么，**抽象类本质还是类**）。</span><br><span class="line">    + 抽象方法不可以用`private`、`final`、`static`来修饰，因为`private`一般由子类用`public`方法提供调用，不能直接重写，但是抽象方法有必须要子类实现，则不可能做到。`final`方法不允许重写，也无法实现。`static`修饰的方法可以直接不new来访问，而抽象方法还没有实现，与此违背。（**抽象类里面的属性可以用静态属性，此时抽象类虽然不能new，但静态属性不需要new也可以访问，可以通过类名直接调用这个静态属性**）</span><br><span class="line">    + 抽象类中的非抽象方法可以直接调用抽象方法。</span><br><span class="line"></span><br><span class="line">  + **一般抽象类会被继承，一个类如果继承了抽象类，那么它必须实现该抽象类的所有抽象方法，或者自己也声明为抽象类**。</span><br><span class="line"></span><br><span class="line">    + 只要有方法体就叫做实现，即使是空的方法体，例如：`public int print()&#123;&#125;`。（只要加了大括号就是）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 19.2  抽象类最佳实践：模板设计模式</span><br><span class="line"></span><br><span class="line">+ ![image-20211230170335979](https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230170335979.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20211230170358278](https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230170358278.png)</span><br><span class="line">  + 简单来说就是如果有**大量不同类中的&lt;u&gt;相同方法（指除了调用了本类的不同的方法外的基础语句相同）&lt;/u&gt;调用了不同类的&lt;u&gt;不同方法&lt;/u&gt;**，可以将此相同的方法放入父类，由于它在不同类中会调用不同方法，在父类中可以**将这个不同方法抽象化**（抽象类中普通方法可以直接调用抽象方法），然后子类继承后只需实现这个每个类不同的抽象方法即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 20. 接口</span><br><span class="line"></span><br><span class="line">### 20.1 接口概念</span><br><span class="line"></span><br><span class="line">+ 下面为了方便把 实现了接口的类 都写成了 子类</span><br><span class="line"></span><br><span class="line">+ ![image-20211230170511675](https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230170511675.png)</span><br><span class="line"></span><br><span class="line">  + 在**接口中抽象方法可以省略`abstract`关键字**，写不写**都可以**定义抽象方法。</span><br><span class="line"></span><br><span class="line">  + 接口中的方法在**jkd8以前**接口里的方法**只能是抽象方法**；**jdk8开始可以有静态方法，默认方法**（可以具体实现）</span><br><span class="line"></span><br><span class="line">    ![image-20211230171244797](https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230171244797.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 20.2  接口细节</span><br><span class="line"></span><br><span class="line">+ **&lt;u&gt;接口中所有方法都必须用`public`修饰&lt;/u&gt;**，因此这是默认的，**接口中不写修饰符默认代表是`pubilc`**。`abstact`关键字也是默认的，都可以省略不写。</span><br><span class="line"></span><br><span class="line">  + **子类**实现接口的抽象方法**不能省略`public`**，会提示缩小了访问范围。</span><br><span class="line"></span><br><span class="line">+ **一个普通类实现接口就必须实现接口的所有抽象方法（和抽象类一致）**，**&lt;u&gt;可以使用快捷键alt+enter&lt;/u&gt;**。而抽象类则可以不实现接口的抽象方法。</span><br><span class="line"></span><br><span class="line">+ **接口和抽象类不同处之一在于**：子类只能继承一个抽象类（除非多层继承），但可以实现多个接口。</span><br><span class="line"></span><br><span class="line">  + **接口的属性必须是`public static final`**。</span><br><span class="line"></span><br><span class="line">  + **&lt;u&gt;接口里的静态方法很特殊&lt;/u&gt;**，无法通过声明的实例调用（ID id = new A(); 这里A是实现了接口的类），`id.方法名`**无法调用接口里面有的静态方法**，静态方法看编译类型，ID接口里有按抽的概念来说是可以调用的，但接口会**提示错误为**：</span><br><span class="line"></span><br><span class="line">    ​							**只能对包含接口类的对象调用静态方法**</span><br><span class="line"></span><br><span class="line">    ![image-20211230232524905](https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230232524905.png)</span><br><span class="line">    </span><br><span class="line">    + 即使用实现了该接口的子类的声明创建实例也**无法调用接口里的静态方法**，例如A实现了接口，`A a = new A()`，**这时`a.方法名`仍不能调用到接口的静态方法，在类中是可以的，会往父类的类里面找**。</span><br><span class="line">    </span><br><span class="line">    + **抽象类中是可以的**，即通过抽象类作为编译类型、子类作为运行类型来**调用抽象类中实现的而子类没有实现方法**（静态非静态都可以，区别是**非静态在子类中实现后叫做重写，&lt;u&gt;静态不能重写&lt;/u&gt;但是也可以那样做**（看起来像重写），上面分析过，即**实质是放在不同空间的两个同样的方法**，这个空间指的是**类的作用空间而不是对象的空间**，调用时**看编译类型而不是看运行类型**，**没有动态绑定机制**，因为动态绑定实质上是使用父类的声明指向子类的引用，在编译的时候看编译类型，此时不能调用子类中的特有方法，因为编译的时候被当做是父类在调用，实质运行的时候由于普通方法存在在对象中，运行的时候回去找到具体的对象所在地址，则运行的时候是跑到指向的地址去调用，即看运行类型，但是静态方法本就存在于类中，可以直接通过`类名.方法名`调用不用new对象，因为静态方法在类中不在对象中，因此在运行的时候，例如**`父类A，子类B`，`A a = new B();`用`a.方法名`调用静态方法会直接找这个变量a的类里面的静态方法，不用去找到这个变量指向的地址去调用，因为静态方法不在对象中**，这里不会去找对象，**即使运行类型是B也不会调用B类的静态方法，除非用B类型声明对象，就会从B类开始找**，如果**找不到则会向上面的父类的类中查找**），&lt;u&gt;**这里接口和抽象类区别很大**&lt;/u&gt;。</span><br><span class="line">    </span><br><span class="line">  + 接口的**默认方法`default`可以被实现接口的子类&lt;u&gt;重写&lt;/u&gt;，也可以被调用，看起来和继承父类的普通方法一样**</span><br><span class="line"></span><br><span class="line">  + **接口里的属性在子类可以使用**，如果子类同时定义同名属性就会先调用子类的属性，这点和继承中使用父类属性一样（**时刻注意属性看的是编译类型，会从声明变量的那个类型开始找，接口中规则也是一样的**）。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  interface ID&#123;</span><br><span class="line">      void h();</span><br><span class="line">  &#125;</span><br><span class="line">  interface IB&#123;</span><br><span class="line">      void k();</span><br><span class="line">  &#125;</span><br><span class="line">  class Aa implements ID,IB &#123;//可以一次实现多个接口</span><br><span class="line">      @Override</span><br><span class="line">      public void h() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void k() &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;	</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>接口不能<strong>继承</strong>其他的<strong>类</strong>，但可以<strong>继承</strong>多个其别的<strong>接口</strong>。（**接口和接口之间是<u>继承</u>，类和接口之间是<u>实现</u>**）</p>
</li>
<li><p>**接口的修饰符只能是<code>public</code>和<code>默认</code>的(和类一样)**。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230223422063.png" alt="image-20211230223422063"></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230223438994.png" alt="image-20211230223438994"></p>
<ul>
<li><p><strong>和抽象类一样，接口虽然本身不能被实例化，但可以用来声明变量指向实现了自己这个接口子类的实例。抽象类也同样不能实例化，同样也可以用来声明变量指向子类的实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ID</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;	<span class="comment">//接口里的属性默认是public static final的，因此必须赋初值</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;	<span class="comment">//接口的方法默认都是public，这里不写也是public</span></span><br><span class="line">        System.out.println(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aa</span> <span class="keyword">implements</span> <span class="title">ID</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ID();			<span class="comment">//这是错误的，接口不能实例化</span></span><br><span class="line">ID id = <span class="keyword">new</span> Aa();	<span class="comment">//这是可以的，虽然本身不能实例化，但可以声明变量指向实现了自己的类的实例对象</span></span><br><span class="line">id.say();	<span class="comment">//错误，接口里的静态方法很特殊，无法通过声明的实例调用，抽象类中是可以的，这个是接口和抽象类的一大区别</span></span><br><span class="line">System.out.println(id.a);<span class="comment">//静态属性是可以通过实例调用的</span></span><br><span class="line">System.out.println(ID.a);	<span class="comment">//输出 5 ，接口和抽象类虽然不能实例化，但是这种调用静态成员的方式避开了new实例化，是可以的</span></span><br><span class="line">ID.say();	<span class="comment">//输出 9 ，同上，抽象类也如此</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="20-3-继承-接口"><a href="#20-3-继承-接口" class="headerlink" title="20.3  继承 + 接口"></a>20.3  继承 + 接口</h3><ul>
<li><p>一个类可以同时<strong>继承父类然后实现多个接口</strong>（这点是使用抽象类做不到的，因为只能继承一个），<strong>可以将实现接口理解为是对java单继承机制的一种补充</strong>。<code>class Aa extends B implements ID</code>，<strong>顺序必须是先继承然后实现接口，不能先实现接口然后继承</strong>。此时<strong>父类中的普通方法如果和接口中的default方法重名</strong>，而子类没有去实现重写，调用的时候会先调用父类的方法而不是接口中的，从<strong>先后顺序也知道是先继承后实现接口</strong>。</p>
<ul>
<li><p>但不过<strong>属性不允许继承的父类和接口中有重名</strong>，<strong>不管父类中的是静态还是非静态</strong>，都不允许和接口中的属性重名，在使用该属性的时候会提示对属性的<strong>引用不明确</strong>，但不过<strong>如果不使用就不会报错</strong>（在<strong>子类中使用</strong>或者在<strong>声明对象后想调用</strong>的时候都会<strong>报错</strong>，提示引<strong>用不明确</strong>）。<img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231101447632.png" alt="image-20211231101447632"></p>
<ul>
<li>但是**可以明确指定属性，例如<code>super.a</code>（明确指定访问父类）和<code>ID.a</code>(因为接口中的属性都是静态的，可以直接访问)**，这样使用就不会报错</li>
</ul>
</li>
<li><p>此时<strong>用向上转型规则用父类声明变量指向子类实例对象规则不变</strong>，即编译的时候只能调用父类的方法，运行的时候动态绑定到子类开始搜索。（<strong>静态方法看编译类型，属性不管静态属性还是非静态都是看编译类型</strong>）</p>
</li>
</ul>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231102137519.png" alt="image-20211231102137519"></p>
</li>
</ul>
<h3 id="20-4-接口的多态"><a href="#20-4-接口的多态" class="headerlink" title="20.4 接口的多态"></a>20.4 接口的多态</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231110556926.png" alt="image-20211231110556926"><ul>
<li><strong>多态传递</strong>就是指一个接口ID继承另一个接口IG后，一个类如果要实现ID接口，那么它必须同时实现IG接口。</li>
</ul>
</li>
</ul>
<h2 id="21-内部类（重难点）"><a href="#21-内部类（重难点）" class="headerlink" title="21. 内部类（重难点）"></a>21. 内部类（重难点）</h2><ul>
<li><p><strong>类的五大成员</strong>：属性，方法，构造器，代码块，<strong>内部类</strong>。</p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123513536.png" alt="image-20211231123513536"></p>
</li>
<li><blockquote>
<ol>
<li><p>如果定义类在局部位置(方法中/代码块) ：**(1) 局部内部类 (2)  匿名内部类**。</p>
</li>
<li><p>定义在成员位置： <strong>(1) 成员内部类 (2) 静态内部类</strong>。</p>
<img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123529853.png" alt="image-20211231123529853" style="zoom: 67%;" /></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="21-1-局部内部类"><a href="#21-1-局部内部类" class="headerlink" title="21.1 局部内部类"></a>21.1 局部内部类</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123546280.png" alt="image-20211231123546280"></p>
</li>
<li><p><strong>有作用域限制</strong>，必须在方法体或者代码块中才能访问，<strong>如果要在外部访问</strong>，需要在此局部内部类<strong>所在方法体/代码块</strong>中<strong>new一个对象实例</strong>出来，然后调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner02</span> </span>&#123;<span class="comment">//局部内部类(本质仍然是一个类),不能加访问修饰符，因为局部变量是不能使用修饰符的，但可以使用final（局部变量可以用final），让其它类无法继承</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外部类在方法中，可以创建 Inner02 对象，然后调用方法即可</span></span><br><span class="line">    Inner02 inner02 = <span class="keyword">new</span> Inner02();</span><br><span class="line">    inner02.f1();<span class="comment">//此时调用m1()方法即可调用局部内部类的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231123555134.png" alt="image-20211231123555134"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.print(a);<span class="comment">//输出4，就近原则</span></span><br><span class="line">                System.out.print(A.<span class="keyword">this</span>.a);<span class="comment">/*这样才能访问到外部类的成员但是要注意这个 A.this 的意思是谁调用了m1()这个方法就表示哪个对象()，如果是继承了A的一个子类创建的对象调用它，则代表这个子类创建的对象，但不过要注意的是如果此时用这个方法来访问属性，则会直接调用A的属性，虽然A.this代表了子类的地址，但是属性是和编译类型绑定的，A.this.a默认访问A类中的A，因为这里A是编译类型。相当于A.this这种用法相当于A表示编译类型，this则指向运行类型的地址，可以将这两 组合看成 一个编译类型是A运行类型是调用此方法的对象的 一个变量，即如果是子类调用就可以A.this看成是向上转型声明的变量，例如这两组合就代表一个类似于 A a = ?中的变量a，即A.this等价于这里的a。所以这里调用属性会调用A的属性而不是实际运行它的对象的属性，如果用A.this调用 方法 则会从子类开始查找，因为运行类型是子类这个类型。</span></span><br><span class="line"><span class="comment">                这样理解更好：A.this的语句已经写死了，不管谁调用它都是A.this，一万个子类继承也是A.this，因此在调用的时候理解为从A这个类开始调用，如果是属性就直接调用A的属性，如果是方法就像向上转型后在父类中调用父类和子类都有的方法还是会回到子类调用一样，从子类开始搜索，即动态绑定。</span></span><br><span class="line"><span class="comment">                而A.super就很好理解了，不管谁继承了A，这个语句都已经写死了就是A.super，它固定死了是代表A的父类，找方法和属性都是从A的父类开始找，不管是A的多少层子类调用，都是从A的父类开始找，找不到就找A父类的父类*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-2-匿名内部类-最重要"><a href="#21-2-匿名内部类-最重要" class="headerlink" title="21.2 匿名内部类(最重要)"></a>21.2 匿名内部类(最重要)</h3><ul>
<li>有时候为了实现一个接口，需要专门创建一个类，但是这个类只使用一次，为了这就创建一个类不划算，因此引出匿名内部类</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231192708828.png" alt="image-20211231192708828" style="zoom:67%;" /></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231205302723.png" alt="image-20211231205302723"></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231205450925.png" alt="image-20211231205450925" style="zoom: 50%;" /></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211231205318623.png" alt="image-20211231205318623"></li>
<li><strong>同样定义在局部位置（代码块/方法体），是局部的</strong></li>
<li><strong>这里匿的是类名，之前讲的匿名对象匿的是对象名</strong></li>
</ul>
<h4 id="21-2-1-基于接口的匿名内部类"><a href="#21-2-1-基于接口的匿名内部类" class="headerlink" title="21.2.1 基于接口的匿名内部类"></a>21.2.1 基于接口的匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ID</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">K</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ss</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ID gg = <span class="keyword">new</span> ID()&#123;	<span class="comment">//如此相当于创建一个匿名类实现ID的方法然后new这个匿名类返回给ID编译类型的gg，这里编译类型是ID，运行类型是匿名类的类型</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;GG&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;<span class="comment">//这里有分号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此匿名内部类的名字是 K$1 即外部类名加一个$1，这个名字是系统底层分配的</span></span><br><span class="line"><span class="comment">/*底层是实现了class K$1 implements ID &#123;</span></span><br><span class="line"><span class="comment">                    @Override</span></span><br><span class="line"><span class="comment">                    public void cry() &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎叫唤...&quot;);</span></span><br><span class="line"><span class="comment">                     &#125;</span></span><br><span class="line"><span class="comment">				&#125;，然后将这个匿名对象实例化再将地址返回给gg*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名内部内的<strong>编译类型是接口类型</strong>，<strong>运行类型</strong>是<strong>匿名内部类所属类型</strong>。</li>
<li><strong>jdk 底层在创建匿名内部类 K$1,立即马上就创建了 k$1 实例，并且把地址返回给 gg</strong>。<ul>
<li>这个添加的 $1 是<strong>底层统一编号</strong>的，如果有两个匿名类，<strong>第二个</strong>就是 $2</li>
<li>因此这里说的<strong>匿名内部类不是说它没有名字</strong>，只是这个名字<strong>不会被显式看到</strong>，这个<strong>匿名内部类的名字是由系统自动分配的</strong>。</li>
</ul>
</li>
<li>匿名内部类使用<strong>一次，就不能再使用</strong>，<strong>只是这个类不能被使用</strong>，上面它已经实例化一次将实例化对象赋给了gg，这个<strong>对象是可以一直用的</strong>。</li>
</ul>
<h4 id="21-2-2-基于类的匿名内部类"><a href="#21-2-2-基于类的匿名内部类" class="headerlink" title="21.2.2 基于类的匿名内部类"></a>21.2.2 基于类的匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.print(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father(<span class="string">&quot;jack&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">            <span class="comment">/*注大意：这里的&quot;Jack&quot;传给了Father的构造器，因为在底层的时候创建匿名对象是继承了Father，则必须初始化父类的构造器的意思，因此如果执行到这一步，就会执行构造器里的语句，输出&quot;jack&quot;。</span></span><br><span class="line"><span class="comment">        而且无法重写构造器，因为不知道类名，只能直接使用父类的构造器。</span></span><br><span class="line"><span class="comment">        但不过可以自己定义属性，只不过访问不到，因为编译类型是Father，属性会找编译类型，而找运行类型的属性需要向下转型，而类名是匿名的，也无法完成向下转型，这个属性则无法直接访问。要想访问这个属性：</span></span><br><span class="line"><span class="comment">        1：通过在重写的方法里面操作属性，然后通过调用这个方法来获取属性值，但要注意这个方法必须是重写父类中有的方法，不能自己新增一个特有的方法，因为这样无法调用，因为编译类型是父类Father类型，编译的时候如果父类中没有此方法则无法调用，想要调用特有方法方式和属性一样，重写父类的方法后在此方法中调用才行</span></span><br><span class="line"><span class="comment">        2.使用匿名对象的方式（和匿名类区分），由于匿名类不需要引用，创建实例后直接调用，因此编译类型和运行类型都是这个匿名类的类型，只不过只能用一次。调用特有方法也可通过匿名对象来规避编译类型是Father*/</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了 test 方法&quot;</span>);</span><br><span class="line">                System.out.println(a);<span class="comment">//访问自己的属性a</span></span><br><span class="line">                System.out.println(Outer.<span class="keyword">this</span>.a);<span class="comment">//访问外部类的属性</span></span><br><span class="line">                System.out.println(<span class="keyword">super</span>.a);<span class="comment">//访问父类即Father的属性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*底层是做了这样一个操作</span></span><br><span class="line"><span class="comment">class Outer04$1 extends Father&#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public void test() &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;匿名内部类重写了 test 方法&quot;);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;，然后new这个类的实例出来返回地址给father*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里其实和接口一样，<strong>编译类型是Father类型，运行类型是匿名内部类的类型，这里也就是 Outer$1 这个类型是它的运行类型</strong>。</li>
<li><strong>这里的Father可以是抽象类，只不过在创建匿名内部类的时候必须实现Father里面的方法，和接口一样</strong>。</li>
</ul>
<h4 id="21-2-3-匿名内部类的两种调用方式"><a href="#21-2-3-匿名内部类的两种调用方式" class="headerlink" title="21.2.3 匿名内部类的两种调用方式"></a>21.2.3 匿名内部类的两种调用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了 test 方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        father.test();<span class="comment">//这是第一种</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了 test 方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.test();<span class="comment">//这是第二种，这里使用到了匿名对象，使用一次对象的方法，注意这里是可以调用父类的方法的，因为底层是继承了Father类,此时运行类型和编译类型统一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="21-2-4-匿名对象的实践"><a href="#21-2-4-匿名对象的实践" class="headerlink" title="21.2.4 匿名对象的实践"></a>21.2.4 匿名对象的实践</h4><ul>
<li><p><strong>可以直接用匿名对象当做参数传递</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sayf(<span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);	<span class="comment">/*相当于传入了一个编译类型是Father运行类型是Father子类的匿名类的实例，这里将会输出 115 ，因为这个匿名类继承了Faher类的属性*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayf</span><span class="params">(Father f)</span></span>&#123;<span class="comment">//在主方法中直接调用它，主方法是静态的，想要直接调用这个方法那么这个方法也必须是静态的 </span></span><br><span class="line">        f.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">115</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>此举的好处之一是简洁，我只要用一次这个的话就不必创建一个Father子类然后传入</strong>。</li>
<li><strong>其次是如果先创建Father子类实现了他的抽象方法，如果传入的时候想改变方法，那么所有运用到这个子类的地方就都会变化，利用匿名类这样创建匿名对象传入就只影响这里</strong>。</li>
</ul>
</li>
</ul>
<h3 id="21-3-成员内部类"><a href="#21-3-成员内部类" class="headerlink" title="21.3 成员内部类"></a>21.3 成员内部类</h3><ul>
<li><p><strong>定义在成员位置，本质是成员，可以用访问修饰符修饰</strong>。</p>
<ul>
<li>```java<br>class AD{<pre><code> class AF&#123;
    public final static int a = 5;
&#125;
</code></pre>
}System.out.println(AD.AF.a);//可以输出5<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ![image-20220101152636455](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101152636455.png)</span><br><span class="line"></span><br><span class="line">+ 这里要注意**如果成员内部类没有用static修饰，那么成员内部类里面的成员就不能直接用static，必须和final一起使用**（我的理解：因为静态成员要满足不创建实例就可以调用的特点，因此想要调用这个内部类的a会使用`AD.AF.a`的操作，而AF不是静态的，`AD.AF`这一步无法成立，因为**`AD.AF`的意思是直接加载AD类然后调用AD&lt;u&gt;类里面&lt;/u&gt;的东西而&lt;u&gt;不是对象实例里面&lt;/u&gt;的东西**，**静态成员在类里面**不在对象实例里面因此可以`AD.AF`**通过加载AD类就调用AF**，但是**AF不是静态的就不在AD类里面，只加载AD不创建实例无法调用**。但是如果使用**`public final static int a = 5;`**就**不用加载类**可以直接调用，因此可行）</span><br><span class="line"></span><br><span class="line">+ **常量变量**即用`final`修饰的变量，注意，**&lt;u&gt;方法&lt;/u&gt;**如果用`static`修饰即使+`final`也没用，此时**必须要成员内部类也用`static`修饰**，即属性加了`final`就是常量，**此时属性无关乎类，使用时不加载类也可调用**，而**方法体里面势必会有调用类的其他成员的语句**，如果有那么**不加载类这些成员就无法使用**，由于**这点无法控制**，因此方法即使用`static+final`也要先加载类，**因此成员内部类的方法如果要static则必须让这个成员内部类也用static修饰**，否则外部如果直接调用这个方法会出错，例如`AD.AF`因为**内部类没static就不能直接调用而需要new实例**。</span><br><span class="line"></span><br><span class="line">+ **但是如果成员内部类用`static`修饰后，在外部其它类无法通过&lt;u&gt;外部类的对象&lt;/u&gt;创建静态内部类的对象实例，需要直接`AD.AF af = new AD.AF();`，或者通过外部本类的方法返回**。此时如果**`AD ad = new AD(); AD.AF af = ad.new AF();`**想new对象会提示![image-20220101155047956](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155047956.png)。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  class AD&#123;</span><br><span class="line">      public static class AF &#123;&#125;</span><br><span class="line">      public AF getAF()&#123;</span><br><span class="line">      	return new AF();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //第一种</span><br><span class="line">  AD.AF af = new AD.AF();</span><br><span class="line">  //第二种</span><br><span class="line">  AD ad = new AD();</span><br><span class="line">  AD.AF af = ad.getAF();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155207964.png" alt="image-20220101155207964" style="zoom: 50%;" /></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155213887.png" alt="image-20220101155213887" style="zoom: 67%;" />

<ul>
<li><p><strong>外部其它类访问成员内部类的三种方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">AF</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">AD ad = <span class="keyword">new</span> AD();</span><br><span class="line">AD.AF af = ad.<span class="function">new <span class="title">AF</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种：在外部类中创建一个方法创建这个类的对象返回</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">AF</span></span>&#123;&#125;</span><br><span class="line">   	 <span class="function"><span class="keyword">public</span> AF <span class="title">getAF</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AF();	<span class="comment">//外部其它类直接调用这个方法就行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AD ad = <span class="keyword">new</span> AD();</span><br><span class="line">AD.AF af = ad.getAF();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">AF</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">AD.AF af = <span class="keyword">new</span> AD().<span class="function">new <span class="title">AF</span><span class="params">()</span></span>;	<span class="comment">//最简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//番外 静态内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AF</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">AD.AF af = <span class="keyword">new</span> AD.AF();	</span><br><span class="line"><span class="comment">//注意不能通过外部类的实例对象来创建静态内部类的对象,上面提过</span></span><br><span class="line">AD.AF af = <span class="keyword">new</span> AD().<span class="function">new <span class="title">AF</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101155226196.png" alt="image-20220101155226196" style="zoom:50%;" /></li>
</ul>
<h3 id="21-4-静态内部类"><a href="#21-4-静态内部类" class="headerlink" title="21.4 静态内部类"></a>21.4 静态内部类</h3><h4 id="21-4-1-小tips"><a href="#21-4-1-小tips" class="headerlink" title="21.4.1 小tips"></a>21.4.1 小tips</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173153957.png" alt="image-20220101173153957"></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173204267.png" alt="image-20220101173204267"></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173208585.png" alt="image-20220101173208585"></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101173212442.png" alt="image-20220101173212442"><ul>
<li><strong>注意：这里要访问外部本类成员是 外部类名.成员 不用this，因为这是静态类只能访问静态成员，因为此成员必须是静态的</strong>。</li>
</ul>
</li>
</ul>
<h4 id="21-4-2-如何在外部其它类得到静态内部类对象实例"><a href="#21-4-2-如何在外部其它类得到静态内部类对象实例" class="headerlink" title="21.4.2 如何在外部其它类得到静态内部类对象实例"></a>21.4.2 如何在外部其它类得到静态内部类对象实例</h4><ul>
<li>```java<br>class AD {<pre><code>public static class AF &#123;
    public static int a = 4;
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + 在学成员内部类时有了解到，**在外部其它类想要创建静态内部类对象不能通过先创建外部本类对象再创建静态内部类对象**，会提示![image-20220101170652340](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101170652340.png)。而**普通成员内部类是可以这样创建的**。</span><br><span class="line">    + **这并不代表静态内部类不能实例化**，在静态内部类自己内部和外部本类中都可以实例化</span><br><span class="line"></span><br><span class="line">+ **方法一**：**静态内部类必须`AD.AF af = new AD.AF();`**，这样通过类名AD访问到静态成员AF创建</span><br><span class="line"></span><br><span class="line">+ **方法二**：**在外部本类创建方法返回这个静态内部类的实例对象**。</span><br><span class="line"></span><br><span class="line">  + 注意这个外部本类的**方法可以是静态方法，因为这个类是静态的**，可以调用，且此时便**不用创建外部本类的对象然后调用方法，因为静态方法直接调用**。</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    class AD&#123;</span><br><span class="line">        public static class AF &#123;&#125;</span><br><span class="line">        public AF getAF()&#123;</span><br><span class="line">        	return new AF();</span><br><span class="line">        &#125;</span><br><span class="line">        public static AF getAF1()&#123;</span><br><span class="line">        	return new AF();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1</span><br><span class="line">    AD ad = new AD();</span><br><span class="line">    AD.AF af = ad.getAF();</span><br><span class="line">    AD.AF af0 = new AD().getAF();//利用匿名对象</span><br><span class="line">    //2</span><br><span class="line">    AD.AF af1 = AD.getAF1();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="22-枚举与注解"><a href="#22-枚举与注解" class="headerlink" title="22. 枚举与注解"></a>22. 枚举与注解</h2><ul>
<li><strong>枚举对应英文(enumeration, 简写 enum)</strong></li>
</ul>
<ol start="2">
<li>枚举是一组常量的集合。</li>
<li><strong>可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象</strong>。</li>
</ol>
<h3 id="22-1-自定义枚举"><a href="#22-1-自定义枚举" class="headerlink" title="22.1 自定义枚举"></a>22.1 自定义枚举</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101194552893.png" alt="image-20220101194552893"><ol>
<li><strong>构造器私有化</strong></li>
</ol>
<ol start="2">
<li><strong>本类内部创建一组对象[四个 春夏秋冬]</strong></li>
<li><strong>对外暴露对象（通过为对象添加 public final static 修饰符）</strong></li>
<li><strong>可以提供 get 方法，但是不要提供 set</strong></li>
</ol>
</li>
</ul>
<h3 id="22-2-enum关键字实现枚举"><a href="#22-2-enum关键字实现枚举" class="headerlink" title="22.2 enum关键字实现枚举"></a>22.2 enum关键字实现枚举</h3><ol>
<li> <strong>使用关键字 enum 替代 class</strong></li>
<li> <strong>public static final Season SPRING = new Season(“春天”, “温暖”) 直接使用 SPRING(“春天”, “温暖”)</strong> </li>
<li><strong>如果有多个常量(对象)， 使用<code> ,</code>号间隔即可</strong></li>
<li><strong>如果使用 enum 来实现枚举，要求将定义常量对象<u>写在最前面</u></strong></li>
<li><strong>如果我们使用的是无参构造器，创建常量对象，则可以省略 ()</strong></li>
<li><strong>用enum实现的类默认是继承<code>Enum</code>类的，java是单继承机制，因此不能再继承其他类，而同时实现的类是个final类，也不能被其他类继承</strong>（ctrl+h可看到继承关系，javap也可看到）<ul>
<li><strong>虽然不能继承其他类，但是可以实现接口</strong><code>enum Music implements ID</code>这样，因为本来先继承后实现接口的语法就是成立的，这样就相当于继承了Enum再实现接口罢了</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;暖和&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;炎热&quot;</span>);<span class="comment">//逗号分隔，且必须放在第一句</span></span><br><span class="line">    <span class="comment">// public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);</span></span><br><span class="line">    <span class="comment">// public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);</span></span><br><span class="line">    <span class="comment">// public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);</span></span><br><span class="line">    <span class="comment">// public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;炎热&quot;);</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String des;</span><br><span class="line"></span><br><span class="line">    Season(String name, String des) &#123;<span class="comment">//构造器默认私有，可写可不写</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.des = des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> des;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, des=&#x27;&quot;</span> + des + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101200841410.png" alt="image-20220101200841410"><ul>
<li><strong>使用javap看.java文件的内容</strong>。</li>
</ul>
</li>
</ul>
<h4 id="22-2-1-Enum类的toString-方法"><a href="#22-2-1-Enum类的toString-方法" class="headerlink" title="22.2.1 Enum类的toString()方法"></a>22.2.1 Enum类的toString()方法</h4><ul>
<li><p>```java<br>/**</p>
<pre><code> * Returns the name of this enum constant, as contained in the
 * declaration.  This method may be overridden, though it typically
 * isn&#39;t necessary or desirable.  An enum type should override this
 * method when a more &quot;programmer-friendly&quot; string form exists.
 *
 * @return the name of this enum constant
 */
public String toString() &#123;
    return name;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **从&lt;u&gt;最后一句&lt;/u&gt;可以得知，Enum类的toString()方法是返回枚举对象的常量名，而不是属性值**。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  enum  Season&#123;</span><br><span class="line">      SPRING(&quot;春天&quot;);</span><br><span class="line">      private String name;</span><br><span class="line">      Season(String name) &#123;</span><br><span class="line">          this.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Season.SPRING);//此时输出 &quot;SPRING&quot; ,而不是春天</span><br><span class="line">  </span><br><span class="line">  //如果重写此方法，即使完封不动，就会返回属性名了</span><br><span class="line">  enum  Season&#123;</span><br><span class="line">      SPRING(&quot;春天&quot;);</span><br><span class="line">      private String name;</span><br><span class="line">      Season(String name) &#123;</span><br><span class="line">          this.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">      public String toString() &#123;</span><br><span class="line">          return name;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(Season.SPRING);//此时输出 &quot;春天&quot;</span><br></pre></td></tr></table></figure>

<p>  <strong>我的分析</strong>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sole constructor. Programmers cannot invoke this constructor. It is for use by code emitted by the compiler in response to enum type declarations</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">唯一的构造器。程序员不能调用此构造函数。它供编译器响应枚举类型声明而发出的代码使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name – - The name of this enum constant, which is the identifier used to declare it.</span></span><br><span class="line"><span class="comment">ordinal – - The ordinal of this enumeration constant (its position in the enum declaration, where the initial constant is assigned an ordinal of zero).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name––此枚举常量的名称，它是用于声明它的标识符。</span></span><br><span class="line"><span class="comment">ordinal––此枚举常量的序数（其在枚举声明中的位置，初始常量的序数为零）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由此可见，<strong>name和ordinal都是Enum类自己独有的属性</strong>，且由构造器初始化，但是子类并不能调用这个构造器，<strong>它的调用是随着创建枚举对象而自行调用，name代表创建的当前枚举对象名字，ordinal代表当前枚举对象是第几个，从0开始计数</strong>，因此<code>enum</code>实现的枚举类中也不必初始化它。<ul>
<li><strong>所以这个name和自己定义的name不是同一个意思，Enum里的name特指常量名也就是枚举对象名，如果自己不显示的定义<code>toString()</code>则会返回Enum里的name属性而不是自己的name属性，即返回常量名</strong>。</li>
<li><strong><code>ordinal</code>则是记录当前创建了多少个枚举对象</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="22-2-3-Enum类的方法"><a href="#22-2-3-Enum类的方法" class="headerlink" title="22.2.3 Enum类的方法"></a>22.2.3 Enum类的方法</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101205910404.png" alt="image-20220101205910404"></li>
</ul>
<h5 id="22-2-3-1-values-方法"><a href="#22-2-3-1-values-方法" class="headerlink" title="22.2.3.1 values()方法"></a>22.2.3.1 values()方法</h5><ul>
<li><strong>values()方法是静态方法</strong>返回一个数组，该数组包含此枚举类型的<strong>常量(即各个对象）</strong>，按声明顺序排列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这种写法叫增强for循环，意思是从Season.values()返回的数组中从头一次取出一个元素给c，c的类型是Season类型</span></span><br><span class="line"><span class="keyword">for</span>(Season c : Season.values()) &#123;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>输出创建的各个枚举对象名，即常量名，因为直接输出对象会调用toString()方法，而它的toString()方法是返回常量名</strong>。</li>
</ul>
<h5 id="22-2-3-2-valueOf-方法"><a href="#22-2-3-2-valueOf-方法" class="headerlink" title="22.2.3.2 valueOf()方法"></a>22.2.3.2 valueOf()方法</h5><ul>
<li><p><strong>将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常</strong>！</p>
<ul>
<li><p>```java<br>Season a = Season2.valueOf(“SPRING”);<br>System.out.println(a);//在Season中找到了名字是SPRING的枚举对象，则输出”SPRING”，因为返回的就是这个名字的枚举对象，直接输出对象又会调用toString()返回名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **执行流程**：</span><br><span class="line"></span><br><span class="line">    1. **根据你输入的 &quot;SPRING&quot; 到 Season 的枚举对象去查找**。</span><br><span class="line">    2.  **如果找到了，就返回这个枚对象，如果没有找到，就报错**，和Season里定义的SPRING是同一个对象。</span><br><span class="line"></span><br><span class="line">##### 22.2.3.3 compareTo()方法</span><br><span class="line"></span><br><span class="line">+ **compareTo：比较两个枚举常量，比较的就是编号**！</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    System.out.println(Season.SPRING.compareTo(Season.SUMMER));</span><br></pre></td></tr></table></figure>

<ul>
<li>**比较SPRING和SUMMER的ordinal值，返回的是相减后的数字(int)**。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="22-3-注解-Annotation"><a href="#22-3-注解-Annotation" class="headerlink" title="22.3 注解(Annotation)"></a>22.3 注解(Annotation)</h3><ul>
<li><strong>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</strong></li>
<li><strong>三个基本的 Annotation:</strong><ol>
<li><strong>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</strong></li>
<li><strong>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</strong></li>
<li><strong>@SuppressWarnings: 抑制编译器警告</strong></li>
</ol>
</li>
</ul>
<h4 id="22-3-1-Override"><a href="#22-3-1-Override" class="headerlink" title="22.3.1 @Override"></a>22.3.1 @Override</h4><ul>
<li><p><strong>加不加的区别在于加了后如果没构成重写就会报错</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 @Target 写了 ElementType 元素类型，然后METHOD的意思是@Override只能修饰方法，不能修饰其他</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p> <strong>@Override只能修饰方法，不能修饰其他</strong>。</p>
</li>
<li><p><strong>@Target是修饰注解的注解，叫做元注解</strong>。</p>
</li>
<li><p><strong>如果发现@interface 表示一个 注解类，不要以为是接口</strong>。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101220142246.png" alt="image-20220101220142246"></p>
</li>
</ul>
</li>
</ul>
<h4 id="22-3-2-Deprecated"><a href="#22-3-2-Deprecated" class="headerlink" title="22.3.2 @Deprecated"></a>22.3.2 @Deprecated</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101220703015.png" alt="image-20220101220703015"><ul>
<li><strong>用这个注解修饰过后代表不推荐使用，但是可以用</strong>。</li>
</ul>
</li>
</ul>
<h4 id="22-3-3-SuppressWarnings"><a href="#22-3-3-SuppressWarnings" class="headerlink" title="22.3.3@SuppressWarnings"></a>22.3.3@SuppressWarnings</h4><ol>
<li><strong>当我们不希望看到这些警告的时候，可以使用 SuppressWarnings 注解来抑制警告信息</strong></li>
<li><strong>在{“”} 中，可以写入你希望抑制(不显示)警告信息</strong></li>
<li><strong>可以指定的警告类型有</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all，抑制所有警告</span></span><br><span class="line"><span class="comment">// boxing，抑制与封装/拆装作业相关的警告</span></span><br><span class="line"><span class="comment">//cast，抑制与强制转型作业相关的警告</span></span><br><span class="line"><span class="comment">//dep-ann，抑制与淘汰注释相关的警告</span></span><br><span class="line"><span class="comment">//deprecation，抑制与淘汰的相关警告</span></span><br><span class="line"><span class="comment">//fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告</span></span><br><span class="line"><span class="comment">//finally，抑制与未传回 finally 区块相关的警告</span></span><br><span class="line"><span class="comment">//hiding，抑制与隐藏变数的区域变数相关的警告</span></span><br><span class="line"><span class="comment">//incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告</span></span><br><span class="line"><span class="comment">//javadoc，抑制与 javadoc 相关的警告</span></span><br><span class="line"><span class="comment">//nls，抑制与非 nls 字串文字相关的警告</span></span><br><span class="line"><span class="comment">//null，抑制与空值分析相关的警告</span></span><br><span class="line"><span class="comment">//rawtypes，抑制与使用 raw 类型相关的警告</span></span><br><span class="line"><span class="comment">//resource，抑制与使用 Closeable 类型的资源相关的警告</span></span><br><span class="line"><span class="comment">//restriction，抑制与使用不建议或禁止参照相关的警告</span></span><br><span class="line"><span class="comment">//serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告</span></span><br><span class="line"><span class="comment">//static-access，抑制与静态存取不正确相关的警告</span></span><br><span class="line"><span class="comment">//static-method，抑制与可能宣告为 static 的方法相关的警告</span></span><br><span class="line"><span class="comment">//super，抑制与置换方法相关但不含 super 呼叫的警告</span></span><br><span class="line"><span class="comment">//synthetic-access，抑制与内部类别的存取未最佳化相关的警告</span></span><br><span class="line"><span class="comment">//sync-override，抑制因为置换同步方法而遗漏同步化的警告</span></span><br><span class="line"><span class="comment">//unchecked，抑制与未检查的作业相关的警告</span></span><br><span class="line"><span class="comment">//unqualified-field-access，抑制与栏位存取不合格相关的警告</span></span><br><span class="line"><span class="comment">//unused，抑制与未用的程式码及停用的程式码相关的警告</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>关于 SuppressWarnings 作用范围是和你放置的位置相关比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main，<u>通常我们可以放置具体的语句, 方法, 类</u></strong>.</p>
</li>
<li><p><strong>看看 @SuppressWarnings 源码</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="comment">        @Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="comment">        public @interface SuppressWarnings &#123;</span></span><br><span class="line"><span class="comment">        String[] value();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//(1) 放置的位置就是 TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE</span></span><br><span class="line"><span class="comment">//(2) 该注解类有数组 String[] values()，可以传入一个数组比如 &#123;&quot;rawtypes&quot;, &quot;unchecked&quot;, &quot;unused&quot;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List list = newArrayList();</span><br><span class="line">    list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    List list = newArrayList();</span><br><span class="line">    list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    <span class="comment">// @SuppressWarnings(&#123;&quot;unused&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101222054912.png" alt="image-20220101222054912"></li>
</ul>
<h4 id="22-3-4-元Annotation-元注解"><a href="#22-3-4-元Annotation-元注解" class="headerlink" title="22.3.4 元Annotation(元注解)"></a>22.3.4 元Annotation(元注解)</h4><ul>
<li><p><strong>JDK 的元 Annotation 用于修饰其他 Annotation</strong></p>
</li>
<li><p><strong>元注解的种类</strong></p>
<ol>
<li><strong>Retention //指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</strong></li>
<li><strong>Target // 指定注解可以在哪些地方使用</strong></li>
<li><strong>Documented //指定该注解是否会在 javadoc 体现</strong></li>
<li><strong>Inherited //子类会继承父类注解</strong></li>
</ol>
</li>
</ul>
<h5 id="22-3-4-1-Retention-注解"><a href="#22-3-4-1-Retention-注解" class="headerlink" title="22.3.4.1 @Retention 注解"></a>22.3.4.1 @Retention 注解</h5><ul>
<li>只能用于修饰一个 Annotation 定义, <strong>用于指定该 Annotation 可以保留多长时间</strong>, @Rentention 包含一个 <strong>RetentionPolicy类型的成员变量,</strong> 使用 @Rentention 时必须为该 value 成员变量指定值:<strong>@Retention 的三种值</strong></li>
</ul>
<ol>
<li><strong>RetentionPolicy.SOURCE</strong>: 编译器使用后，直接丢弃这种策略的注释</li>
<li><strong>RetentionPolicy.CLASS</strong>: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解。 这是默认值</li>
<li><strong>RetentionPolicy.RUNTIME</strong>:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以通过反射获取该注解</li>
</ol>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220101222753151.png" alt="image-20220101222753151"></p>
<h5 id="22-3-4-2-Target"><a href="#22-3-4-2-Target" class="headerlink" title="22.3.4.2 @Target"></a>22.3.4.2 @Target</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114034690.png" alt="image-20220102114034690"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114118342.png" alt="image-20220102114118342"></p>
</li>
</ul>
<h5 id="22-3-4-3-Documented"><a href="#22-3-4-3-Documented" class="headerlink" title="22.3.4.3@Documented"></a>22.3.4.3@Documented</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114400602.png" alt="image-20220102114400602"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114410291.png" alt="image-20220102114410291"></p>
</li>
</ul>
<h5 id="22-3-4-4-Inherited"><a href="#22-3-4-4-Inherited" class="headerlink" title="22.3.4.4 @Inherited"></a>22.3.4.4 @Inherited</h5><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102114447001.png" alt="image-20220102114447001"></li>
</ul>
<h2 id="23-异常-Exception"><a href="#23-异常-Exception" class="headerlink" title="23. 异常(Exception)"></a>23. 异常(Exception)</h2><ul>
<li>快捷键：将该代码块-&gt;选中-&gt;快捷键 ctrl + alt + t -&gt; 选中 try-catch。</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102144809463.png" alt="image-20220102144809463"></li>
</ul>
<h3 id="23-1-异常体系图"><a href="#23-1-异常体系图" class="headerlink" title="23.1 异常体系图"></a>23.1 异常体系图</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102144920581.png" alt="image-20220102144920581"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102152857427.png" alt="image-20220102152857427"></p>
</li>
</ul>
<h3 id="23-2-常见的运行时异常"><a href="#23-2-常见的运行时异常" class="headerlink" title="23.2 常见的运行时异常"></a>23.2 常见的运行时异常</h3><h4 id="23-2-1-常见的运行时异常包括"><a href="#23-2-1-常见的运行时异常包括" class="headerlink" title="23.2.1 常见的运行时异常包括"></a>23.2.1 常见的运行时异常包括</h4><ol>
<li><strong>NullPointerException 空指针异常</strong></li>
<li><strong>ArithmeticException 数学运算异常</strong></li>
<li><strong>ArrayIndexOutOfBoundsException 数组下标越界异常</strong></li>
<li><strong>ClassCastException 类型转换异常</strong></li>
<li><strong>NumberFormatException 数字格式不正确异常[]</strong></li>
</ol>
<h3 id="23-3-编译异常"><a href="#23-3-编译异常" class="headerlink" title="23.3 编译异常"></a>23.3 编译异常</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102154542865.png" alt="image-20220102154542865"></li>
</ul>
<h4 id="23-3-1-常见的编译异常"><a href="#23-3-1-常见的编译异常" class="headerlink" title="23.3.1 常见的编译异常"></a>23.3.1 常见的编译异常</h4><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102154604190.png" alt="image-20220102154604190"></p>
<ul>
<li><strong>例如打开一个不存在的文件</strong></li>
</ul>
<h3 id="23-4-异常处理"><a href="#23-4-异常处理" class="headerlink" title="23.4 异常处理"></a>23.4 异常处理</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102155824897.png" alt="image-20220102155824897"></p>
<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102155846580.png" alt="image-20220102155846580"  /></li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102160517251.png" alt="image-20220102160517251"></p>
<ul>
<li><strong>默认是<code>throws</code>，JVM机的处理方式就是输出异常信息然后退出程序</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="23-4-1-try-catch"><a href="#23-4-1-try-catch" class="headerlink" title="23.4.1 try-catch"></a>23.4.1 try-catch</h4><ul>
<li><strong>将异常封装成Exception对象，<code>.getMessage()</code>方法的作用是返回异常信息</strong>。</li>
</ul>
<ul>
<li><p><strong>finally表示无论是否发生异常，都执行的语句，可有可无</strong>。</p>
<ul>
<li><p><strong>此时如果在finally前面的catch有return语句也不会结束程序，因为finally必须执行，最后返回的值取决于finally中的return</strong>。</p>
<ul>
<li><p>**<u>但是只是说前面catch里面的return语句不会返回一个值，里面的表达式之类的还是会执行</u>**，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    i /= i;</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++i;		<span class="comment">//最后返回2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**<u>注意try/catch/finally都是不同的作用域，即try里面初始化i后，catch和finally里无法访问；catch和finally也一样</u>**。</li>
</ul>
</li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102164006487.png" alt="image-20220102164006487" style="zoom: 80%;" />

<ul>
<li>**<u>执行到catch里的return时不会马上return，底层会先用给一个临时变量temp保存此时i的值，然后执行finally，finally执行完毕发现没有return，然后在回来catch执行，此时返回的是临时变量temp的值，并是不i的值</u>**。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>可以有多个catch，捕获不同的异常，按catch的先后顺序执行，因此在使用的时候必须是子类异常在前，父类异常在后，不然直接都被父类异常捕获，后面的子类捕获无意义</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span> ()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102162046341.png" alt="image-20220102162046341"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102164413213.png" alt="image-20220102164413213"></p>
</li>
</ul>
<h4 id="23-4-2-throws"><a href="#23-4-2-throws" class="headerlink" title="23.4.2 throws"></a>23.4.2 throws</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102170505782.png" alt="image-20220102170505782"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d://ff.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**意思是f1()方法中的  <code>FileNotFoundException</code> 异常将由这个方法的调用者处理，它可以继续抛给上面或者<code>try-catch</code>**。</li>
<li><strong>也可以是<code>throws Exception</code>,因为<code>Exception</code>是<code>FileNotFoundException</code>的父类</strong></li>
<li><strong>可以抛出异常列表 <code>throws FileNotFoundException,NullPointExcepiton</code><strong>，</strong>如果嫌抛出异常太多很烦，直接抛出<code>Exception</code>也行</strong>。</li>
</ul>
<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102170648800.png" alt="image-20220102170648800"><ul>
<li><strong>注意第三点</strong>。</li>
</ul>
</li>
</ul>
<h5 id="23-4-2-1-小tips"><a href="#23-4-2-1-小tips" class="headerlink" title="23.4.2.1 小tips"></a>23.4.2.1 小tips</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里大家思考问题 调用 f3() 报错</span></span><br><span class="line">    <span class="comment">//1. 因为 f3() 方法抛出的FileNotFoundException是一个编译异常</span></span><br><span class="line">    <span class="comment">//2. 即这时，就要 f1() 必须处理这个编译异常</span></span><br><span class="line">    <span class="comment">//3. 在 f1() 中，要么 try-catch-finally ,或者继续 throws 这个编译异常</span></span><br><span class="line">    f3(); <span class="comment">// 抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d://aa.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 在 f4()中调用方法 f5() 是 OK</span></span><br><span class="line">    <span class="comment">//2. 原因是 f5() 抛出的 ArithmeticException 是运行异常</span></span><br><span class="line">    <span class="comment">//3. 而 java 中，并不要求程序员显示处理,因为有默认处理机制</span></span><br><span class="line">    f5();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><u>注意</u><strong>：</strong>即使f5()没有异常但是也可throws硬抛，f4()调用它的时候还是得处理</strong>。</li>
</ul>
<h4 id="23-4-3-自定义异常"><a href="#23-4-3-自定义异常" class="headerlink" title="23.4.3 自定义异常"></a>23.4.3 自定义异常</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102172129733.png" alt="image-20220102172129733"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102172139168.png" alt="image-20220102172139168"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="comment">/*throws AgeException*/</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">180</span>;</span><br><span class="line">        <span class="comment">//要求范围在 18 – 120 之间，否则抛出一个自定义异常</span></span><br><span class="line">        <span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AgeException(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄范围正确.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义一个异常</span></span><br><span class="line"><span class="comment">//1. 一般情况下，我们自定义异常是继承 RuntimeException</span></span><br><span class="line"><span class="comment">//2. 即把自定义异常做成 运行时异常，好处是，我们可以使用默认的处理机制</span></span><br><span class="line"><span class="comment">//3. 即比较方便</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    publicAgeException(String message) &#123;<span class="comment">//构造器</span></span><br><span class="line">        <span class="keyword">super</span>(message);<span class="comment">//这个message就是最后打印出的异常提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>这里使用<code>throw</code>抛出异常</strong>，<strong>对于已有的固定异常也可</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;数组越界&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="23-4-3-1-throws和throw的区别"><a href="#23-4-3-1-throws和throw的区别" class="headerlink" title="23.4.3.1 throws和throw的区别"></a>23.4.3.1 throws和throw的区别</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102185506856.png" alt="image-20220102185506856"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102185512682.png" alt="image-20220102185512682"></p>
</li>
</ul>
<h2 id="24-常用类"><a href="#24-常用类" class="headerlink" title="24. 常用类"></a>24. 常用类</h2><h3 id="24-1-包装类Wrapper"><a href="#24-1-包装类Wrapper" class="headerlink" title="24.1 包装类Wrapper"></a>24.1 包装类Wrapper</h3><ol>
<li><strong>针对八种基本数据类型相应的引用类型—包装类</strong>。</li>
<li><strong>有了类的特点，就可以调用类中的方法</strong>。</li>
</ol>
<ul>
<li><p><img src="C:/Users/%E5%90%B4%E5%AE%87/AppData/Roaming/Typora/typora-user-images/image-20220102200349175.png" alt="image-20220102200349175"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102200519291.png" alt="image-20220102200519291"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102200525182.png" alt="image-20220102200525182"></p>
</li>
</ul>
<h4 id="24-1-1-包装类和基本数据的转换"><a href="#24-1-1-包装类和基本数据的转换" class="headerlink" title="24.1.1 包装类和基本数据的转换"></a>24.1.1 包装类和基本数据的转换</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102200812679.png" alt="image-20220102200812679"></p>
<ul>
<li><p><strong>JDK5以前只能手动：</strong></p>
<ul>
<li><strong>手动装箱</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = <span class="number">100</span>;</span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(n1);</span><br><span class="line">Integer integer1 = Integer.valueOf(n1);<span class="comment">//这个方法里面也是要new的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer.valueof的源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<span class="comment">//[-128,127]</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);<span class="comment">//如果不在上述范围内就new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>手动拆箱</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = integer.intValue();</span><br><span class="line">int j = integer1.intValue();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>JDK5以后</strong>：</p>
<ul>
<li><p><strong>自动装箱/自动拆箱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n2 = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//自动装箱 int-&gt;Integer</span></span><br><span class="line">Integer integer2 = n2; <span class="comment">//底层使用的是 Integer.valueOf(n2)</span></span><br><span class="line"><span class="comment">//自动拆箱 Integer-&gt;int</span></span><br><span class="line"><span class="keyword">int</span> n3 = integer2; <span class="comment">//底层仍然使用的是 intValue()方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102202023034.png" alt="image-20220102202023034"></p>
<ul>
<li><strong>输出的是1.0，三元运算符要看做一个整体，这里面精度最高的是Double，因此Integer转换成了Double</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="24-1-2-包装类和String类型转换"><a href="#24-1-2-包装类和String类型转换" class="headerlink" title="24.1.2 包装类和String类型转换"></a>24.1.2 包装类和String类型转换</h4><ul>
<li><p>```java<br>Integer i = 100;//自动装箱<br>//Integer -&gt; String<br>//方式 1<br>String str1 = i + “”;<br>//方式 2<br>String str2 = i.toString();//Integer的toString()返回一个String类型的对应数字<br>//方式 3<br>String str3 = String.valueOf(i);</p>
<p>//String -&gt; 包装类(Integer)<br>String str4 = “12345”;<br>Integer i2 = Integer.parseInt(str4);//使用到自动装箱<br>Integer i3 = new Integer(str4);//构造器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **常用方法**：</span><br><span class="line"></span><br><span class="line">  + ![image-20220102203502477](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102203502477.png)</span><br><span class="line">    + **MAX_VALUE和MIN_VALUE各个基本数据类型的包装类都有**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **经典问题**：</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    //1. 如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回 (这里有个缓存数组，事先创建好了)</span><br><span class="line">    //2. 如果不在 -128~127,就直接 new Integer(i)</span><br><span class="line">    </span><br><span class="line">    Integer m = 1; //底层 Integer.valueOf(1);</span><br><span class="line">    Integer n = 1;//底层 Integer.valueOf(1);</span><br><span class="line">    System.out.println(m == n); //True</span><br><span class="line">    //所以，这里主要是看范围 -128 ~ 127 就是直接返回</span><br><span class="line">    //，否则，就 new Integer(xx);</span><br><span class="line">    </span><br><span class="line">    Integer x = 128;//底层 Integer.valueOf(128);</span><br><span class="line">    Integer y = 128;//底层 Integer.valueOf(128);</span><br><span class="line">    System.out.println(x == y);//False</span><br></pre></td></tr></table></figure>

<ul>
<li>```java<br>Integer i11=127;<br>int i12=127;<br>//只要有基本数据类型，判断的是值是否相同<br>System.out.println(i11 == i12); //True<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 24.2 String类</span><br><span class="line"></span><br><span class="line">+ ![image-20220102205748422](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102205748422.png)</span><br><span class="line">  + **常用的构造器还有:`String s5 = new String(byte[] b)`**。</span><br><span class="line"></span><br><span class="line">+ ![image-20220102205759383](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102205759383.png)</span><br><span class="line"></span><br><span class="line">  + **String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】**。</span><br><span class="line"></span><br><span class="line">  + **接口 Comparable [String 对象可以比较大小]**。</span><br><span class="line"></span><br><span class="line">  + **String 是 final 类，不能被其他的类继承**。</span><br><span class="line"></span><br><span class="line">  + **&lt;u&gt;String 有属性 private final char value[]; 用于存放字符串内容，也就是说它在底层仍然是一个char数组&lt;/u&gt;**。</span><br><span class="line"></span><br><span class="line">    + **一定要注意：value 是一个 final 类型， 不可以修改：即 value 不能指向新的地址，但是单个字符内容是可以变化**。</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      private final char value[];//源码中的定义</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>.intern</code>方法返回的是常量池中的字符串地址</strong>： <img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103093841127.png" alt="image-20220103093841127"></p>
</li>
</ul>
<h4 id="24-2-1-String类的创建方式"><a href="#24-2-1-String类的创建方式" class="headerlink" title="24.2.1 String类的创建方式"></a>24.2.1 String类的创建方式</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211112611.png" alt="image-20220102211112611" style="zoom: 80%;" /></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211256998.png" alt="image-20220102211256998" style="zoom:80%;" />
+ <img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211745526.png" alt="image-20220102211745526" style="zoom:80%;" />
  + **虽然指向的是常量池中同一个地址，但是一个存放的是常量池地址，一个存放的是堆空间地址**。</li>
</ul>
<h4 id="24-2-2-题目："><a href="#24-2-2-题目：" class="headerlink" title="24.2.2 题目："></a>24.2.2 题目：</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102211950716.png" alt="image-20220102211950716" style="zoom: 80%;" /></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102212556359.png" alt="image-20220102212556359" style="zoom: 67%;" /></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220102213318272.png" alt="image-20220102213318272" style="zoom:67%;" /></li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103092438800.png" alt="image-20220103092438800"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103092635917.png" alt="image-20220103092635917"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103093338669.png" alt="image-20220103093338669"></p>
<ul>
<li><strong><code>String c = a + b</code>底层new了SrtingBuilder然后用append()方法添加a和b，最后通过这个创建的StringBuilder对象的toString()方法返回给c</strong>。<strong>StringBuiler的toString()方法是这样的返回字符串的：<code>return new String(value, 0, count);</code>，也就是通过new一个String对象返回，因此返回的地址是堆中的地址</strong>。</li>
</ul>
</li>
<li><blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103095112120.png" alt="image-20220103095112120"></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103095118917.png" alt="image-20220103095118917"></p>
</blockquote>
</li>
</ul>
<h4 id="24-2-3-String类的常见方法"><a href="#24-2-3-String类的常见方法" class="headerlink" title="24.2.3 String类的常见方法"></a>24.2.3 String类的常见方法</h4><ul>
<li><strong>不用背，用久了就好了</strong>。</li>
</ul>
<blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103095327324.png" alt="image-20220103095327324"></p>
</blockquote>
<ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103212135653.png" alt="image-20220103212135653"></p>
<blockquote>
<p><strong>substring使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abcdefg&quot;</span>.substring(<span class="number">2</span>,<span class="number">5</span>);<span class="comment">//索引从2-5不包括5</span></span><br><span class="line"><span class="string">&quot;abcdefg&quot;</span>.substring(<span class="number">5</span>);<span class="comment">//索引5开始之后的全部</span></span><br></pre></td></tr></table></figure>

<p><strong>indexOf方法可以是一个子串，返回子串首次出现位置</strong>。</p>
</blockquote>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103212903120.png" alt="image-20220103212903120"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMethod02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.toUpperCase 转换成大写</span></span><br><span class="line">        String s = <span class="string">&quot;heLLo&quot;</span>;</span><br><span class="line">        System.out.println(s.toUpperCase());<span class="comment">//HELLO</span></span><br><span class="line">        <span class="comment">// 2.toLowerCase</span></span><br><span class="line">        System.out.println(s.toLowerCase());<span class="comment">//hello</span></span><br><span class="line">        <span class="comment">// 3.concat 拼接字符串</span></span><br><span class="line">        String s1 = <span class="string">&quot;宝玉&quot;</span>;</span><br><span class="line">        s1 = s1.concat(<span class="string">&quot;林黛玉&quot;</span>).concat(<span class="string">&quot;薛宝钗&quot;</span>).concat(<span class="string">&quot;together&quot;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//宝玉林黛玉薛宝钗 together</span></span><br><span class="line">        <span class="comment">// 4.replace 替换字符串中的字符</span></span><br><span class="line">        s1 = <span class="string">&quot;宝玉 and 林黛玉 林黛玉 林黛玉&quot;</span>;</span><br><span class="line">        <span class="comment">//在 s1 中，将 所有的 林黛玉 替换成薛宝钗</span></span><br><span class="line">        <span class="comment">// 老韩解读: s1.replace() 方法执行后，返回的结果才是替换过的.</span></span><br><span class="line">        <span class="comment">// 注意对 s1 没有任何影响</span></span><br><span class="line">        String s11 = s1.replace(<span class="string">&quot;宝玉&quot;</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//宝玉 and 林黛玉 林黛玉 林黛玉</span></span><br><span class="line">        System.out.println(s11);<span class="comment">//jack and 林黛玉 林黛玉 林黛玉</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.split 分割字符串, 对于某些分割字符，我们需要 转义比如 | \\等</span></span><br><span class="line">        String poem = <span class="string">&quot;锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦&quot;</span>;</span><br><span class="line">        <span class="comment">//老韩解读：</span></span><br><span class="line">        <span class="comment">// 1. 以 , 为标准对 poem 进行分割 , 返回一个数组</span></span><br><span class="line">        <span class="comment">// 2. 在对字符串进行分割时，如果有特殊字符，需要加入 转义符 \</span></span><br><span class="line">        String[] split = poem.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        poem = <span class="string">&quot;E:\\aaa\\bbb&quot;</span>;</span><br><span class="line">        split = poem.split(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;==分割后内容===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; split.length; i++) &#123;</span><br><span class="line">            System.out.println(split[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6.toCharArray 转换成字符数组</span></span><br><span class="line">        s = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            System.out.println(chs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 7.compareTo 比较两个字符串的大小，如果前者大，</span></span><br><span class="line">        <span class="comment">// 则返回正数，后者大，则返回负数，如果相等，返回 0</span></span><br><span class="line">        <span class="comment">// 老韩解读</span></span><br><span class="line">        <span class="comment">// (1) 如果长度相同，并且每个字符也相同，就返回 0</span></span><br><span class="line">        <span class="comment">// (2) 如果长度不同或者有字符不同，则比较每个字符大小，返回第一个不同的字符的差值</span></span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">// (3) 如果前面的部分都相同，就返回字符串 str1.len - str2.len</span></span><br><span class="line">        String a = <span class="string">&quot;jcck&quot;</span>;<span class="comment">// len = 4</span></span><br><span class="line">        String b = <span class="string">&quot;jack&quot;</span>;<span class="comment">// len = 4</span></span><br><span class="line">        System.out.println(a.compareTo(b)); <span class="comment">// 返回值是 &#x27;c&#x27; - &#x27;a&#x27; = 2 的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 8.format 格式字符串</span></span><br><span class="line">        <span class="comment">/* 占位符有:</span></span><br><span class="line"><span class="comment">        * %s 字符串 %c 字符 %d 整型 %.2f 浮点型</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        String name = <span class="string">&quot;john&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">double</span> score = <span class="number">56.857</span>;</span><br><span class="line">        <span class="keyword">char</span> gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有的信息都拼接在一个字符串.</span></span><br><span class="line">        String info =</span><br><span class="line">            <span class="string">&quot;我的姓名是&quot;</span> + name + <span class="string">&quot;年龄是&quot;</span> + age + <span class="string">&quot;,成绩是&quot;</span> + score + <span class="string">&quot;性别是&quot;</span> + gender + <span class="string">&quot;。希望大家喜欢我！</span></span><br><span class="line"><span class="string">            &quot;</span>;</span><br><span class="line">            System.out.println(info);</span><br><span class="line">        <span class="comment">//老韩解读</span></span><br><span class="line">        <span class="comment">//1. %s , %d , %.2f %c 称为占位符</span></span><br><span class="line">        <span class="comment">//2. 这些占位符由后面变量来替换</span></span><br><span class="line">        <span class="comment">//3. %s 表示后面由 字符串来替换</span></span><br><span class="line">        <span class="comment">//4. %d 是整数来替换</span></span><br><span class="line">        <span class="comment">//5. %.2f 表示使用小数来替换，替换后，只会保留小数点两位, 并且进行四舍五入的处理</span></span><br><span class="line">        <span class="comment">//6. %c 使用 char 类型来替换</span></span><br><span class="line">        String formatStr = <span class="string">&quot;我的姓名是%s 年龄是%d，成绩是%.2f 性别是%c.希望大家喜欢我！&quot;</span>;</span><br><span class="line">        String info2 = String.format(formatStr, name, age, score, gender);</span><br><span class="line">        System.out.println(<span class="string">&quot;info2=&quot;</span> + info2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：replace是返回一个新的修改过后串，不是对原先指向的位置就地修改字符串。</p>
</blockquote>
</li>
</ul>
<h3 id="24-3-StringBuffer类"><a href="#24-3-StringBuffer类" class="headerlink" title="24.3 StringBuffer类"></a>24.3 StringBuffer类</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103222304693.png" alt="image-20220103222304693"></li>
</ul>
<ol>
<li><strong>StringBuffer 的直接父类 是 AbstractStringBuilder</strong></li>
<li><strong>StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</strong></li>
<li> <strong>在父类中 AbstractStringBuilder 有属性 char[] value,不是 final，该 value 数组存放 字符串内容，因此存放在堆中的</strong></li>
<li> <strong>StringBuffer 是一个 final 类，不能被继承</strong></li>
<li><strong>因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)，不用每次都更换地址(即不是每次创建新对象，<u>只在超出数组范围的时候才创建新对象</u>)， 所以效率高于 String</strong></li>
</ol>
<ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103224726268.png" alt="image-20220103224726268"></p>
<blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220103224800723.png" alt="image-20220103224800723"></p>
<p><strong>默认构造器的不带字符的字符串缓冲区指的是这个从父类继承的value[]，初始16</strong>。</p>
<p><strong>第三个构造器可以指定这个字符串数组的大小</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();<span class="comment">//默认16</span></span><br><span class="line">StringBuffer stringBuffer1 = <span class="keyword">new</span> StringBuffer(<span class="number">100</span>);<span class="comment">//指定100</span></span><br><span class="line">StringBuffer stringBuffer2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello&quot;</span>);<span class="comment">//第四个构造器</span></span><br><span class="line">    <span class="comment">/*public StringBuffer(String str) &#123;</span></span><br><span class="line"><span class="comment">            super(str.length() + 16); 因此此时长度是21</span></span><br><span class="line"><span class="comment">            append(str);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        第四个构造器里面的底层操作创建一个长度是默认16加上当前传入的长度的字符数组*/</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h4 id="24-3-1-String-和-StringBuffer-相互转换"><a href="#24-3-1-String-和-StringBuffer-相互转换" class="headerlink" title="24.3.1  String 和 StringBuffer 相互转换"></a>24.3.1  String 和 StringBuffer 相互转换</h4><ul>
<li>```java<br>//看 String——&gt;StringBuffer<br>String str = “hello tom”;<br>//方式 1 使用构造器<br>//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响<br>StringBuffer stringBuffer = new StringBuffer(str);<br>//方式 2 使用的是 append 方法<br>StringBuffer stringBuffer1 = new StringBuffer();<br>stringBuffer1 = stringBuffer1.append(str);//看看 StringBuffer -&gt;String<br>StringBuffer stringBuffer3 = new StringBuffer(“韩顺平教育”);<br>//方式 1 使用 StringBuffer 提供的 toString 方法<br>String s = stringBuffer3.toString();<br>//方式 2: 使用构造器来搞定<br>String s1 = new String(stringBuffer3);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 24.3.2  StringBuffer 类常见方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//增</span><br><span class="line">s.append(&#x27;,&#x27;);// &quot;hello,&quot;</span><br><span class="line">s.append(&quot;张三丰&quot;);//&quot;hello,张三丰&quot;</span><br><span class="line">s.append(&quot;赵敏&quot;).append(100).append(true).append(10.5);//&quot;hello,张三丰赵敏 100true10.5&quot;</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰赵敏 100true10.5&quot;</span><br><span class="line"></span><br><span class="line">//删</span><br><span class="line">/*</span><br><span class="line">    * 删除索引为&gt;=start &amp;&amp; &lt;end 处的字符</span><br><span class="line">    * 解读: 删除 11~14 的字符 [11, 14)</span><br><span class="line">    */</span><br><span class="line">s.delete(11, 14);</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰赵敏 true10.5&quot;</span><br><span class="line"></span><br><span class="line">//改</span><br><span class="line">//老韩解读，使用 周芷若 替换 索引 9-11 的字符 [9,11)</span><br><span class="line">s.replace(9, 11, &quot;周芷若&quot;);</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰周芷若 true10.5&quot;</span><br><span class="line">//查找指定的子串在字符串第一次出现的索引，如果找不到返回-1</span><br><span class="line">int indexOf = s.indexOf(&quot;张三丰&quot;);</span><br><span class="line">System.out.println(indexOf);//6</span><br><span class="line"></span><br><span class="line">//插</span><br><span class="line">//老韩解读，在索引为 9 的位置插入 &quot;赵敏&quot;,原来索引为 9 的内容自动后移</span><br><span class="line">s.insert(9, &quot;赵敏&quot;);</span><br><span class="line">System.out.println(s);//&quot;hello,张三丰赵敏周芷若 true10.5&quot;</span><br><span class="line"></span><br><span class="line">//长度</span><br><span class="line">System.out.println(s.length());//22</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="24-3-2-1-测试方法"><a href="#24-3-2-1-测试方法" class="headerlink" title="24.3.2.1 测试方法"></a>24.3.2.1 测试方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">null</span>;<span class="comment">// ok</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(); <span class="comment">//ok</span></span><br><span class="line">sb.append(str);<span class="comment">//需要看源码, 如果str是空，底层调用的是 AbstractStringBuilder 的 appendNull(往value数组里一次加入n u l l 四个字符)</span></span><br><span class="line">System.out.println(sb);<span class="comment">//输出&quot;null&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的构造器，会抛出 NullpointerException</span></span><br><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(str);<span class="comment">//看底层源码 super(str.length() + 16);</span></span><br></pre></td></tr></table></figure>



<h3 id="24-4-StringBuilder-类"><a href="#24-4-StringBuilder-类" class="headerlink" title="24.4  StringBuilder 类"></a>24.4  StringBuilder 类</h3><blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104131911414.png" alt="image-20220104131911414"></p>
</blockquote>
<ul>
<li><strong>一般用在单线程</strong>。</li>
</ul>
<h4 id="24-4-1-继承关系图"><a href="#24-4-1-继承关系图" class="headerlink" title="24.4.1 继承关系图"></a>24.4.1 继承关系图</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104132210285.png" alt="image-20220104132210285"></p>
<blockquote>
<p><strong>和StringBuffer一模一样</strong>。</p>
<ol>
<li>StringBuilder <strong>继承 AbstractStringBuilder 类</strong></li>
<li> <strong>实现了 Serializable ,说明 StringBuilder 对象是可以串行化(对象可以网络传输,可以保存到文件)</strong></li>
<li>StringBuilder 是 <strong>final 类, 不能被继承</strong></li>
<li>StringBuilder <strong>对象字符序列仍然是存放在其父类 AbstractStringBuilder 的 char[] value</strong>;因此，字<strong>符序列是堆中</strong></li>
<li>StringBuilder 的方法，<strong>没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用</strong></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="24-5-String、StringBuffer-和-StringBuilder-的比较"><a href="#24-5-String、StringBuffer-和-StringBuilder-的比较" class="headerlink" title="24.5 String、StringBuffer 和 StringBuilder 的比较"></a>24.5 String、StringBuffer 和 StringBuilder 的比较</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104133030046.png" alt="image-20220104133030046"></li>
<li><strong>如何选择</strong>：<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104133256295.png" alt="image-20220104133256295"></li>
</ul>
</li>
</ul>
<h3 id="24-6-Math类"><a href="#24-6-Math类" class="headerlink" title="24.6 Math类"></a>24.6 Math类</h3><ul>
<li><strong>包含了一系列静态方法</strong>。</li>
</ul>
<h4 id="24-6-1-常用方法"><a href="#24-6-1-常用方法" class="headerlink" title="24.6.1 常用方法"></a>24.6.1 常用方法</h4><ol>
<li><strong>abs 绝对值</strong></li>
<li><strong>pow 求幂</strong></li>
<li><strong>ceil 向上取整,返回&gt;=该参数的最小整数(转成 double);</strong></li>
<li><strong>floor 向下取整，返回&lt;=该参数的最大整数(转成 double)</strong></li>
<li><strong>round 四舍五入 Math.floor(该参数+0.5)</strong></li>
<li><strong>sqrt 求开方</strong></li>
<li><strong>random 求随机数</strong><ul>
<li><strong>random 返回的是 0 &lt;= x &lt; 1 之间的一个随机小数</strong></li>
</ul>
</li>
<li><strong>max , min 返回最大值和最小值</strong></li>
</ol>
<h3 id="24-7-Arrays类"><a href="#24-7-Arrays类" class="headerlink" title="24.7 Arrays类"></a>24.7 Arrays类</h3><ul>
<li><strong>包含一系列静态方法</strong>。</li>
</ul>
<h4 id="24-7-1-常用方法"><a href="#24-7-1-常用方法" class="headerlink" title="24.7.1 常用方法"></a>24.7.1 常用方法</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104142407252.png" alt="image-20220104142407252"></p>
<ul>
<li>```java<br>//1. 可以直接使用冒泡排序 , 也可以直接使用 Arrays 提供的 sort 方法排序<br>//2. 因为数组是引用类型，所以通过 sort 排序后，会直接影响到 实参 arr<br>//3. sort 重载的，也可以通过传入一个接口 Comparator 实现定制排序<br>//4. 调用 定制排序 时，传入两个参数 (1) 排序的数组 arr<br>// (2) 实现了 Comparator 接口的匿名内部类 , 要求实现 compare 方法<br>//5. 先演示效果，再解释<br>//6. 这里体现了接口编程的方式 , 看看源码，就明白<br>// 源码分析<br>//(1)Arrays.sort(arr, new Comparator()<br>//(2) 最终到 TimSort 类的 private static <T> void binarySort(T[] a, int lo, int hi, int start,Comparator&lt;? super T&gt; c)()<br>//(3) 执行到 binarySort 方法的代码, 会根据动态绑定机制 c.compare()执行我们传入的<br>// 匿名内部类的 compare ()<br>while (left &lt; right) {<pre><code>int mid = (left + right) &gt;&gt;&gt; 1;
if (c.compare(pivot, a[mid]) &lt; 0)//这里调用了我们重写的compare方法比较大小，从而决定顺序
    right = mid;
else
    left = mid + 1;
</code></pre>
}<br>(4)    new Comparator() {<pre><code>         @Override
         public int compare(Object o1, Object o2) &#123;
         Integer i1 = (Integer) o1;
         Integer i2 = (Integer) o2;
         return i2 - i1;
         &#125;
    &#125;
</code></pre>
//(5) public int compare(Object o1, Object o2) 返回的值&gt;0 还是 &lt;0<br>// 会影响整个排序结果, 这就充分体现了 接口编程+动态绑定+匿名内部类的综合使用<br>// 将来的底层框架和源码的使用方式，会非常常见<br>//定制排序<br>Arrays.sort(arr, new Comparator() {<pre><code>@Override
public int compare(Object o1, Object o2) &#123;
    Integer i1 = (Integer) o1;
    Integer i2 = (Integer) o2;
    return i2 - i1;
&#125;
</code></pre>
});<br>//结合冒泡 + 定制<br>int[] arr = {1, -1, 8, 0, 20};<br>public static void bubble02(int[] arr, Comparator c) {<pre><code>int temp = 0;
for (int i = 0; i &lt; arr.length - 1; i++) &#123;
    for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;
        //数组排序由 c.compare(arr[j], arr[j + 1])返回的值决定
        if (c.compare(arr[j], arr[j + 1]) &gt; 0) &#123;
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        &#125;
    &#125;
&#125;
</code></pre>
}<br>bubble02(arr, new Comparator() {<pre><code>@Override
public int compare(Object o1, Object o2) &#123;
    int i1 = (Integer) o1;
    int i2 = (Integer) o2;
    return i2 - i1;// return i2 - i1;
&#125;
</code></pre>
});<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **binarySearch查找的时候如果不存在就返回(应该在的位置+1然后取负数)（使用的前提是 数组有序）**。</span><br><span class="line"></span><br><span class="line">+ ![image-20220104143126802](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104143126802.png)</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    //copyOf方法第一个参数是被复制的数组arr，第二个参数是newLength，即返回一个newLength长度的新数组，这个新数组是从arr中复制newlength个数组，如果这个长度大于了arr.length，多出的长度是数组的默认值。</span><br><span class="line">    //因为数组是有默认值的，int类型的数组就为0，double为0.0，Object为null。如果arr是空数组，就全都是0/0.0/null等默认值，具体看类型。</span><br><span class="line">    //因此，可以用Arrays.copyOf()方法对数组扩容！！！</span><br><span class="line">    Object[] a = &#123;&#125;;</span><br><span class="line">    System.out.println(a.length);		//0</span><br><span class="line">    Object[] b = Arrays.copyOf(a,10);</span><br><span class="line">    System.out.println(b.length);		//10</span><br><span class="line">    System.out.println(Arrays.toString(b));//[null,null,null,null,null,null,null,null,null,null]</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    asList 将一组值，转换成 list</span><br><span class="line">    1. asList 方法，会将 (2,3,4,5,6,1)数据转成一个 List 集合</span><br><span class="line">    2. 返回的 asList 编译类型 List(接口)</span><br><span class="line">    3. asList 运行类型 java.util.Arrays$ArrayList, 是 Arrays 类的</span><br><span class="line">    静态内部类 private static class ArrayList&lt;E&gt; extendsAbstractList&lt;E&gt;</span><br><span class="line">    implements RandomAccess, java.io.Serializable</span><br><span class="line">    */</span><br><span class="line">    List asList =Arrays.asList(2,3,4,5,6,1);</span><br><span class="line">    System.out.println(&quot;asList=&quot; + asList);</span><br><span class="line">    System.out.println(&quot;asList 的运行类型&quot; + asList.getClass());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="24-8-System类"><a href="#24-8-System类" class="headerlink" title="24.8 System类"></a>24.8 System类</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104153603185.png" alt="image-20220104153603185"></p>
<ul>
<li>```java<br>//关于arraycopy的五个参数的意义<br>public static native void arraycopy(Object src,  int  srcPos,<pre><code>                                Object dest, int destPos,
                                int length);
</code></pre>
// 源数组<br>// * @param src the source array.// srcPos： 从源数组的哪个索引位置开始拷贝<br>// * @param srcPos starting position in the source array<br>.<br>// dest : 目标数组，即把源数组的数据拷贝到哪个数组<br>// * @param dest the destination array.// destPos: 把源数组的数据拷贝到 目标数组的哪个索引<br>// * @param destPos starting position in the destination data.// length: 从源数组拷贝多少个数据到目标数组<br>// * @param length the number of array elements to be copied.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 24.9 BigInteger 和 BigDecimal 类</span><br><span class="line"></span><br><span class="line">+ ![image-20220104162426848](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104162426848.png)</span><br><span class="line"></span><br><span class="line">![image-20220104162450276](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104162450475.png)</span><br><span class="line"></span><br><span class="line">+ **不能直接加减乘除，要用固定的方法**</span><br><span class="line"></span><br><span class="line">+ **BigDecimal在进行除法运算的时候可能出现除不尽的情况，此时需要指定精度，否则会异常**。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  bigDecimal = new BigDecimal(&quot;1564556.1212&quot;);</span><br><span class="line">  bigDecimal2 = new BigDecimal(&quot;1564556.1212&quot;);</span><br><span class="line">  bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING)//会保留 分子 的精度,这里分子是四位，即保留四位，输出 1.0000</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="24-10-日期类"><a href="#24-10-日期类" class="headerlink" title="24.10 日期类"></a>24.10 日期类</h3><h4 id="24-10-1-第一代日期类"><a href="#24-10-1-第一代日期类" class="headerlink" title="24.10.1 第一代日期类"></a>24.10.1 第一代日期类</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104165321379.png" alt="image-20220104165321379"  />

<ul>
<li><p>在使用SimpleDateFormat的时候有固定格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取当前系统时间</span></span><br><span class="line"><span class="comment">//2. 这里的 Date 类是在 java.util 包,sql包也有一个Date类，不要引错包了</span></span><br><span class="line"><span class="comment">//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换</span></span><br><span class="line">Date d1 = <span class="keyword">new</span> Date(); <span class="comment">//获取当前系统时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + d1);</span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">9234567</span>); <span class="comment">//通过指定毫秒数得到时间</span></span><br><span class="line">System.out.println(<span class="string">&quot;d2=&quot;</span> + d2); <span class="comment">//获取某个时间对应的毫秒数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式</span></span><br><span class="line"><span class="comment">//2. 这里的格式使用的字母是规定好，不能乱写</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>);</span><br><span class="line">String format = sdf.format(d1); <span class="comment">// format:将日期转换成指定格式的字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;当前日期=&quot;</span> + format);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 可以把一个格式化的 String 转成对应的 Date</span></span><br><span class="line"><span class="comment">//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</span></span><br><span class="line"><span class="comment">//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</span></span><br><span class="line">String s = <span class="string">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class="line">Date parse = sdf.parse(s);</span><br><span class="line">System.out.println(<span class="string">&quot;parse=&quot;</span> + sdf.format(parse));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="24-10-1-1-时间戳"><a href="#24-10-1-1-时间戳" class="headerlink" title="24.10.1.1 时间戳"></a>24.10.1.1 时间戳</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220108102129267.png" alt="image-20220108102129267"></p>
</li>
<li><p>```java<br>public class Instant_ {</p>
<pre><code>public static void main(String[] args) &#123;
    //1.通过 静态方法 now() 获取表示当前时间戳的对象
    Instant now = Instant.now();
    System.out.println(now);
    //2. 通过 from 可以把 Instant 转成 Date
    Date date = Date.from(now);
    //3. 通过 date 的 toInstant() 可以把 date 转成 Instant 对象
    Instant instant = date.toInstant();
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 24.10.2 第二代日期类</span><br><span class="line"></span><br><span class="line">+ ![image-20220104170952981](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104170952981.png)</span><br><span class="line">+ **用getInstance() 来获取实例**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Calendar_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1. Calendar 是一个抽象类， 并且构造器是 private</span><br><span class="line">        //2. 可以通过 getInstance() 来获取实例</span><br><span class="line">        //3. 提供大量的方法和字段提供给程序员</span><br><span class="line">        //4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</span><br><span class="line">        //5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=&gt; Calendar.HOUR_OF_DAY</span><br><span class="line">        Calendar c = Calendar.getInstance(); //创建日历类对象//比较简单，自由</span><br><span class="line">        System.out.println(&quot;c=&quot; + c);</span><br><span class="line">        //2.获取日历对象的某个日历字段</span><br><span class="line">        System.out.println(&quot;年：&quot; + c.get(Calendar.YEAR));</span><br><span class="line">        // 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span><br><span class="line">        System.out.println(&quot;月：&quot; + (c.get(Calendar.MONTH) + 1));</span><br><span class="line">        System.out.println(&quot;日：&quot; + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(&quot;小时：&quot; + c.get(Calendar.HOUR));</span><br><span class="line">        System.out.println(&quot;分钟：&quot; + c.get(Calendar.MINUTE));</span><br><span class="line">        System.out.println(&quot;秒：&quot; + c.get(Calendar.SECOND));</span><br><span class="line">        //Calender 没有专门的格式化方法，所以需要程序员自己来组合显示</span><br><span class="line">        System.out.println(c.get(Calendar.YEAR) + &quot;-&quot; + (c.get(Calendar.MONTH) + 1) + &quot;-&quot; + c.get(Calendar.DAY_OF_MONTH) + &quot; &quot; + c.get(Calendar.HOUR_OF_DAY) + &quot;:&quot; + c.get(Calendar.MINUTE) + &quot;:&quot; + c.get(Calendar.SECOND) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="24-10-3-第三代日期类"><a href="#24-10-3-第三代日期类" class="headerlink" title="24.10.3 第三代日期类"></a>24.10.3 第三代日期类</h4><ul>
<li><p><strong>在开发中尽量使用第三代日期</strong>。</p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104172114749.png" alt="image-20220104172114749"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220104172126309.png" alt="image-20220104172126309"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220108101336971.png" alt="image-20220108101336971"></p>
</li>
<li><p><strong>JDK8引入，需要在JDK8API文档中才能查到</strong>。</p>
</li>
<li><p><strong>可以在IDEA中查看具体方法，用LocalDateTime.now()方法返回一个对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDate_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第三代日期</span></span><br><span class="line">        <span class="comment">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class="line">        LocalDateTime ldt = LocalDateTime.now(); <span class="comment">//LocalDate.now();//LocalTime.now()</span></span><br><span class="line">        System.out.println(ldt);</span><br><span class="line">        <span class="comment">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class="line">        <span class="comment">// 创建 DateTimeFormatter 对象</span></span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String format = dateTimeFormatter.format(ldt);</span><br><span class="line">        System.out.println(<span class="string">&quot;格式化的日期=&quot;</span> + format);</span><br><span class="line">        System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class="line">        System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonth());<span class="comment">//英文表示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonthValue());<span class="comment">//数字表示</span></span><br><span class="line">        System.out.println(<span class="string">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class="line">        System.out.println(<span class="string">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class="line">        System.out.println(<span class="string">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class="line">        System.out.println(<span class="string">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class="line">        LocalDate now = LocalDate.now(); <span class="comment">//可以获取年月日</span></span><br><span class="line">        LocalTime now2 = LocalTime.now();<span class="comment">//获取到时分秒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="24-10-3-1-第三代日期类其他方法"><a href="#24-10-3-1-第三代日期类其他方法" class="headerlink" title="24.10.3.1 第三代日期类其他方法"></a>24.10.3.1 第三代日期类其他方法</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220108102310753.png" alt="image-20220108102310753"></p>
<ul>
<li><p><strong>用到哪个方法就去查</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line"><span class="comment">//提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class="line"><span class="comment">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class="line">LocalDateTime localDateTime = ldt.plusDays(<span class="number">890</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(localDateTime));</span><br><span class="line"><span class="comment">//看看在 3456 分钟前是什么时候，把 年月日-时分秒输出</span></span><br><span class="line">LocalDateTime localDateTime2 = ldt.minusMinutes(<span class="number">3456</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="25-集合"><a href="#25-集合" class="headerlink" title="25 集合"></a>25 集合</h2><blockquote>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109182224949.png" alt="image-20220109182224949"></p>
</blockquote>
<h3 id="25-1-集合框架体系"><a href="#25-1-集合框架体系" class="headerlink" title="25.1 集合框架体系"></a>25.1 集合框架体系</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109183518910.png" alt="image-20220109183518910"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109183525252.png" alt="image-20220109183525252"></p>
<ol>
<li><strong>集合主要是两组(单列集合 , 双列集合)</strong></li>
<li> <strong>Collection 接口有两个重要的子接口 List Set , 他们的实现子类都是单列集合</strong></li>
<li> <strong>Map 接口的实现子类 是双列集合，存放的 K-V</strong></li>
</ol>
</li>
</ul>
<h3 id="25-2-Colection接口"><a href="#25-2-Colection接口" class="headerlink" title="25.2 Colection接口"></a>25.2 Colection接口</h3><h4 id="25-2-1-Collection接口实现类的特点"><a href="#25-2-1-Collection接口实现类的特点" class="headerlink" title="25.2.1 Collection接口实现类的特点"></a>25.2.1 Collection接口实现类的特点</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109184158045.png" alt="image-20220109184158045"></p>
</li>
<li><p><strong>以ArrayList为例</strong></p>
<ul>
<li><strong>用add添加元素的时候添加的是Object，添加int会自动装箱成Integer</strong></li>
<li><strong>删除的时候可以指定名字或者索引，指定名字的时候返回一个布尔值表示删除是否成功，指定索引的时候返回一个Object表示被删除的对象</strong>。<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109184927445.png" alt="image-20220109184927445"></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add:添加单个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        list.add(<span class="number">10</span>);<span class="comment">//list.add(new Integer(10))</span></span><br><span class="line">        list.add(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remove:删除指定元素</span></span><br><span class="line">        <span class="comment">//list.remove(0);//删除第一个元素</span></span><br><span class="line">        list.remove(<span class="keyword">true</span>);<span class="comment">//指定删除某个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// contains:查找元素是否存在</span></span><br><span class="line">        System.out.println(list.contains(<span class="string">&quot;jack&quot;</span>));<span class="comment">//T</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// size:获取元素个数</span></span><br><span class="line">        System.out.println(list.size());<span class="comment">//2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// isEmpty:判断是否为空</span></span><br><span class="line">        System.out.println(list.isEmpty());<span class="comment">//F</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// clear:清空</span></span><br><span class="line">        list.clear();</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// addAll:添加多个元素</span></span><br><span class="line">        ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list2.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">        list2.add(<span class="string">&quot;三国演义&quot;</span>);</span><br><span class="line">        list.addAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// containsAll:查找多个元素是否都存在</span></span><br><span class="line">        System.out.println(list.containsAll(list2));<span class="comment">//T</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// removeAll：删除多个元素</span></span><br><span class="line">        list.add(<span class="string">&quot;聊斋&quot;</span>);</span><br><span class="line">        list.removeAll(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;list=&quot;</span> + list);<span class="comment">//[聊斋]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="25-2-2-Collection-接口遍历元素方式"><a href="#25-2-2-Collection-接口遍历元素方式" class="headerlink" title="25.2.2  Collection 接口遍历元素方式"></a>25.2.2  Collection 接口遍历元素方式</h4><h5 id="25-2-2-1-使用-Iterator-迭代器"><a href="#25-2-2-1-使用-Iterator-迭代器" class="headerlink" title="25.2.2.1 使用 Iterator(迭代器)"></a>25.2.2.1 使用 Iterator(迭代器)</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109192403303.png" alt="image-20220109192403303"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109192409874.png" alt="image-20220109192409874"></p>
<ul>
<li><strong>next()有两个作用</strong>：<strong>1.下移 2.返回下移位置上的集合元素</strong>。</li>
</ul>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220109192544481.png" alt="image-20220109192544481"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection col = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        col.add(<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>, <span class="string">&quot;罗贯中&quot;</span>, <span class="number">10.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> Book(<span class="string">&quot;小李飞刀&quot;</span>, <span class="string">&quot;古龙&quot;</span>, <span class="number">5.1</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> Book(<span class="string">&quot;红楼梦&quot;</span>, <span class="string">&quot;曹雪芹&quot;</span>, <span class="number">34.6</span>));</span><br><span class="line">        <span class="comment">//1. 先得到 col 对应的 迭代器</span></span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        <span class="comment">//2. 使用 while 循环遍历</span></span><br><span class="line">        <span class="comment">//快捷键快速生成 while =&gt; itit</span></span><br><span class="line">        <span class="comment">//显示所有的快捷键的的快捷键 ctrl + j</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素</span></span><br><span class="line">        <span class="comment">// iterator.next();//NoSuchElementException</span></span><br><span class="line">        <span class="comment">//4. 如果希望再次遍历，需要重置我们的迭代器</span></span><br><span class="line">        iterator = col.iterator();<span class="comment">//重置迭代器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===第二次遍历===&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj=&quot;</span> + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>迭代器迭代完了之后退出循环的时候指向最后位置的元素，此时再使用<code>.next()</code>方法会异常</strong>。需要重置迭代器，重新调用<code>.iterator()</code>方法生成返回一个需要的迭代器即可。</li>
</ul>
<h5 id="25-2-2-2-for-循环增强"><a href="#25-2-2-2-for-循环增强" class="headerlink" title="25.2.2.2 -for 循环增强"></a>25.2.2.2 -for 循环增强</h5><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123105036233.png" alt="image-20220123105036233"  />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection col = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    col.add(<span class="number">1</span>);</span><br><span class="line">    col.add(<span class="number">2</span>);</span><br><span class="line">    col.add(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object c : col) &#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**增强for循环底层仍然是使用的迭代器来遍历，可以理解为一个简化版的迭代器遍历(可以追断点看见)**。</li>
</ul>
</li>
</ul>
<h3 id="25-3-List接口"><a href="#25-3-List接口" class="headerlink" title="25.3 List接口"></a>25.3 List接口</h3><h4 id="25-3-1-List接口基本介绍"><a href="#25-3-1-List接口基本介绍" class="headerlink" title="25.3.1 List接口基本介绍"></a>25.3.1 List接口基本介绍</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123114115175.png" alt="image-20220123114115175"></p>
<ul>
<li><p><strong>ArrayList,LinkedList,Vector是比较常用的三个实现子类</strong>。</p>
</li>
<li><p><strong>List.get(索引)得到对应索引的List元素</strong>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="25-3-2-List-接口的常用方法"><a href="#25-3-2-List-接口的常用方法" class="headerlink" title="25.3.2 List 接口的常用方法"></a>25.3.2 List 接口的常用方法</h4><ul>
<li>```java<br>public class ListMethod {<pre><code>public static void main(String[] args) &#123;
    List list = newArrayList();
    
    //普通的添加元素add
    list.add(&quot;张三丰&quot;);
    list.add(&quot;贾宝玉&quot;);
    
    // void add(int index, Object ele):在 index 位置插入 ele 元素
    //在 index = 1 的位置插入一个对象
    list.add(1, &quot;韩顺平&quot;);
    System.out.println(&quot;list=&quot; + list);
    
    // boolean addAll(int index, Collection eles):从 index 位置开始将 eles 中的所有元素添加进来
    List list2 = newArrayList();
    list2.add(&quot;jack&quot;);
    list2.add(&quot;tom&quot;);
    list.addAll(1, list2);
    System.out.println(&quot;list=&quot; + list);
    
    // Object get(int index):获取指定 index 位置的元素
    
    // int indexOf(Object obj):返回 obj 在集合中首次出现的位置
    System.out.println(list.indexOf(&quot;tom&quot;));//2
    
    // int lastIndexOf(Object obj):返回 obj 在当前集合中末次出现的位置
    list.add(&quot;韩顺平&quot;);
    System.out.println(&quot;list=&quot; + list);
    System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));
    
    // Object remove(int index):移除指定 index 位置的元素，并返回此元素
    list.remove(0);
    System.out.println(&quot;list=&quot; + list);
    
    // Object set(int index, Object ele):设置指定 index 位置的元素为 ele , 相当于是替换.
    list.set(1, &quot;玛丽&quot;);
    System.out.println(&quot;list=&quot; + list);
    
    // List subList(int fromIndex, int toIndex):返回从 fromIndex 到 toIndex 位置的子集合
    // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex
    List returnlist = list.subList(0, 2);
    System.out.println(&quot;returnlist=&quot; + returnlist);
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  + **可以添加null，即.add(null)**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.3.3  List 的三种遍历方式</span><br><span class="line"></span><br><span class="line">+ ![image-20220123114805318](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123114805318.png)</span><br><span class="line">  + **List有顺序，因此可以使用普通for依据索引依次遍历**。</span><br><span class="line">  + **Vector，LinkedList也一样有这三种方式**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.3.4  ArrayList 底层结构和源码分析</span><br><span class="line"></span><br><span class="line">+ ![image-20220123182240774](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123182240774.png)</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">     //这是ArrayList源码里的add方法，从这里可以看出它是线程不安全的，没有使用 synchronized 关键字</span><br><span class="line">     public boolean add(E e) &#123;</span><br><span class="line">          ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">          elementData[size++] = e;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="25-3-4-1-源码分析"><a href="#25-3-4-1-源码分析" class="headerlink" title="25.3.4.1 源码分析"></a>25.3.4.1 源码分析</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123182854676.png" alt="image-20220123182854676"></p>
<ol>
<li><strong>也就是说add添加的元素实际存放在一Object类型的elementData数组里面</strong>：</li>
</ol>
<img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220123182957730.png" alt="image-20220123182957730" style="zoom: 67%;" />

<ol start="2">
<li><strong>使用无参构造器首先是0-10-15-15+15/2=22-22+22/2=33，第一次初始化的时候是个空数组，每次需要扩容的时候以1.5倍的方式扩容</strong>。</li>
<li><strong>如果使用指定大小构造器，则按指定的大小的1.5倍开始扩容</strong>。</li>
</ol>
</li>
</ul>
<h5 id="25-3-4-2-追源码"><a href="#25-3-4-2-追源码" class="headerlink" title="25.3.4.2 追源码"></a>25.3.4.2 追源码</h5><ul>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>//注意，注意，注意，Idea 默认情况下，Debug 显示的数据是简化后的，如果希望看到完整的数据需要做设置.
//使用无参构造器创建 ArrayList 对象
ArrayList list = newArrayList();    //elementData.lenth = 0
//使用 for 给 list 集合添加 1-10 数据
for (int i = 1; i &lt;= 10; i++) &#123;
    list.add(i);                    //elementData.lenth = 10
&#125;
//使用 for 给 list 集合添加 11-15 数据
for (int i = 11; i &lt;= 15; i++) &#123;
    list.add(i);                    //elementData.lenth = 15
&#125;
list.add(100);                        //elementData.lenth = 22
list.add(200);
list.add(null);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **无参构造器**：</span><br><span class="line"></span><br><span class="line">  + ![image-20220124100448168](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124100448168.png)</span><br><span class="line"></span><br><span class="line">  + &lt;img src=&quot;https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124100528127.png&quot; alt=&quot;image-20220124100528127&quot;  /&gt;</span><br><span class="line"></span><br><span class="line">+ **有参构造器**：</span><br><span class="line">  + ![image-20220124102046764](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124102046764.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.3.5 Vector 底层结构和源码剖析</span><br><span class="line"></span><br><span class="line">+ ![image-20220124105326840](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124105326840.png)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      //无参构造器</span><br><span class="line">      //有参数的构造</span><br><span class="line">      Vector vector = new Vector();</span><br><span class="line">      for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">          vector.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      vector.add(100);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>new vector()<strong>使用</strong>无参构造器</strong>，此时底层源码会<strong>调用有参构造器，参数默认10</strong>：</li>
</ol>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124105744662.png" alt="image-20220124105744662"></p>
<ol start="2">
<li><p>调用<strong>有参构造器</strong>的时候有<strong>两个参数</strong>，**一个是elementData数组长度，另一个是capacityIncrement固定是0(**这是参数后面扩容用到)</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124105904572.png" alt="image-20220124105904572"></p>
</li>
<li><p><strong>vector.add()<strong>：</strong>modCount记录修改次数，然后确认是否需要扩容，然后添加元素</strong>。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124110256510.png" alt="image-20220124110256510"></p>
</li>
<li><p><strong>ensureCapacityHelper()方法</strong>：判断<strong>最少需要容量</strong>是否大于elementData<strong>数组长度</strong>，是则调用grow()扩容</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124110434940.png" alt="image-20220124110434940"></p>
</li>
<li><p><strong>grow()方法</strong>：newCapacity等于原来的长度+原来的长度，即**扩容二倍(因为capacityIncrement固定是0，后面的三元表达式一直为假，返回oldCapacity)**。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124110624403.png" alt="image-20220124110624403"></p>
</li>
</ol>
</li>
<li><p><strong>使用有参构造器不同之处在于默认长度为自己设置，而不是10</strong>。</p>
</li>
</ul>
<h4 id="25-3-6-Vector-和-ArrayList-的比较"><a href="#25-3-6-Vector-和-ArrayList-的比较" class="headerlink" title="25.3.6  Vector 和 ArrayList 的比较"></a>25.3.6  Vector 和 ArrayList 的比较</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124111310294.png" alt="image-20220124111310294"></li>
</ul>
<h4 id="25-3-7-LinkedList-底层结构"><a href="#25-3-7-LinkedList-底层结构" class="headerlink" title="25.3.7  LinkedList 底层结构"></a>25.3.7  LinkedList 底层结构</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124114646341.png" alt="image-20220124114646341"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124114752627.png" alt="image-20220124114752627"></p>
</li>
</ul>
<h5 id="25-3-7-1-LinkedList-的增删改查"><a href="#25-3-7-1-LinkedList-的增删改查" class="headerlink" title="25.3.7.1 LinkedList 的增删改查"></a>25.3.7.1 LinkedList 的增删改查</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    linkedList.add(<span class="number">1</span>);</span><br><span class="line">    linkedList.add(<span class="number">2</span>);</span><br><span class="line">    linkedList.add(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;linkedList=&quot;</span> + linkedList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//演示一个删除结点的</span></span><br><span class="line">    linkedList.remove(); <span class="comment">// 这里默认删除的是第一个结点，会返回被删除结点的数据item</span></span><br><span class="line">    System.out.println(<span class="string">&quot;linkedList=&quot;</span> + linkedList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//修改某个结点对象</span></span><br><span class="line">    linkedList.set(<span class="number">1</span>, <span class="number">999</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;linkedList=&quot;</span> + linkedList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//得到某个结点对象</span></span><br><span class="line">    <span class="comment">//get(1) 是得到双向链表的第二个对象</span></span><br><span class="line">    Object o = linkedList.get(<span class="number">1</span>);</span><br><span class="line">    System.out.println(o);<span class="comment">//999</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为 LinkedList 是 实现了 List 接口, 遍历方式</span></span><br><span class="line">    第一种遍历方式：</span><br><span class="line">    System.out.println(<span class="string">&quot;===LinkeList 遍历迭代器====&quot;</span>);</span><br><span class="line">    Iterator iterator = linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;next=&quot;</span> + next);</span><br><span class="line">    &#125;</span><br><span class="line">    第二种遍历方式：</span><br><span class="line">    System.out.println(<span class="string">&quot;===LinkeList 遍历增强 for====&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object o1 : linkedList) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;o1=&quot;</span> + o1);</span><br><span class="line">    &#125;</span><br><span class="line">    第三种遍历方式：</span><br><span class="line">    System.out.println(<span class="string">&quot;===LinkeList 遍历普通 for====&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">        System.out.println(linkedList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//源码阅读.</span></span><br><span class="line">    <span class="number">1.</span> 	LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="number">2.</span> 这时 linkeList 的属性 first = <span class="keyword">null</span> last = <span class="keyword">null</span></span><br><span class="line">    <span class="number">3.</span> 执行 添加</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            linkLast(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="number">4.</span>将新的结点，加入到双向链表的最后</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">            last = newNode;</span><br><span class="line">            <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l.next = newNode;</span><br><span class="line">            size++;</span><br><span class="line">            modCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//源码 linkedList.remove();  这里默认删除的是第一个结点</span></span><br><span class="line">    <span class="number">1.</span> 执行 <span class="function">removeFirst</span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="number">2.</span> 执行</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="number">3.</span> 执行 unlinkFirst, 将 f 指向的双向链表的第一个结点拿掉</span><br><span class="line">        <span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">            <span class="keyword">final</span> E element = f.item;</span><br><span class="line">            <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">            f.item = <span class="keyword">null</span>;</span><br><span class="line">            f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            first = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                last = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next.prev = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>删除有三种：默认、指定索引、指定结点</strong>。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124124620017.png" alt="image-20220124124620017"></p>
</li>
</ul>
<h4 id="25-3-8-ArrayList-和-LinkedList-比较"><a href="#25-3-8-ArrayList-和-LinkedList-比较" class="headerlink" title="25.3.8 ArrayList 和 LinkedList 比较"></a>25.3.8 ArrayList 和 LinkedList 比较</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124125521375.png" alt="image-20220124125521375"><ul>
<li><strong>ArrayList和LinkedList都是线程不安全的，vector是线程安全的</strong>。</li>
</ul>
</li>
</ul>
<h3 id="25-4-Set-接口"><a href="#25-4-Set-接口" class="headerlink" title="25.4  Set 接口"></a>25.4  Set 接口</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124170225581.png" alt="image-20220124170225581"></p>
</li>
<li><p><strong>和 List 接口一样, Set 接口也是 Collection 的子接口，因此，<u>常用方法</u>和 Collection 接口一样</strong>.</p>
</li>
<li><p>Set接口的实现类有很多，HashSet和TreeSet比较常用。</p>
</li>
<li><p><strong>注意：虽然Set接口添加和取出的顺序不一致，但是<u>取出的顺序是固定的</u>，即多取几次顺序不会变化，因为它的底层在存放元素的时候会根据哈希值计算索引，因此索引顺序是乱的，但是是固定的</strong>。</p>
</li>
</ul>
<h4 id="25-4-1-遍历方式-两种"><a href="#25-4-1-遍历方式-两种" class="headerlink" title="25.4.1 遍历方式(两种)"></a>25.4.1 遍历方式(两种)<img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124170311551.png" alt="image-20220124170311551"></h4><h4 id="25-4-2-HashSet"><a href="#25-4-2-HashSet" class="headerlink" title="25.4.2 HashSet"></a>25.4.2 HashSet</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124173839183.png" alt="image-20220124173839183"><ul>
<li><strong>HashSet的底层是HsahMap，HashMap的底层是（数组+链表+红黑树）：之所以不使用单纯的数组或者链表，是因为这样存储效率太低，使用数组+链表存储效率会提高很多</strong>。</li>
<li><strong>HashMap用的是Node类型的数组，里面存放Node结点</strong>。这个Node就是HashMap里面的一个<strong>静态内部类</strong>。</li>
</ul>
</li>
</ul>
<h5 id="25-4-2-1-HashSet-add-方法分析"><a href="#25-4-2-1-HashSet-add-方法分析" class="headerlink" title="25.4.2.1 HashSet.add()方法分析"></a>25.4.2.1 HashSet.add()方法分析</h5><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124190124073.png" alt="image-20220124190124073"></p>
</li>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>HashSet hashSet = new HashSet();
hashSet.add(&quot;java&quot;);//到此位置，第 1 次 add 分析完毕.
hashSet.add(&quot;php&quot;);//到此位置，第 2 次 add 分析完毕
hashSet.add(&quot;java&quot;);
System.out.println(&quot;set=&quot; + hashSet);

// HashSet 的源码解读
1. 执行 new HashSet()
    public HashSet() &#123;
    map = new HashMap&lt;&gt;();
&#125;

2. 执行 add()
    public boolean add(E e) &#123;//e = &quot;java&quot;
    return map.put(e, PRESENT) == null;//put方法添加成功会返回null，然后该条件表达式为真最终返回true，添加成功
    //(static) PRESENT = new Object();PRESENT没什么意义，起一个占位的作用
&#125;

3.执行 put() , 该方法会执行 hash(key) 得到 key 对应的 hash 值 算法 h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)//无符号右移16位，按位异或，减少碰撞
    public V put(K key, V value) &#123;//key = &quot;java&quot; value = PRESENT 共享
        return putVal(hash(key), key, value, false, true);
        &#125;

4.执行 putVal
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义了辅助变量
    //table 就是 HashMap 的一个数组，类型是 Node[]
    //if 语句表示如果当前 table 是 null, 或者 大小=0
    //就是第一次扩容，到 16 个空间.
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;//resize方法放下面另一个代码块
    //(1)根据 key，得到 hash 去计算该 key 应该存放到 table 表的哪个索引位置并把这个位置的对象，赋给 p
    //(2)判断 p 是否为 null
    //(2.1) 如果 p 为 null, 表示还没有存放元素, 就创建一个 Node (key=&quot;java&quot;,value=PRESENT)
    //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else &#123;
        //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建
        Node&lt;K,V&gt; e; K k; //
        //如果当前索引位置对应的链表的第一个元素和准备添加的 key 的 hash 值一样
        //并且满足 下面两个条件之一:
        //(1) 准备加入的 key 和 p 指向的 Node 结点的 key 是同一个对象
        //(2) p 指向的 Node 结点的 key 的 equals() 和准备加入的 key 比较后相同
        //就不能加入
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        //再判断 p 是不是一颗红黑树,
        //如果是一颗红黑树，就调用 putTreeVal , 来进行添加
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else &#123;//如果 table 对应索引位置，已经是一个链表, 就使用 for 循环比较
            //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后
            // 注意在把元素添加到链表后，立即判断 该链表是否已经达到 8 个结点
            // 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)
            // 注意，在转成红黑树时，要进行判断, 判断条件
                /* 
                if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY(64))
                     resize();  //扩容
                */
            // 如果上面条件成立，先 table 扩容.
            // 只有上面条件不成立时，才进行转成红黑树
            //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接 break
            for (int binCount = 0; ; ++binCount) &#123;
                if ((e = p.next) == null) &#123;
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;//p移动到e的位置，一次遍历链表
            &#125;
        &#125;
        if (e != null) &#123; // existing mapping for key
            V oldValue = e.value;//PRESENT
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;//e不等于空表示添加失败，返回的不是null，遇上一层的条件表达式 ==null得false
        &#125;
    &#125;
    ++modCount;
    //size 就是我们每加入一个结点 Node(k,v,h,next), size++
    if (++size &gt; threshold)
        resize();//扩容
    afterNodeInsertion(evict);//此方法HashMap没有实现，留给子类实现
    return null;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **resize()方法**：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">          Node&lt;K,V&gt;[] oldTab = table;//这个table就是放数据的数组</span><br><span class="line">          int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">          int oldThr = threshold;</span><br><span class="line">          int newCap, newThr = 0;</span><br><span class="line">          if (oldCap &gt; 0) &#123;</span><br><span class="line">              if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                  threshold = Integer.MAX_VALUE;</span><br><span class="line">                  return oldTab;</span><br><span class="line">              &#125;</span><br><span class="line">              else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                       oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                  newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">          &#125;</span><br><span class="line">          else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">              newCap = oldThr;</span><br><span class="line">          else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">              newCap = DEFAULT_INITIAL_CAPACITY;//默认大小为16</span><br><span class="line">              newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//DEFAULT_LOAD_FACTOR表示装载因子，这里是0.75，两者相乘表示数据存放数量临界值，超过此值应扩容</span><br><span class="line">          &#125;</span><br><span class="line">          if (newThr == 0) &#123;</span><br><span class="line">              float ft = (float)newCap * loadFactor;</span><br><span class="line">              newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                        (int)ft : Integer.MAX_VALUE);</span><br><span class="line">          &#125;</span><br><span class="line">          threshold = newThr;//threshold就表示临界值</span><br><span class="line">          @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">              Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//这里是关键，new了一个newCap容量大小的newTab数组</span><br><span class="line">          table = newTab;//此时把 newTab赋给table</span><br><span class="line">          if (oldTab != null) &#123;//这段不管</span><br><span class="line">              for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                  Node&lt;K,V&gt; e;</span><br><span class="line">                  if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                      oldTab[j] = null;</span><br><span class="line">                      if (e.next == null)</span><br><span class="line">                          newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                      else if (e instanceof TreeNode)</span><br><span class="line">                          ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                      else &#123; // preserve order</span><br><span class="line">                          Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                          Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                          Node&lt;K,V&gt; next;</span><br><span class="line">                          do &#123;</span><br><span class="line">                              next = e.next;</span><br><span class="line">                              if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                                  if (loTail == null)</span><br><span class="line">                                      loHead = e;</span><br><span class="line">                                  else</span><br><span class="line">                                      loTail.next = e;</span><br><span class="line">                                  loTail = e;</span><br><span class="line">                              &#125;</span><br><span class="line">                              else &#123;</span><br><span class="line">                                  if (hiTail == null)</span><br><span class="line">                                      hiHead = e;</span><br><span class="line">                                  else</span><br><span class="line">                                      hiTail.next = e;</span><br><span class="line">                                  hiTail = e;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125; while ((e = next) != null);</span><br><span class="line">                          if (loTail != null) &#123;</span><br><span class="line">                              loTail.next = null;</span><br><span class="line">                              newTab[j] = loHead;</span><br><span class="line">                          &#125;</span><br><span class="line">                          if (hiTail != null) &#123;</span><br><span class="line">                              hiTail.next = null;</span><br><span class="line">                              newTab[j + oldCap] = hiHead;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return newTab;//最终返回newTab</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>补充</strong>：<img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124194309747.png" alt="image-20220124194309747"></p>
<ul>
<li><strong>注意：这里当一条链表元素到达8但是table大小小于64时不会树化，而是数组扩容，而树化和扩容一次只能进行一种，并不是在这一步扩容完直接树化，而且扩容也只扩一倍，并不是直接扩容到64大小</strong>。<ul>
<li><strong>例如：此时table大小为16，有一条已经到了9，此时table扩到32；然后加链表到了10，table扩到64；链表到了11，table大小不在扩大，此时Node结点变成treeNode结点，树化</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>注意：判断是否超过阈值而扩容的源码比较的是size是否大于threshold，而这个size表示的是每add一个size就增加，并不是说在链表上而不在table上的就不算，因此有可能table只有一个索引存放了链表，但是这个链表长度超过阈值，也会扩容，但要注意单挑链表超过8就会树化</strong>。</p>
<ul>
<li><p>```java<br>if (++size &gt; threshold)</p>
<pre><code>resize();
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 25.4.2.2 快捷键设置hashCode和equals方法</span><br><span class="line"></span><br><span class="line">+ **例如一个对象有age和name两个属性，此时`alt+ins`里面选择**![image-20220124202348467](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124202348467.png)：</span><br><span class="line">  1. &lt;img src=&quot;https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124202429734.png&quot; alt=&quot;image-20220124202429734&quot; style=&quot;zoom: 80%;&quot; /&gt;</span><br><span class="line">     + **这里表示选择哪些属性作为`equals()`方法判断标准，即这些属性相同则equals返回true**。</span><br><span class="line">  2. &lt;img src=&quot;https://gitee.com/YuFish-W/picture/raw/master/img/image-20220124202526357.png&quot; alt=&quot;image-20220124202526357&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line">     + **这里则表示选择哪些属性作为`hashCode()`方法判断标准**。</span><br><span class="line">+ **注意**：如果属性里面有对象类型的属性，那么该对象的`hashCode()`和`equals()`方法也应重写，因为判断到该对象属性是否相同的时候，由于动态绑定机制，判断依据是该对象的`hashCode()`和`equals()`方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.4.3 LinkedHashSet</span><br><span class="line"></span><br><span class="line">+ ![image-20220125105426208](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125105426208.png)</span><br><span class="line">  + **底层是LinkedHashMap，它是HashMap的子类**。</span><br><span class="line"></span><br><span class="line">+ ![image-20220125105706389](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125105706389.png)</span><br><span class="line"></span><br><span class="line">  + **LinkedHashSet数组类型依然是HashMap$Node类型的数组，但里面存放的元素类型是LinkedHashMap$Entry**。</span><br><span class="line"></span><br><span class="line">    &lt;img src=&quot;https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125111152771.png&quot; alt=&quot;image-20220125111152771&quot; style=&quot;zoom: 80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    + **由此可见这里运用到了数组的多态，Entry继承了HashMap.Node**：</span><br><span class="line"></span><br><span class="line">      ```java</span><br><span class="line">      //Entry的源码：</span><br><span class="line">      static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">              Entry&lt;K,V&gt; before, after;</span><br><span class="line">              Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">                  super(hash, key, value, next);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由此可见Entry只是在继承了Node后<strong>多加了before和after两个属性，其余一样</strong>。<strong>而且LinkedHashSet也继承HashSet，它继承了HashSet的add方法，因此在添加元素的时候计算索引和判断是否重复的方式一致</strong>，不同的是多了before和after可以实现顺序取出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="25-5-Map-接口"><a href="#25-5-Map-接口" class="headerlink" title="25.5 Map 接口"></a>25.5 Map 接口</h3><ul>
<li><p><strong>Map是双列集合，即实现了Key-value键值对。Set里面其实为了使用Map也用到了K-V，但是这个V是PRENSENT常量，Map的Value有我们设置</strong>。</p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125114338098.png" alt="image-20220125114338098"></p>
<ul>
<li><strong>注意第三点：key不能重复，如果后面后重复的key添加，那么后添加的key的value会替换掉先添加的</strong>。</li>
<li><strong>注意第六点：常用String作为key，但是key和value的类型都是Object，只要是Object都可以</strong>。</li>
</ul>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125134933858.png" alt="image-20220125134933858"></p>
<ul>
<li><p><strong>实际上一对K-V是存放在HashMap.Node里面的，这个Node实现了Map.Entry接口，因此可以用Entry来接收Node，然后底层为了方便管理又有一个entrySet属性，它是一个集合，存放的元素类型是EntrySet类型，而EntrySet类型可以存放Entry类型的数据，因此Node实现了Entry接口可以存放。最终entrySet集合存放EntrySet类型元素，但是最终存放的元素类型是HashMap.Node类型，可以说这个entrySet集合里的K-V只是指向Node里面的K-V。通过entrySet()方法可以返回一个与这个entrySet相同的集合，然后用getclass()方法可以看到运行类型以及里面元素的运行类型</strong>：</p>
<ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125141752593.png" alt="image-20220125141752593"></li>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125141556302.png" alt="image-20220125141556302"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;<span class="comment">//entrySet属性，是一个集合，存放了EntrySet类型元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;..&#125;<span class="comment">//EntrySet类，可以指向Entry类型元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;<span class="comment">//entrySet方法</span></span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>实际的K-V存放在Node里面而不是entrySet里面</strong>。</p>
</li>
<li><p><strong><u>Entry接口</u>有getKey()和getValue()两个方法，可以取出entrySet集合里的元素用此方法分别得到键和值</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        Set set = map.entrySet();</span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        Map.Entry entry = (Map.Entry) iterator.next();<span class="comment">//迭代器返回的是Object类型，转成Entry</span></span><br><span class="line">        System.out.println(entry.getKey());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实际上<u>map接口</u>里的keySet()方法可以返回key的集合,Values()方法可以返回value的集合</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set set = map.keySet();</span><br><span class="line">Collection values = map.values();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>这两个返回的集合里的K和V也是只是指向Node里面K-V，并不是new的新的</strong>。</li>
</ul>
</li>
</ul>
<h4 id="25-5-1-Map-接口常用方法"><a href="#25-5-1-Map-接口常用方法" class="headerlink" title="25.5.1 Map 接口常用方法"></a>25.5.1 Map 接口常用方法</h4><ul>
<li>```java<br>public static void main(String[] args) {<pre><code>//演示 map 接口常用方法
Map map = new HashMap();
map.put(&quot;邓超&quot;, new Book(&quot;&quot;, 100));//OK
map.put(&quot;邓超&quot;, &quot;孙俪&quot;);//替换
map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);//OK
map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);//OK
map.put(&quot;刘令博&quot;, null);//OK
map.put(null, &quot;刘亦菲&quot;);//OK
map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);//OK
map.put(&quot;hsp&quot;, &quot;hsp 的老婆&quot;);
System.out.println(&quot;map=&quot; + map);

// remove:根据键删除映射关系
map.remove(null);
System.out.println(&quot;map=&quot; + map);

// get：根据键获取值
Object val = map.get(&quot;鹿晗&quot;);
System.out.println(&quot;val=&quot; + val);

// size:获取元素个数
System.out.println(&quot;k-v=&quot; + map.size());

// isEmpty:判断个数是否为 0
System.out.println(map.isEmpty());//F

// clear:清除 k-v
map.clear();
System.out.println(&quot;map=&quot; + map);

// containsKey:查找键是否存在
System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T
</code></pre>
}class Book {<pre><code>private String name;
private int num;
public Book(String name, int num) &#123;
    this.name = name;
    this.num = num;
&#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.5.2  Map 接口遍历方法</span><br><span class="line"></span><br><span class="line">+ ![image-20220125152546814](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125152546814.png)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Map map = new HashMap();</span><br><span class="line">      map.put(&quot;邓超&quot;, &quot;孙俪&quot;);</span><br><span class="line">      map.put(&quot;王宝强&quot;, &quot;马蓉&quot;);</span><br><span class="line">      map.put(&quot;宋喆&quot;, &quot;马蓉&quot;);</span><br><span class="line">      map.put(&quot;刘令博&quot;, null);</span><br><span class="line">      map.put(null, &quot;刘亦菲&quot;);</span><br><span class="line">      map.put(&quot;鹿晗&quot;, &quot;关晓彤&quot;);</span><br><span class="line">      </span><br><span class="line">      //第一组: 先取出 所有的 Key , 通过 Key 取出对应的 Value</span><br><span class="line">      Set keyset = map.keySet();</span><br><span class="line">      //(1) 增强 for</span><br><span class="line">      System.out.println(&quot;-----第一种方式-------&quot;);</span><br><span class="line">      for (Object key : keyset) &#123;</span><br><span class="line">          System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      //(2) 迭代器</span><br><span class="line">      System.out.println(&quot;----第二种方式--------&quot;);</span><br><span class="line">      Iterator iterator = keyset.iterator();</span><br><span class="line">      while (iterator.hasNext()) &#123;</span><br><span class="line">          Object key = iterator.next();</span><br><span class="line">          System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //第二组: 把所有的 values 取出</span><br><span class="line">      Collection values = map.values();</span><br><span class="line">      //这里可以使用所有的 Collections 使用的遍历方法</span><br><span class="line">      //(1) 增强 for</span><br><span class="line">      System.out.println(&quot;---取出所有的 value 增强 for----&quot;);</span><br><span class="line">      for (Object value : values) &#123;</span><br><span class="line">          System.out.println(value);</span><br><span class="line">      &#125;</span><br><span class="line">      //(2) 迭代器</span><br><span class="line">      System.out.println(&quot;---取出所有的 value 迭代器----&quot;);</span><br><span class="line">      Iterator iterator2 = values.iterator();</span><br><span class="line">      while (iterator2.hasNext()) &#123;</span><br><span class="line">          Object value = iterator2.next();</span><br><span class="line">          System.out.println(value);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //第三组: 通过 EntrySet 来获取 k-v</span><br><span class="line">      Set entrySet = map.entrySet();// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><span class="line">      //(1) 增强 for</span><br><span class="line">      System.out.println(&quot;----使用 EntrySet 的 for 增强(第 3 种)----&quot;);</span><br><span class="line">      for (Object entry : entrySet) &#123;</span><br><span class="line">          //将 entry 转成 Map.Entry</span><br><span class="line">          Map.Entry m = (Map.Entry) entry;</span><br><span class="line">          System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      //(2) 迭代器</span><br><span class="line">      System.out.println(&quot;----使用 EntrySet 的 迭代器(第 4 种)----&quot;);</span><br><span class="line">      Iterator iterator3 = entrySet.iterator();</span><br><span class="line">      while (iterator3.hasNext()) &#123;</span><br><span class="line">          Object entry = iterator3.next();</span><br><span class="line">          //System.out.println(next.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br><span class="line">          //向下转型 Map.Entry</span><br><span class="line">          Map.Entry m = (Map.Entry) entry;</span><br><span class="line">          System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="25-5-3-阶段小结"><a href="#25-5-3-阶段小结" class="headerlink" title="25.5.3 阶段小结"></a>25.5.3 阶段小结</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125195133444.png" alt="image-20220125195133444"></p>
<ul>
<li><p><strong>当添加相同key的键值对的时候，只是替换原先Node结点里面的value值，并不是全部换新</strong>。</p>
<ul>
<li><p>```java<br>//如果碰到key相同，会触发以下两条源码：<br>Node&lt;K,V&gt; e;<br>if (p.hash == hash &amp;&amp;</p>
<pre><code>            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;//一个新的Node e指向此时的Node p
</code></pre>
<p>}<br>//因此下面的if成立，e不为空<br>if (e != null) { // existing mapping for key</p>
<pre><code>            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)//成立
                e.value = value;//将新的value替换掉原先e里面的value
            afterNodeAccess(e);
            return oldValue;
        &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">    + </span><br><span class="line">  </span><br><span class="line">  + **添加的时候和HashSet一样，只是判断key的哈希值和equals，与value无关**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.5.4 HashMap 底层机制及源码剖析</span><br><span class="line"></span><br><span class="line">+ ![image-20220125203600243](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125203600243.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20220125203642177](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125203642177.png)</span><br><span class="line"></span><br><span class="line">  + **扩容也不是无限扩容，有一个最大值：`static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;`,即2^30**。**超过这个值后执行下句**</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;//临界值变成此值</span><br><span class="line">        return oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    //上述最大值</span><br><span class="line">    public static final int   MAX_VALUE = 0x7fffffff;</span><br></pre></td></tr></table></figure></li>
<li><p>即超过MAXIMUN_CAPACITY后阈值threshold设置成MAX_VALUE</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="25-5-4-1-源码分析"><a href="#25-5-4-1-源码分析" class="headerlink" title="25.5.4.1 源码分析"></a>25.5.4.1 源码分析</h5><ul>
<li>```java<br>public static void main(String[] args) {<pre><code>HashMap map = new HashMap();
map.put(&quot;java&quot;, 10);//ok
map.put(&quot;php&quot;, 10);//ok
map.put(&quot;java&quot;, 20);//替换 value
System.out.println(&quot;map=&quot; + map);

//HashMap 的源码
1. 执行构造器 new HashMap()
    初始化加载因子 loadfactor = 0.75
    HashMap$Node[] table = null
2. 执行 put 调用 hash 方法，计算 key 的 hash 值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)
    public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10
        return putVal(hash(key), key, value, false, true);
    &#125;
3. 执行 putVal
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量
    //如果底层的 table 数组为 null, 或者 length =0 , 就扩容到 16
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //取出 hash 值对应的 table 的索引位置的 Node, 如果为 null, 就直接把加入的 k-v
    //, 创建成一个 Node ,加入该位置即可
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else &#123;
        Node&lt;K,V&gt; e; K k;//辅助变量
        // 如果 table 的索引位置的 key 的 hash 相同和新的 key 的 hash 值相同，
        // 并 满足(table 现有的结点的 key 和准备添加的 key 是同一个对象 || equals 返回真)
        // 就认为不能加入新的 k-v
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)//如果当前的 table 的已有的 Node 是红黑树，就按照红黑树的方式处理
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else &#123;
            //如果找到的结点，后面是链表，就循环比较
            for (int binCount = 0; ; ++binCount) &#123;//死循环
                if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后
                    p.next = newNode(hash, key, value, null);
                    //加入后，判断当前链表的个数，是否已经到 8 个，到 8 个，后
                    //就调用 treeifyBin 方法进行红黑树的转换
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就 break,就只是替换 value
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            &#125;
        &#125;
        if (e != null) &#123; // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value; //替换，key 对应 value
            afterNodeAccess(e);
            return oldValue;
        &#125;
    &#125;
    ++modCount;//每增加一个 Node ,就 size++
    if (++size &gt; threshold[12-24-48])//如 size &gt; 临界值，就扩容
        resize();
    afterNodeInsertion(evict);
    return null;
&#125;
5. 关于树化(转成红黑树)
    //如果 table 为 null ,或者大小还没有到 64，暂时不树化，而是进行扩容.
    //否则才会真正的树化 -&gt; 剪枝
    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;
        int n, index; Node&lt;K,V&gt; e;
        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            resize();
    &#125;
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.5.5 Hashtable</span><br><span class="line"></span><br><span class="line">+ ![image-20220125211815265](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125211815265.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 25.5.5.1 Hashtable 和 HashMap 对比</span><br><span class="line"></span><br><span class="line">+ ![image-20220125211857869](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125211857869.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 25.5.6 Properties</span><br><span class="line"></span><br><span class="line">+ ![image-20220125211924779](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220125211924779.png)</span><br><span class="line"></span><br><span class="line">##### 25.5.6.1 基本使用</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      //1. Properties 继承 Hashtable</span><br><span class="line">      //2. 可以通过 k-v 存放数据，当然 key 和 value 不能为 null</span><br><span class="line">      </span><br><span class="line">      //增加</span><br><span class="line">      Properties properties = new Properties();</span><br><span class="line">      //properties.put(null, &quot;abc&quot;);//抛出 空指针异常</span><br><span class="line">      //properties.put(&quot;abc&quot;, null); //抛出 空指针异常</span><br><span class="line">      properties.put(&quot;john&quot;, 100);//k-v</span><br><span class="line">      properties.put(&quot;lucy&quot;, 100);</span><br><span class="line">      properties.put(&quot;lic&quot;, 100);</span><br><span class="line">      properties.put(&quot;lic&quot;, 88);//如果有相同的 key ， value 被替换</span><br><span class="line">      System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line">      //通过 k 获取对应值</span><br><span class="line">      System.out.println(properties.get(&quot;lic&quot;));//88</span><br><span class="line">      </span><br><span class="line">      //删除</span><br><span class="line">      properties.remove(&quot;lic&quot;);</span><br><span class="line">      System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line">      </span><br><span class="line">      //修改</span><br><span class="line">      properties.put(&quot;john&quot;, &quot;约翰&quot;);</span><br><span class="line">      System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line">      </span><br><span class="line">      //查</span><br><span class="line">      System.out.println(propertiex.get(&quot;john&quot;));</span><br><span class="line">      System.out.println(propertiex.getProperty(&quot;john&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="25-6-开发中如何选择集合实现类"><a href="#25-6-开发中如何选择集合实现类" class="headerlink" title="25.6 开发中如何选择集合实现类"></a>25.6 开发中如何选择集合实现类</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220126161218339.png" alt="image-20220126161218339"></li>
</ul>
<h3 id="25-7-TreeSet"><a href="#25-7-TreeSet" class="headerlink" title="25.7 TreeSet"></a>25.7 TreeSet</h3><ul>
<li><p>可以实现排序，创建的时候需要传入一个比较器</p>
</li>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code> // TreeSet treeSet = new TreeSet();  使用此默认构造器，无法排序
TreeSet treeSet = new TreeSet(new Comparator() &#123;
    @Override
    public int compare(Object o1, Object o2) &#123;
        //下面 调用 String 的 compareTo 方法进行字符串大小比较
        //如果老韩要求加入的元素，按照长度大小排序
        //return ((String) o2).compareTo((String) o1);
        return ((String) o1).length() - ((String) o2).length();
    &#125;
&#125;);
//1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的
//2. 老师希望添加的元素，按照字符串大小来排序
//3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类) 并指定排序规则
//4. 简单看看源码


1. 构造器把传入的比较器对象，赋给了 TreeSet 的底层的 TreeMap 的属性 this.comparator
    public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
        this.comparator = comparator;
    &#125;
2. 在 调用 treeSet.add(&quot;tom&quot;), 在底层会执行到
    if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)
        do &#123;
            parent = t;
            //动态绑定到我们的匿名内部类(对象)compare
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else //如果相等，即返回 0,这个 Key 就没有加入，底层判断两者为同一个对象！！！！！！！！注意：从这里可以知道，我们自己设置的比较规则得出的结果会底层是否将两个对象判断为同一个对象。
                return t.setValue(value);//
        &#125; while (t != null);
    &#125;


//添加数据.
treeSet.add(&quot;jack&quot;);
treeSet.add(&quot;tom&quot;);//3
treeSet.add(&quot;sp&quot;);
treeSet.add(&quot;a&quot;);
treeSet.add(&quot;abc&quot;);//3
System.out.println(&quot;treeSet=&quot; + treeSet);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ **TreeSet传入的比较器中设置的方法中是否涉及到类型转换，这将决定添加的元素是什么类型**。</span><br><span class="line"></span><br><span class="line">+ **特别注意：如果使用默认构造器，即没有传入比较器，则底层会根据添加的元素类型动态绑定到此类型的比较方法，因此如果第一个添加了int类型，后面添加的会调用integer的compareTo方法比较，而interger的compareTo方法只能和int比较，如果后面添加的类型不是int类型，则会抛出异常**:</span><br><span class="line"></span><br><span class="line">  + 因此TreeSet应该添加同类型的元素，否则可能异常</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  //无比较器时底层执行此段代码</span><br><span class="line">  if (key == null)</span><br><span class="line">      throw new NullPointerException();</span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//key是当前添加的元素，向上转型成Comparable(接口),因此传入的key必须是实现了Comparable接口的类，否则会异常！！！！！！</span><br><span class="line">  do &#123;</span><br><span class="line">      parent = t;</span><br><span class="line">      cmp = k.compareTo(t.key);//！！！！会动态绑定到k运行类型的compareTo方法</span><br><span class="line">      if (cmp &lt; 0)</span><br><span class="line">          t = t.left;</span><br><span class="line">      else if (cmp &gt; 0)</span><br><span class="line">          t = t.right;</span><br><span class="line">      else</span><br><span class="line">          return t.setValue(value);</span><br><span class="line">  &#125; while (t != null);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="25-8-TreeMap"><a href="#25-8-TreeMap" class="headerlink" title="25.8 TreeMap"></a>25.8 TreeMap</h3><ul>
<li><p><strong>TreeMap底层是Entry(TreeMap的一个内部类)，不再是Node</strong>。</p>
</li>
<li><p><strong>需要传入比较器才能排序</strong>。</p>
</li>
<li><p><strong>和TreeSet一样，毕竟TreeSet底层就是TreeMap，即如果不传入比较器，会根据类型动态调用对应的compareTo方法，如果添加的key的类型不一样，则可能会异常</strong>！！！！！</p>
</li>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>//使用默认的构造器，创建 TreeMap, 是无序的(也没有排序)
// TreeMap treeMap = new TreeMap();
TreeMap treeMap = new TreeMap(new Comparator() &#123;
    @Override
    public int compare(Object o1, Object o2) &#123;
        //按照 K(String) 的长度大小排序
        return ((String) o2).length() - ((String) o1).length();
    &#125;
&#125;);
treeMap.put(&quot;jack&quot;, &quot;杰克&quot;);
treeMap.put(&quot;tom&quot;, &quot;汤姆&quot;);
treeMap.put(&quot;kristina&quot;, &quot;克瑞斯提诺&quot;);
treeMap.put(&quot;smith&quot;, &quot;斯密斯&quot;);
treeMap.put(&quot;hsp&quot;, &quot;韩顺平&quot;);//长度和tom相同，加入不了，但是tom的value被替换成了&quot;韩顺平&quot;！！！！！
System.out.println(&quot;treemap=&quot; + treeMap);




//分析
1. 构造器. 把传入的实现了 Comparator 接口的匿名内部类(对象)，传给给 TreeMap 的 comparator
    public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;
        this.comparator = comparator;
    &#125;
2. 调用 put 方法
    2.1 第一次添加, 把 k-v 封装到 Entry 对象，放入 root
    Entry&lt;K,V&gt; t = root;
if (t == null) &#123;
    compare(key, key); // type (and possibly null) check
    /*虽然是第一次添加，但是还是调用了compare方法，这个方法是TreeMap内部的方法：
    final int compare(Object k1, Object k2) &#123;
        return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)
            : comparator.compare((K)k1, (K)k2);
    &#125;
    用来判断是否为null，如果为null就会异常。如果没有比较器则会根据类型动态调用此类型自己的，要注意此类型的compareTo方法是否能和不同类型比较，可能抛出异常，但此时都是相同的key，类型一致不会异常！！！！！！！！
    */
    root = new Entry&lt;&gt;(key, value, null);
    size = 1;
    modCount++;
    return null;
&#125;
2.2 以后添加
    Comparator&lt;? super K&gt; cpr = comparator;
if (cpr != null) &#123;
    do &#123; //遍历所有的 key , 给当前 key 找到适当位置
        parent = t;
        cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的 compare
        if (cmp &lt; 0)
            t = t.left;
        else if (cmp &gt; 0)
            t = t.right;
        else //如果遍历过程中，发现准备添加 Key 和当前已有的 Key 相等，就不添加
            return t.setValue(value);//!!!!!!注意，判断的时候只是比较key值，如果key相同，会将新的value替换掉原先的value！！！！！！！！！！！！！！！！！！！！！！！！！
    &#125; while (t != null);
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 25.9 Collections 工具类</span><br><span class="line"></span><br><span class="line">+ ![image-20220126194541984](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220126194541984.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20220126194701173](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220126194701173.png)</span><br><span class="line">+ ![image-20220126195043296](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220126195043296.png)</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      List list = new ArrayList();</span><br><span class="line">      list.add(&quot;tom&quot;);</span><br><span class="line">      list.add(&quot;smith&quot;);</span><br><span class="line">      list.add(&quot;king&quot;);</span><br><span class="line">      list.add(&quot;milan&quot;);</span><br><span class="line">      list.add(&quot;tom&quot;);</span><br><span class="line">      </span><br><span class="line">      // reverse(List)：反转 List 中元素的顺序</span><br><span class="line">      Collections.reverse(list);</span><br><span class="line">      System.out.println(&quot;list=&quot; + list);</span><br><span class="line">      </span><br><span class="line">      // shuffle(List)：对 List 集合元素进行随机排序</span><br><span class="line">      for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">          Collections.shuffle(list);</span><br><span class="line">          System.out.println(&quot;list=&quot; + list);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      // sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span><br><span class="line">      Collections.sort(list);</span><br><span class="line">      System.out.println(&quot;自然排序后&quot;);</span><br><span class="line">      System.out.println(&quot;list=&quot; + list);</span><br><span class="line">      </span><br><span class="line">      // sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</span><br><span class="line">      //我们希望按照 字符串的长度大小排序</span><br><span class="line">      Collections.sort(list, new Comparator() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public int compare(Object o1, Object o2) &#123;</span><br><span class="line">              //可以加入校验代码.</span><br><span class="line">              return ((String) o2).length() - ((String) o1).length();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(&quot;字符串长度大小排序=&quot; + list);</span><br><span class="line">      </span><br><span class="line">      // swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span><br><span class="line">      //比如</span><br><span class="line">      Collections.swap(list, 0, 1);</span><br><span class="line">      System.out.println(&quot;交换后的情况&quot;);</span><br><span class="line">      System.out.println(&quot;list=&quot; + list);</span><br><span class="line">      </span><br><span class="line">      //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span><br><span class="line">      System.out.println(&quot;自然顺序最大元素=&quot; + Collections.max(list));</span><br><span class="line">      //Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</span><br><span class="line">      //比如，我们要返回长度最大的元素</span><br><span class="line">      Object maxObject = Collections.max(list, new Comparator() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public int compare(Object o1, Object o2) &#123;</span><br><span class="line">              return ((String)o1).length() - ((String)o2).length();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(&quot;长度最大的元素=&quot; + maxObject);</span><br><span class="line">      //Object min(Collection)</span><br><span class="line">      //Object min(Collection，Comparator)</span><br><span class="line">      //上面的两个方法，参考 max 即可</span><br><span class="line">      </span><br><span class="line">      //int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span><br><span class="line">      System.out.println(&quot;tom 出现的次数=&quot; + Collections.frequency(list, &quot;tom&quot;));</span><br><span class="line">      </span><br><span class="line">      //void copy(List dest,List src)：将 src 中的内容复制到 dest 中</span><br><span class="line">      ArrayList dest = new ArrayList();</span><br><span class="line">      //为了完成一个完整拷贝，我们需要先给 dest 赋值，大小和 list.size()一样</span><br><span class="line">      //注意：这个大小指的是.size()方法返回的大小，即实际存放了多少元素，而不是底层的elementData数组大小</span><br><span class="line">      for(int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">          dest.add(&quot;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //拷贝</span><br><span class="line">      Collections.copy(dest, list);</span><br><span class="line">      System.out.println(&quot;dest=&quot; + dest);</span><br><span class="line">      </span><br><span class="line">      //boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span><br><span class="line">      //如果 list 中，有 tom 就替换成 汤姆</span><br><span class="line">      Collections.replaceAll(list, &quot;tom&quot;, &quot;汤姆&quot;);</span><br><span class="line">      System.out.println(&quot;list 替换后=&quot; + list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="25-10-题-重要"><a href="#25-10-题-重要" class="headerlink" title="25.10 题(重要)"></a>25.10 题(重要)</h3><ul>
<li>```java<br>//Person的hashCode()和equals()方法都重写了，即只要id和name相同就是同一元素<br>public static void main(String[] args) {<pre><code>HashSet hashSet = new HashSet();
Person p1 = new Person(1001, &quot;AA&quot;);
Person p2 = new Person(1002, &quot;BB&quot;);
hashSet.add(p1);
hashSet.add(p2);//add方法添加的时候Node里面的key是传入的p2的地址，因此p2改变Node结点里的key也会跟着变
System.out.println(hashSet);
p1.setName(&quot;CC&quot;);//改变了p1，hashSet里Node结点指向此地址的key自然也变化，要知道此时p1的哈希值已经变了，因为重写了hashCode()方法--按照id和name计算hash值，如果不重写的话hash值不会变，因为地址没有改变
System.out.println(hashSet);
hashSet.remove(p1);//这个remove是按照p1计算出来的hash值转成索引，再在底层数组中对应索引的链表上找equals相同的对象，!!!!!!!!!!此时p1的name已经变化，Person的hashCode()方法已经重写，并不是按地址计算，而是按照id和name计算，因此此时p1的hash值会变化，因此计算出来的索引位置也与原先不同，则无法找出已经add的p1，删除失败
System.out.println(hashSet);
hashSet.add(new Person(1001,&quot;CC&quot;));//这个新person虽然和先加入的p1的id和name相同，但是上面分析了p1添加时的hash值和现在并不一致，因此这个新的person哈希过后的索引上并没有p1，添加成功
System.out.println(hashSet);
hashSet.remove(p1);//此时会将刚刚加入的匿名person删除，因为此时的p1和它hash值一样
System.out.println(hashSet);
hashSet.add(new Person(1001,&quot;AA&quot;));//此时的新person的id和name和p1修改之前一样，因此它哈希过后的索引位置就是现在p1的位置，但是在equals比较的时候p1的name已经修改成了&quot;CC&quot;,因此判断为不同对象，添加成功
System.out.println(hashSet);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **输出结果**：![image-20220126211952846](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220126211952846.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 26 泛型</span><br><span class="line"></span><br><span class="line">+ 传统方法存在的缺陷：</span><br><span class="line">  + ![image-20220127145709967](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127145709967.png)</span><br><span class="line"></span><br><span class="line">+ 使用泛型的好处：</span><br><span class="line">  + ![image-20220127145758803](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127145758803.png)</span><br><span class="line"></span><br><span class="line">### 26.1 泛型简介</span><br><span class="line"></span><br><span class="line">+ ![image-20220127145839630](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127145839630.png)</span><br><span class="line"></span><br><span class="line">  + **泛型就是指定数据类型的类型**。</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    class Person&lt;E&gt; &#123;//在定义类的时候使用泛型</span><br><span class="line">        E s ;//E 表示 s 的数据类型, 该数据类型在定义 Person 对象的时候指定,即在编译期间，就确定 E 是什么类型</span><br><span class="line">        public Person(E s) &#123;//E 也可以是参数类型</span><br><span class="line">            this.s = s;</span><br><span class="line">        &#125;</span><br><span class="line">        public E f() &#123;//返回类型使用 E</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-2-泛型语法"><a href="#26-2-泛型语法" class="headerlink" title="26.2 泛型语法"></a>26.2 泛型语法</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127150113869.png" alt="image-20220127150113869"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127150156886.png" alt="image-20220127150156886"></p>
<ul>
<li><p><strong>第三点中第一种和第二种等价，即后面尖括号中可以省略，推荐使用第二种，更简洁</strong>。</p>
</li>
<li><p><strong>第四点</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pig pig = <span class="keyword">new</span> Pig();<span class="comment">//此时E默认是Object类型,不推荐</span></span><br><span class="line">Pig&lt;Object&gt; pig = <span class="keyword">new</span> Pig();<span class="comment">//和上面等价，推荐</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="26-3-自定义泛型"><a href="#26-3-自定义泛型" class="headerlink" title="26.3 自定义泛型"></a>26.3 自定义泛型</h3><h4 id="26-3-1-自定义类的泛型"><a href="#26-3-1-自定义类的泛型" class="headerlink" title="26.3.1 自定义类的泛型"></a>26.3.1 自定义类的泛型</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127173529338.png" alt="image-20220127173529338"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T t;</span><br><span class="line">    T[] ts = <span class="keyword">new</span> T[<span class="number">8</span>];<span class="comment">//错误，不能确定 T 的类型，就无法在内存开空间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T tt;<span class="comment">//错误，静态属性可能类还没加载就使用，无法确定T的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(T t)</span></span>&#123;&#125;;<span class="comment">//错误，同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="26-3-2-自定义接口的泛型"><a href="#26-3-2-自定义接口的泛型" class="headerlink" title="26.3.2 自定义接口的泛型"></a>26.3.2 自定义接口的泛型</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127174231666.png" alt="image-20220127174231666"><ul>
<li>一个接口在继承另一个接口时就需要确定另一个接口的泛型，不指定就是Object</li>
</ul>
</li>
</ul>
<h4 id="26-3-3-自定义泛型方法"><a href="#26-3-3-自定义泛型方法" class="headerlink" title="26.3.3 自定义泛型方法"></a>26.3.3 自定义泛型方法</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127175402831.png" alt="image-20220127175402831"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Car car = <span class="keyword">new</span> Car();</span><br><span class="line">    </span><br><span class="line">    car.fly(<span class="string">&quot;宝马&quot;</span>, <span class="number">100</span>);<span class="comment">//当调用方法时，传入参数，编译器，就会确定类型</span></span><br><span class="line">    <span class="comment">//！！！！注意：此时第二个参数的类型会输出Integer而不是int，因为泛型只能接收引用类型，会自动装箱</span></span><br><span class="line">    <span class="comment">//！！！！同时：泛型方法每次的泛型都需重新确定，而不是使用一次过后就确定了</span></span><br><span class="line">    System.out.println(<span class="string">&quot;=======&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    car.fly(<span class="number">300</span>, <span class="number">100.1</span>);<span class="comment">//当调用方法时，传入参数，编译器，就会确定类型</span></span><br><span class="line">    <span class="comment">//T-&gt;String, R-&gt;ArrayList</span></span><br><span class="line">    Fish&lt;String,ArrayList&gt; fish = <span class="keyword">new</span> Fish&lt;&gt;();</span><br><span class="line">    fish.hello(newArrayList(), <span class="number">11.3f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法，可以定义在普通类中, 也可以定义在泛型类中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;<span class="comment">//普通类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(T t, R r)</span> </span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">        System.out.println(t.getClass());</span><br><span class="line">        System.out.println(r.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;<span class="comment">//泛型类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>&lt;U,M&gt; <span class="keyword">void</span> <span class="title">eat</span><span class="params">(U u, M m)</span> </span>&#123;<span class="comment">//泛型方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//！！！！！！下面 hi 方法不是泛型方法,而是 hi 方法使用了类声明的泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>&lt;K&gt; <span class="keyword">void</span> <span class="title">hello</span><span class="params">(R r, K k)</span> </span>&#123;</span><br><span class="line">        System.out.println(r.getClass());</span><br><span class="line">        System.out.println(k.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-4-泛型的继承和通配符"><a href="#26-4-泛型的继承和通配符" class="headerlink" title="26.4  泛型的继承和通配符"></a>26.4  泛型的继承和通配符</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127181520835.png" alt="image-20220127181520835"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//泛型没有继承性</span></span><br><span class="line">    List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//举例说明下面三个方法的使用</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;AA&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BB&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;CC&gt; list5 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是 List&lt;?&gt; c ，可以接受任意的泛型类型</span></span><br><span class="line">    printCollection1(list1);</span><br><span class="line">    printCollection1(list2);</span><br><span class="line">    printCollection1(list3);</span><br><span class="line">    printCollection1(list4);</span><br><span class="line">    printCollection1(list5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA 或者 AA 子类</span></span><br><span class="line">    printCollection2(list1);<span class="comment">//×</span></span><br><span class="line">    printCollection2(list2);<span class="comment">//×</span></span><br><span class="line">    printCollection2(list3);<span class="comment">//√</span></span><br><span class="line">    printCollection2(list4);<span class="comment">//√</span></span><br><span class="line">    printCollection2(list5);<span class="comment">//√</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//List&lt;? super AA&gt; c: 支持 AA 类以及 AA 类的父类，不限于直接父类</span></span><br><span class="line">    printCollection3(list1);<span class="comment">//√</span></span><br><span class="line">    printCollection3(list2);<span class="comment">//×</span></span><br><span class="line">    printCollection3(list3);<span class="comment">//√</span></span><br><span class="line">    printCollection3(list4);<span class="comment">//×</span></span><br><span class="line">    printCollection3(list5);<span class="comment">//×</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? extendsAA 表示 上限，可以接受 AA 或者 AA 子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection2</span><span class="params">(List&lt;? extends AA&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//！！！！注意：在方法中添加带有泛型的参数时，只能添加指定的泛型，比如(List&lt;AA&gt; c)如果想添加AA的子类是不允许的，必须像(List&lt;? extends AA&gt; c)这样指明才能添加。</span></span><br><span class="line">    <span class="comment">//但如果在ArrayList&lt;AA&gt; aas = new ArrayList&lt;&gt;();添加元素是可以直接添加AA的子类的。</span></span><br><span class="line">    <span class="comment">//而且如果是这样使用?:ArrayList&lt;?&gt; aas = new ArrayList&lt;&gt;();此时?不能代表任何元素，即什么元素都无法添加</span></span><br><span class="line">    <span class="keyword">for</span> (Object object : c) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection1</span><span class="params">(List&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object object : c) &#123; <span class="comment">// 通配符，取出时，就是 Object</span></span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ? super 子类类名 AA:支持 AA 类以及 AA 类的父类，不限于直接父类，</span></span><br><span class="line"><span class="comment">//规定了泛型的下限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection3</span><span class="params">(List&lt;? <span class="keyword">super</span> AA&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object object : c) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> <span class="keyword">extends</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> <span class="keyword">extends</span> <span class="title">BB</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-5-JUnit"><a href="#26-5-JUnit" class="headerlink" title="26.5  JUnit"></a>26.5  JUnit</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127214126750.png" alt="image-20220127214126750"></p>
<ul>
<li><p><strong>使用的时候直接在类中的某一方法上加<code>@Test</code>就行，左边出现绿色运行按钮</strong></p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220127215109811.png" alt="image-20220127215109811"></p>
</li>
</ul>
</li>
</ul>
<h2 id="27-坦克大战-1"><a href="#27-坦克大战-1" class="headerlink" title="27  坦克大战[1]"></a>27  坦克大战[1]</h2><h3 id="27-1-坐标体系"><a href="#27-1-坐标体系" class="headerlink" title="27.1 坐标体系"></a>27.1 坐标体系</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128114328320.png" alt="image-20220128114328320"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128114407747.png" alt="image-20220128114407747"></p>
</li>
<li><p><strong>画圆的时候<code>fillOval(110,140,20,20);</code>中：110,140代表矩形的左上角点，20,20代表这个矩形的长和宽，在这个矩形中画圆</strong>。</p>
</li>
<li><p><strong>写字的时候<code>drawString(&quot;Bin导在干嘛&quot;,50,50);</code>中：50,50则代表所写字体的左下角</strong>。</p>
</li>
</ul>
<h3 id="27-2-基本绘图方法"><a href="#27-2-基本绘图方法" class="headerlink" title="27.2 基本绘图方法"></a>27.2 基本绘图方法</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128121516292.png" alt="image-20220128121516292"></p>
</li>
<li><p>```java<br>public class DrawCircle extends JFrame { //JFrame 对应窗口,可以理解成是一个画框</p>
<pre><code>//定义一个面板
private MyPanel mp = null;
public static void main(String[] args) &#123;
    new DrawCircle();
    System.out.println(&quot;退出程序~&quot;);
&#125;
public DrawCircle() &#123;//构造器
    //初始化面板
    mp = new MyPanel();
    //把面板放入到窗口(画框)
    this.add(mp);
    //设置窗口的大小
    this.setSize(400, 300);
    //当点击窗口的小×，程序完全退出.
    this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    this.setVisible(true);//可以显示
&#125;
</code></pre>
<p>}</p>
<p>//1.先定义一个 MyPanel, 继承 JPanel 类， 画图形，就在面板上画<br>class MyPanel extends JPanel {</p>
<pre><code>//说明:
//1. MyPanel 对象就是一个画板
//2. Graphics g 把 g 理解成一支画笔
//3. Graphics 提供了很多绘图的方法
@Override
public void paint(Graphics g) &#123;//绘图方法
    super.paint(g);//调用父类的方法完成初始化.
    System.out.println(&quot;paint 方法被调用了~&quot;);
    //画出一个圆形.
    g.drawOval(10, 10, 100, 100);
    //演示绘制不同的图形..
    //画直线 drawLine(int x1,int y1,int x2,int y2)
    g.drawLine(10, 10, 100, 100);
    //画矩形边框 drawRect(int x, int y, int width, int height)
    g.drawRect(10, 10, 100, 100);
    //画椭圆边框 drawOval(int x, int y, int width, int height)
    //填充矩形 fillRect(int x, int y, int width, int height)
    //设置画笔的颜色 setColor(Color c)
    g.setColor(Color.blue);
    g.fillRect(10, 10, 100, 100);
    //填充椭圆 fillOval(int x, int y, int width, int height)
    g.setColor(Color.red);
    g.fillOval(10, 10, 100, 100);
    //画图片 drawImage(Image img, int x, int y, ..)
    //1. 获取图片资源, /bg.png 表示在该项目的根目录去获取 bg.png 图片资源
    Image image = Toolkit.getDefaultToolkit().getImage(Panel.class.getResource(&quot;/bg.png&quot;));
    g.drawImage(image, 10, 10, 175, 221, this);
    //画字符串 drawString(String str, int x, int y)//写字
    //给画笔设置颜色和字体
    g.setColor(Color.red);
    //设置画笔的字体 setFont(Font font)
    g.setFont(new Font(&quot;隶书&quot;, Font.BOLD, 50));
    //这里设置的 100， 100， 是 &quot;北京你好&quot;左下角
    g.drawString(&quot;北京你好&quot;, 100, 100);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ![image-20220128121202426](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128121202426.png)</span><br><span class="line">  + **运行绘图程序后出现窗口，可以手动调节窗口大小，由于窗口大小变化则绘图位置也会变化，因此paint()会被调用**。</span><br><span class="line">  + **在paint()方法中写一条print语句就可以在终端看到是否被调用**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 27.3 java 事件处理机制</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  public class BallMove extends JFrame &#123; //窗口</span><br><span class="line">      MyPanel mp = null;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          BallMove ballMove = new BallMove();</span><br><span class="line">      &#125;</span><br><span class="line">      //构造器</span><br><span class="line">      public BallMove() &#123;</span><br><span class="line">          mp = new MyPanel();</span><br><span class="line">          this.add(mp);</span><br><span class="line">          this.setSize(400, 300);</span><br><span class="line">          //窗口 JFrame 对象可以监听键盘事件, 即可以监听到面板发生的键盘事件</span><br><span class="line">          this.addKeyListener(mp);</span><br><span class="line">          this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">          this.setVisible(true);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //面板, 可以画出小球</span><br><span class="line">  //KeyListener 是监听器, 可以监听键盘事件</span><br><span class="line">  class MyPanel extends JPanel implements KeyListener &#123;</span><br><span class="line">      //为了让小球可以移动, 把他的左上角的坐标(x,y)设置变量</span><br><span class="line">      int x = 10;</span><br><span class="line">      int y = 10;</span><br><span class="line">      @Override</span><br><span class="line">      public void paint(Graphics g) &#123;</span><br><span class="line">          super.paint(g);</span><br><span class="line">          g.fillOval(x, y, 20, 20); //默认黑色</span><br><span class="line">      &#125;</span><br><span class="line">      //有字符输出时，该方法就会触发</span><br><span class="line">      @Override</span><br><span class="line">      public void keyTyped(KeyEvent e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      //当某个键按下，该方法会触发</span><br><span class="line">      @Override</span><br><span class="line">      public void keyPressed(KeyEvent e) &#123;</span><br><span class="line">          //System.out.println((char)e.getKeyCode() + &quot;被按下..&quot;);</span><br><span class="line">          //根据用户按下的不同键，来处理小球的移动 (上下左右的键)</span><br><span class="line">          //在 java 中，会给每一个键，分配一个值(int)</span><br><span class="line">          if(e.getKeyCode() == KeyEvent.VK_DOWN) &#123;//KeyEvent.VK_DOWN 就是向下的箭头对应的 code</span><br><span class="line">              y++;</span><br><span class="line">          &#125; else if(e.getKeyCode() == KeyEvent.VK_UP) &#123;</span><br><span class="line">              y--;</span><br><span class="line">          &#125; else if(e.getKeyCode() == KeyEvent.VK_LEFT) &#123;</span><br><span class="line">              x--;</span><br><span class="line">          &#125; else if(e.getKeyCode() == KeyEvent.VK_RIGHT) &#123;</span><br><span class="line">              x++;</span><br><span class="line">          &#125;</span><br><span class="line">          //让面板重绘</span><br><span class="line">          this.repaint();</span><br><span class="line">      &#125;</span><br><span class="line">      //当某个键释放(松开)，该方法会触发</span><br><span class="line">      @Override</span><br><span class="line">      public void keyReleased(KeyEvent e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>这里MyPanel实现了KeyListener监听接口，它就是监听者</strong>。</li>
</ul>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152455290.png" alt="image-20220128152455290"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152530666.png" alt="image-20220128152530666"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152538592.png" alt="image-20220128152538592"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152548035.png" alt="image-20220128152548035"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128152559189.png" alt="image-20220128152559189"></p>
</li>
</ul>
<h2 id="28-多线程基础"><a href="#28-多线程基础" class="headerlink" title="28  多线程基础"></a>28  多线程基础</h2><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128210352703.png" alt="image-20220128210352703"></li>
</ul>
<h3 id="28-1-线程基本使用"><a href="#28-1-线程基本使用" class="headerlink" title="28.1  线程基本使用"></a>28.1  线程基本使用</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128210414360.png" alt="image-20220128210414360"></li>
</ul>
<h4 id="28-1-1-继承-Thread-类"><a href="#28-1-1-继承-Thread-类" class="headerlink" title="28.1.1 继承 Thread 类"></a>28.1.1 继承 Thread 类</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128210437584.png" alt="image-20220128210437584"></p>
<ul>
<li><p>在使用JConsole监控线程执行情况的时候如果主线程结束了但还有其他线程在运行，进程不会退出，此时主线程消失，直到最后一个线程结束，进程才结束，此时最后一个线程看上去并没有消失，这是因为进程结束了，监控也停止了，这个页面静止了。</p>
</li>
<li><p>```java<br>public static void main(String[] args) throws InterruptedException {</p>
<pre><code>//创建 Cat 对象，可以当做线程使用
Cat cat = new Cat();
//源码：
/*
(1)
public synchronized void start() &#123;
    start0();
&#125;
(2)
//start0() 是本地方法，是 JVM 调用, 底层是 c/c++实现
//真正实现多线程的效果， 是 start0(), 而不是 run
private native void start0();，start0()是个原生方法
*/
cat.start();//启动线程-&gt; 最终会执行 cat 的 run 方法
//cat.run();//run 方法就是一个普通的方法, 没有真正的启动一个线程，就会把 run 方法执行完毕，才向下执行
//说明: 当 main 线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行
//这时 主线程和子线程是交替执行..
System.out.println(&quot;主线程继续执行&quot; + Thread.currentThread().getName());//名字 main
for(int i = 0; i &lt; 60; i++) &#123;
    System.out.println(&quot;主线程 i=&quot; + i);
    //让主线程休眠
    Thread.sleep(1000);
&#125;
</code></pre>
<p>}</p>
<p>//1. 当一个类继承了 Thread 类， 该类就可以当做线程使用<br>//2. 我们会重写 run 方法，写上自己的业务代码<br>//3. run Thread 类 实现了 Runnable 接口的 run 方法<br>/*</p>
<pre><code>@Override
public void run() &#123;
    if (target != null) &#123;
        target.run();
    &#125;
&#125;
</code></pre>
<p>*/<br>class Cat extends Thread {</p>
<pre><code>int times = 0;
@Override
public void run() &#123;//重写 run 方法，写上自己的业务逻辑
    while (true) &#123;
        //该线程每隔 1 秒。在控制台输出 “喵喵, 我是小猫咪”
        System.out.println(&quot;喵喵, 我是小猫咪&quot; + (++times) + &quot; 线程名=&quot; + Thread.currentThread().getName());
        //让该线程休眠 1 秒 ctrl+alt+t
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        if(times == 80) &#123;
            break;//当 times 到 80, 退出 while, 这时线程也就退出..
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    + `Thread.currentThread().getName());`**返回当前线程的名字**。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">+ ![image-20220128221655957](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128221655957.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 28.1.2 实现 Runnable 接口</span><br><span class="line"></span><br><span class="line">+ ![image-20220128221856857](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128221856857.png)</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      Dog dog = new Dog();</span><br><span class="line">      Thread thread = new Thread(dog);</span><br><span class="line">      thread.start();</span><br><span class="line">      //简略可以理解底层步骤是这样做的：</span><br><span class="line">      // Tiger tiger = new Tiger();//实现了 Runnable</span><br><span class="line">      // ThreadProxy threadProxy = new ThreadProxy(tiger);</span><br><span class="line">      // threadProxy.start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  class Animal &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  class Tiger extendsAnimal implements Runnable &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          System.out.println(&quot;老虎嗷嗷叫....&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //线程代理类 , 模拟了一个极简的 Thread 类</span><br><span class="line">  class ThreadProxy implements Runnable &#123;</span><br><span class="line">      private Runnable target = null;//属性，类型是 Runnable</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          if (target != null) &#123;</span><br><span class="line">              target.run();//动态绑定（运行类型 Tiger）</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      public ThreadProxy(Runnable target) &#123;</span><br><span class="line">          this.target = target;</span><br><span class="line">      &#125;</span><br><span class="line">      public void start() &#123;</span><br><span class="line">          start0();//这个方法时真正实现多线程方法</span><br><span class="line">      &#125;</span><br><span class="line">      public void start0() &#123;</span><br><span class="line">          run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  class Dog implements Runnable &#123; //通过实现 Runnable 接口，开发线程</span><br><span class="line">      int count = 0;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123; //普通方法</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              System.out.println(&quot;小狗汪汪叫..hi&quot; + (++count) + Thread.currentThread().getName());</span><br><span class="line">              //休眠 1 秒</span><br><span class="line">              try &#123;</span><br><span class="line">                  Thread.sleep(1000);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              if (count == 10) &#123;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="28-1-3-多线程执行"><a href="#28-1-3-多线程执行" class="headerlink" title="28.1.3 多线程执行"></a>28.1.3 多线程执行</h4><ul>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>T1 t1 = new T1();
T2 t2 = new T2();
Thread thread1 = new Thread(t1);
Thread thread2 = new Thread(t2);
thread1.start();//启动第 1 个线程
thread2.start();//启动第 2 个线程
</code></pre>
<p>}</p>
<p>class T1 implements Runnable {</p>
<pre><code>int count = 0;
@Override
public void run() &#123;
    while (true) &#123;
        //每隔 1 秒输出 “hello,world”,输出 10 次
        System.out.println(&quot;hello,world &quot; + (++count));
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        if(count == 60) &#123;
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>class T2 implements Runnable {</p>
<pre><code>int count = 0;
@Override
public void run() &#123;
    //每隔 1 秒输出 “hi”,输出 5 次
    while (true) &#123;
        System.out.println(&quot;hi &quot; + (++count));
        try &#123;
            Thread.sleep(1000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        if(count == 50) &#123;
            break;
        &#125;
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ![image-20220128222408315](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128222408315.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 28.1.4  继承 Thread vs 实现 Runnable 的区别</span><br><span class="line"></span><br><span class="line">+ ![image-20220128222445363](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220128222445363.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 28.2 线程终止</span><br><span class="line"></span><br><span class="line">+ ![image-20220129000100665](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129000100665.png)</span><br><span class="line">  + ![image-20220129000131667](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129000131667.png)</span><br><span class="line">  + **即将线程类中run方法里的while循环的条件改成一个变量loop，当需要终止此线程时，只需在另一个线程中将loop设置成false就行。就像是在主线程通知子线程终止一样，即通知方式**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 28.3 线程常用方法</span><br><span class="line"></span><br><span class="line">#### 28.3.1 第一组</span><br><span class="line"></span><br><span class="line">+ ![image-20220129000518848](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129000518848.png)</span><br><span class="line"></span><br><span class="line">  + **注意事项**：</span><br><span class="line"></span><br><span class="line">  + ![image-20220129000528718](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129000528718.png)</span><br><span class="line"></span><br><span class="line">    + **在线程休眠期间如果调用`interrupt()`方法，则会让这个线程中断休眠**。</span><br><span class="line"></span><br><span class="line">    + **使用setPriority()方法时，有下面三个参数，默认值是10,1,5**：</span><br><span class="line"></span><br><span class="line">      **`Thread.MAX_PRIORITY;`：代表优先级10**</span><br><span class="line"></span><br><span class="line">      **`Thread.MIN_PRIORITY;`：代表优先级1**</span><br><span class="line"></span><br><span class="line">      **`Thread.NORM_PRIORITY;`：代表优先级5**</span><br><span class="line"></span><br><span class="line">    + **`getName()`和`setNmae()`即：`Thread.currentThread().setName();Thread.currentThread().getName();`两个方法，可以在创建了线程对象比如t后`t.getName()`调用**。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#### 28.3.2 第二组</span><br><span class="line"></span><br><span class="line">+ ![image-20220129001602525](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129001602525.png)</span><br><span class="line">  + **调用`yield()`方法的时候有可能判断资源充足不需要礼让，礼让失败等情况**。</span><br><span class="line">  + **`join()`方法调用后必须先执行完插队的线程再返回调用`join()`的地方继续执行**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 28.4 用户线程和守护线程</span><br><span class="line"></span><br><span class="line">+ ![image-20220129105825571](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129105825571.png)</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    Ticket ticket = new Ticket();</span><br><span class="line">    ticket.setDaemon(true);</span><br></pre></td></tr></table></figure>

<p>  <strong>这样就是将ticket线程设置成守护线程，当所有用户线程结束它就自动结束</strong>。</p>
</li>
</ul>
<h3 id="28-5-线程的生命周期"><a href="#28-5-线程的生命周期" class="headerlink" title="28.5 线程的生命周期"></a>28.5 线程的生命周期</h3><ul>
<li><p>​    <strong>在Thread类里面有一个枚举类型State记录了线程六种状态，其中RUNNABLE可以细分为就绪态和运行态</strong>。</p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129110020434.png" alt="image-20220129110020434"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129110046015.png" alt="image-20220129110046015"></p>
<ul>
<li>```java<br>public static void main(String[] args) throws InterruptedException {<pre><code>T t = new T();
System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());//此时为NEW状态
t.start();//start过后立马进入RUNNABLE状态
while (Thread.State.TERMINATED != t.getState()) &#123;
    System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());
    Thread.sleep(500);
&#125;
System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());//最后是Teminated状态
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    + **`.getState()`可以查看线程状态**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 28.6 线程的同步</span><br><span class="line"></span><br><span class="line">+ ![image-20220129110728992](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129110728992.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 28.6.1 Synchronized</span><br><span class="line"></span><br><span class="line">+ ![image-20220129110800698](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129110800698.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20220129165253667](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220129165253667.png)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">      SellTicket03 sellTicket03 = new SellTicket03();</span><br><span class="line">      new Thread(sellTicket03).start();//第 1 个线程-窗口</span><br><span class="line">      new Thread(sellTicket03).start();//第 2 个线程-窗口</span><br><span class="line">      new Thread(sellTicket03).start();//第 3 个线程-窗口</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //实现接口方式, 使用 synchronized 实现线程同步</span><br><span class="line">  class SellTicket03 implements Runnable &#123;</span><br><span class="line">      private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">      private boolean loop = true;//控制 run 方法变量</span><br><span class="line">      Object object = new Object();</span><br><span class="line">      //老韩说明</span><br><span class="line">      //1. public synchronized void sell() &#123;&#125; 就是一个同步方法</span><br><span class="line">      //2. 这时锁在 this 对象</span><br><span class="line">      //3. 也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在 this 对象</span><br><span class="line">      public /*synchronized*/ void sell() &#123; //同步方法, 在同一时刻， 只能有一个线程来执行 sell 方法</span><br><span class="line">          synchronized (/*this*/ object) &#123;//这里object是静态的，所以所有对象使用的是同一个object的锁</span><br><span class="line">              if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                  System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                  loop = false;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">              //休眠 50 毫秒, 模拟</span><br><span class="line">              try &#123;</span><br><span class="line">                  Thread.sleep(50);</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">              System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                                 + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1 - -2</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          while (loop) &#123;</span><br><span class="line">              sell();//sell 方法是一共同步方法</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //静态方法使用synchronize:</span><br><span class="line">  //同步方法（静态的）的锁为当前类本身</span><br><span class="line">  public synchronized static void m1() &#123;//在方法上加synchronized</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public static void m2() &#123;//在代码块上加</span><br><span class="line">      synchronized (SellTicket03.class) &#123;//静态方法使用synchronized+对象的时候后面不能用this了，因为this与对象实例有关，这个时候要在后面加`类名.class`</span><br><span class="line">          System.out.println(&quot;m2&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //由于实现了RUNNABLE接口的线程只需创建一个类，然后只是将这个类创建三个对应的Thread对象，所以每个线程的this都是同一个对象</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="28-6-2-死锁"><a href="#28-6-2-死锁" class="headerlink" title="28.6.2 死锁"></a>28.6.2 死锁</h4><ul>
<li><p><strong>下面操作会释放锁</strong>：</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221056884.png" alt="image-20220211221056884"></p>
</li>
<li><p><strong>下面操作不会释放锁</strong>：</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221153736.png" alt="image-20220211221153736"></p>
</li>
</ul>
<h2 id="29-IO-流"><a href="#29-IO-流" class="headerlink" title="29 IO 流"></a>29 IO 流</h2><h3 id="29-1-文件"><a href="#29-1-文件" class="headerlink" title="29.1 文件"></a>29.1 文件</h3><h4 id="29-1-1-文件流"><a href="#29-1-1-文件流" class="headerlink" title="29.1.1 文件流"></a>29.1.1 文件流</h4><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221348465.png" alt="image-20220211221348465"><ul>
<li><strong>进入内存就是输入流，从内存出去就是输出流</strong>。</li>
</ul>
</li>
</ul>
<h4 id="29-1-2-常用的文件操作"><a href="#29-1-2-常用的文件操作" class="headerlink" title="29.1.2 常用的文件操作"></a>29.1.2 常用的文件操作</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211221447818.png" alt="image-20220211221447818"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">file0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String filePath = <span class="string">&quot;e:\\new01.txt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">file1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    File parentFile = <span class="keyword">new</span> File(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line">    String fileName = <span class="string">&quot;new02.txt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    File file = <span class="keyword">new</span> File(parentFile, fileName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">file2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String parentPath = <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">    String fileName = <span class="string">&quot;new03.txt&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    File file = <span class="keyword">new</span> File(parentPath, fileName);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="29-1-3-获取文件的相关信息"><a href="#29-1-3-获取文件的相关信息" class="headerlink" title="29.1.3 获取文件的相关信息"></a>29.1.3 获取文件的相关信息</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211224059980.png" alt="image-20220211224059980"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;e:\\news1.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用相应的方法，得到对应信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件名字=&quot;</span> + file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span> + file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件父级目录=&quot;</span> + file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件大小(字节)=&quot;</span> + file.length());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件是否存在=&quot;</span> + file.exists());<span class="comment">//T</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span> + file.isFile());<span class="comment">//T</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span> + file.isDirectory());<span class="comment">//F</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="29-1-4-目录的操作和文件删除"><a href="#29-1-4-目录的操作和文件删除" class="headerlink" title="29.1.4  目录的操作和文件删除"></a>29.1.4  目录的操作和文件删除</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211224223346.png" alt="image-20220211224223346"></p>
<ul>
<li><p><strong>mkdir()无法创建多级目录，且方法返回一个布尔值</strong>。</p>
</li>
<li><p><strong>delete()删除目录时必须是空目录，否则失败，目录是一种特殊的文件</strong>。</p>
</li>
<li><p>```java<br>public void file0(){</p>
<pre><code>String filePath = &quot;e:\\demo02\\a\\b\\c&quot;;
File file = new File(filePath);
if(file.exists())&#123;//判断是否存在
    if(file.delete())&#123;
        System.out.println(&quot;删掉了&quot;);
    &#125;else &#123;
        System.out.println(&quot;没删掉&quot;);
    &#125;
&#125; else &#123;
    if(file.mkdirs())&#123;//要用mkdirs()
        System.out.println(&quot;创建成功&quot;);
    &#125;else &#123;
        System.out.println(&quot;创建失败&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 29.2  IO 流原理及流的分类</span><br><span class="line"></span><br><span class="line">+ ![image-20220211233359746](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211233359746.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20220211233410426](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211233410426.png)</span><br><span class="line"></span><br><span class="line">+ **流的分类**：</span><br><span class="line">  + ![image-20220211233457520](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211233457520.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **IO 流体系图**：</span><br><span class="line">  + ![image-20220211233544136](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211233544136.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **文件 &amp; 流**：</span><br><span class="line"></span><br><span class="line">  + ![image-20220211233644088](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220211233644088.png)</span><br><span class="line"></span><br><span class="line">  + **创建一个文件的流对象，用这个流对象操作文件数据**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 29.2.1 FileInputStream</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  public void readFile01() &#123;</span><br><span class="line">      String filePath = &quot;e:\\hello.txt&quot;;</span><br><span class="line">      int readData = 0;//用于接收read()方法返回值，返回的是int类型</span><br><span class="line">      FileInputStream fileInputStream = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          //创建 FileInputStream 对象，用于读取 文件</span><br><span class="line">          fileInputStream = new FileInputStream(filePath);</span><br><span class="line">          //从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。</span><br><span class="line">          //如果返回-1 , 表示读取完毕</span><br><span class="line">          while ((readData = fileInputStream.read()) != -1) &#123;</span><br><span class="line">              System.out.print((char)readData);//转成 char 显示</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          //关闭文件流，释放资源.</span><br><span class="line">          try &#123;</span><br><span class="line">              fileInputStream.close();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  /**</span><br><span class="line">  * 使用 read(byte[] b) 读取文件，提高效率</span><br><span class="line">  */</span><br><span class="line">  public void readFile02() &#123;</span><br><span class="line">      String filePath = &quot;e:\\hello.txt&quot;;</span><br><span class="line">      //字节数组</span><br><span class="line">      byte[] buf = new byte[8]; //一次读取 8 个字节.</span><br><span class="line">      int readLen = 0;</span><br><span class="line">      FileInputStream fileInputStream = null;</span><br><span class="line">      try &#123;</span><br><span class="line">          //创建 FileInputStream 对象，用于读取 文件</span><br><span class="line">          fileInputStream = new FileInputStream(filePath);</span><br><span class="line">          //从该输入流读取最多 b.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。</span><br><span class="line">          //如果返回-1 , 表示读取完毕</span><br><span class="line">          //如果读取正常, 返回实际读取的字节数</span><br><span class="line">          while ((readLen = fileInputStream.read(buf)) != -1) &#123;</span><br><span class="line">              System.out.print(new String(buf, 0, readLen));//显示</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          //关闭文件流，释放资源.</span><br><span class="line">          try &#123;</span><br><span class="line">              fileInputStream.close();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="29-2-2-FileOutputStream"><a href="#29-2-2-FileOutputStream" class="headerlink" title="29.2.2  FileOutputStream"></a>29.2.2  FileOutputStream</h4><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212000055365.png" alt="image-20220212000055365"></p>
</li>
<li><p>```java<br>public void writeFile() {</p>
<pre><code>//创建 FileOutputStream 对象
String filePath = &quot;e:\\a.txt&quot;;
FileOutputStream fileOutputStream = null;
String str = &quot;hello,world!&quot;;
try &#123;
    //1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容
    //2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面
    fileOutputStream = new FileOutputStream(filePath);
    
    //写入一个字节
    fileOutputStream.write(&#39;H&#39;);
    
    //写入字符串
    //str.getBytes() 可以把 字符串 -&gt; 字节数组
    fileOutputStream.write(str.getBytes());
    
    /*
    write(byte[] b, int off, int len) 将 len 字节从位于偏移量 off 的指定字节数组写入此文件输出流
    */
    fileOutputStream.write(str.getBytes(), 0, 3);
    
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125; finally &#123;
    try &#123;
        fileOutputStream.close();
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 29.2.3 FileReader 和 FileWriter</span><br><span class="line"></span><br><span class="line">+ ![image-20220212141308490](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212141308490.png)</span><br><span class="line"></span><br><span class="line">##### 29.2.3.1  FileReader 相关方法</span><br><span class="line"></span><br><span class="line">+ ![image-20220212141342990](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212141342990.png)</span><br><span class="line"></span><br><span class="line">##### 29.2.3.2 FileWriter 常用方法</span><br><span class="line"></span><br><span class="line">+ ![image-20220212141356472](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212141356472.png)</span><br><span class="line">  + **在使用FileWriter时不关闭或者刷新，数据不会写入文件，而在FileOutputStream里不关闭会写入**。</span><br><span class="line">  + 关闭和刷新底层都调用了</span><br><span class="line"></span><br><span class="line">##### 29.2.3.3 代码示例</span><br><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  //单个字符读取</span><br><span class="line">  public void readFile01() &#123;</span><br><span class="line">      String filePath = &quot;e:\\story.txt&quot;;</span><br><span class="line">      FileReader fileReader = null;</span><br><span class="line">      int data = 0;</span><br><span class="line">      try &#123;</span><br><span class="line">          fileReader = new FileReader(filePath);</span><br><span class="line">          //循环读取 使用 read, 单个字符读取</span><br><span class="line">          while ((data = fileReader.read()) != -1) &#123;</span><br><span class="line">              System.out.print((char) data);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              if (fileReader != null) &#123;</span><br><span class="line">                  fileReader.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //字符数组读取文件</span><br><span class="line">  @Test</span><br><span class="line">  public void readFile02() &#123;</span><br><span class="line">      String filePath = &quot;e:\\story.txt&quot;;</span><br><span class="line">      FileReader fileReader = null;</span><br><span class="line">      int readLen = 0;</span><br><span class="line">      char[] buf = new char[8];</span><br><span class="line">      //1. 创建 FileReader 对象</span><br><span class="line">      try &#123;</span><br><span class="line">          fileReader = new FileReader(filePath);</span><br><span class="line">          //循环读取 使用 read(buf), 返回的是实际读取到的字符数</span><br><span class="line">          //如果返回-1, 说明到文件结束</span><br><span class="line">          while ((readLen = fileReader.read(buf)) != -1) &#123;</span><br><span class="line">              System.out.print(new String(buf, 0, readLen));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              if (fileReader != null) &#123;</span><br><span class="line">                  fileReader.close();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>String filePath = &quot;e:\\note.txt&quot;;
FileWriter fileWriter = null;
char[] chars = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;;
try &#123;
    fileWriter = new FileWriter(filePath);//默认是覆盖写入
    // 3) write(int):写入单个字符
    fileWriter.write(&#39;H&#39;);
    // 4) write(char[]):写入指定数组
    fileWriter.write(chars);
    // 5) write(char[],off,len):写入指定数组的指定部分
    fileWriter.write(&quot;韩顺平教育&quot;.toCharArray(), 0, 3);
    // 6) write（string）：写入整个字符串
    fileWriter.write(&quot; 你好北京~&quot;);
    // 7) write(string,off,len):写入字符串的指定部分
    fileWriter.write(&quot;上海天津&quot;, 0, 2);
    //在数据量大的情况下，可以使用循环操作.
&#125; catch (IOException e) &#123;
    e.printStackTrace();
&#125; finally &#123;
    try &#123;
        //fileWriter.flush();
        //close()关闭文件流，等价 flush() + 关闭
        fileWriter.close();
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
System.out.println(&quot;程序结束...&quot;);
</code></pre>
<p>}</p>
<p>//对应 FileWriter , 一定要关闭流，或者 flush 才能真正的把数据写入到文件<br>//原因:看看代码,flush和close底层都会调用这个writeBytes()方法，这个方法会真正写入数据到文件<br>private void writeBytes() throws IOException {</p>
<pre><code>this.bb.flip();
int var1 = this.bb.limit();
int var2 = this.bb.position();
assert var2 &lt;= var1;
int var3 = var2 &lt;= var1 ? var1 - var2 : 0;
if (var3 &gt; 0) &#123;
    if (this.ch != null) &#123;
        assert this.ch.write(this.bb) == var3 : var3;
    &#125; else &#123;
        this.out.write(this.bb.array(), this.bb.arrayOffset() + var2, var3);
    &#125;//这里的this.out实际上就是FileOutputStream这个out
&#125;
this.bb.clear();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 29.3 节点流和处理流</span><br><span class="line"></span><br><span class="line">+ ![image-20220212152853631](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212152853631.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20220212152917599](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212152917599.png)</span><br><span class="line"></span><br><span class="line">+ ![image-20220212152929841](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212152929841.png)</span><br><span class="line"></span><br><span class="line">+ **处理流例如：BufferedReader里面有一个Reader类型的属性，这个属性就可以用来接收所有Reader的子类，比如FileReader,CharArrayReader等节点流，**然后提供方法对它进行操作，是一种修饰器模式。</span><br><span class="line"></span><br><span class="line">  ![image-20220212153457587](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212153457587.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 29.3.1 处理流的功能主要体现在以下两个方面</span><br><span class="line"></span><br><span class="line">+ ![image-20220212153047461](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212153047461.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 29.3.2 处理流-BufferedReader 和 BufferedWriter</span><br><span class="line"></span><br><span class="line">+ ![image-20220212162046109](https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212162046109.png)</span><br><span class="line"></span><br><span class="line">  + **在使用外层流的close()方法时底层会动态绑定到传入的字节流的close方法**。</span><br><span class="line"></span><br><span class="line">+ **BufferedReader**:</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String filePath = &quot;e:\\a.java&quot;;</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));</span><br><span class="line">        String line; //按行读取, 效率高</span><br><span class="line">        //说明</span><br><span class="line">        //1. bufferedReader.readLine() 是按行读取文件</span><br><span class="line">        //2. 当返回 null 时，表示文件读取完毕</span><br><span class="line">        while ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        //关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流FileReader</span><br><span class="line">    	/*</span><br><span class="line">        public void close() throws IOException &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                if (in == null)</span><br><span class="line">                    return;</span><br><span class="line">                try &#123;</span><br><span class="line">                    in.close();//in 就是我们传入的 new FileReader(filePath)!!!!!!!</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    in = null;</span><br><span class="line">                    cb = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>BufferedWriter</strong>:</p>
<ul>
<li>```java<br>public static void main(String[] args) throws IOException {<pre><code>String filePath = &quot;e:\\ok.txt&quot;;
//1. new FileWriter(filePath, true) 表示以追加的方式写入
//2. new FileWriter(filePath) , 表示以覆盖的方式写入
BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath,true));
bufferedWriter.write(&quot;hello, 韩顺平教育!&quot;);
bufferedWriter.newLine();//插入一个和系统相关的换行
bufferedWriter.write(&quot;hello2, 韩顺平教育!&quot;);
bufferedWriter.newLine();
bufferedWriter.write(&quot;hello3, 韩顺平教育!&quot;);
bufferedWriter.newLine();
//说明：关闭外层流即可 ， 传入的 new FileWriter(filePath) ,会在底层关闭
bufferedWriter.close();
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  + **写入的时候想换行可以调用.newLine()方法，也可以在字符串后+&quot;\n&quot;**。</span><br><span class="line"></span><br><span class="line">#### 29.3.3 处理流-BufferedInputStream 和 BufferedOutputStream</span><br><span class="line"></span><br><span class="line">+ &lt;img src=&quot;https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212162912410.png&quot; alt=&quot;image-20220212162912410&quot; style=&quot;zoom: 67%;&quot; /&gt;</span><br><span class="line">  + **里面的in属性就是用来接收InputStream()子类的**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ &lt;img src=&quot;https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212162918251.png&quot; alt=&quot;image-20220212162918251&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line">  + **里面的out属性就是用来接收OutputStream()子类的**。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ **拷贝图片**（图片是二进制文件，还有声音，视频，doc，pdf等）：</span><br><span class="line"></span><br><span class="line">  + ```java</span><br><span class="line">    public static void main(String[] args) thorws Exception&#123;</span><br><span class="line">        String srcFilePath = &quot;e:\\Koala.jpg&quot;;</span><br><span class="line">        String destFilePath = &quot;e:\\hsp.jpg&quot;;</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFilePath));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFilePath));</span><br><span class="line">        byte[] buff = new byte[1024];</span><br><span class="line">        int readLen = 0;</span><br><span class="line">        </span><br><span class="line">        //当返回 -1 时，就表示文件读取完毕</span><br><span class="line">        while ((readLen = bis.read(buff)) != -1) &#123;</span><br><span class="line">            bos.write(buff, 0, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;文件拷贝完毕~~~&quot;);</span><br><span class="line">        </span><br><span class="line">        //关闭流</span><br><span class="line">        if(bis != null) &#123;</span><br><span class="line">            bis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        if(bos != null) &#123;</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="29-4-对象流-ObjectInputStream-和-ObjectOutputStream"><a href="#29-4-对象流-ObjectInputStream-和-ObjectOutputStream" class="headerlink" title="29.4 对象流-ObjectInputStream 和 ObjectOutputStream"></a>29.4 对象流-ObjectInputStream 和 ObjectOutputStream</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212170606391.png" alt="image-20220212170606391"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212170646465.png" alt="image-20220212170646465"></p>
</li>
<li><p><strong>序列化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//序列化后，保存的文件格式，不是纯文本，而是按照他的格式来保存</span></span><br><span class="line">    String filePath = <span class="string">&quot;e:\\data.dat&quot;</span>;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(filePath));</span><br><span class="line">    </span><br><span class="line">    oos.writeInt(<span class="number">100</span>);<span class="comment">// int -&gt; Integer (实现了 Serializable)</span></span><br><span class="line">    oos.writeBoolean(<span class="keyword">true</span>);<span class="comment">// boolean -&gt; Boolean (实现了 Serializable)</span></span><br><span class="line">    oos.writeChar(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// char -&gt; Character (实现了 Serializable)</span></span><br><span class="line">    oos.writeDouble(<span class="number">9.5</span>);<span class="comment">// double -&gt; Double (实现了 Serializable)</span></span><br><span class="line">    oos.writeUTF(<span class="string">&quot;韩顺平教育&quot;</span>);<span class="comment">//String</span></span><br><span class="line">    <span class="comment">//保存一个 dog 对象，这个dog对象需要实现可序列化接口，否则会报错，而且序列化的时候会将这个Dog类所在的包名也序列化保存，在反序列化得到dog对象后（需向下转型，因为是readObject）必须也调用的是这个包名下的dog类的方法。！！！！！！！！！！</span></span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Dog(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">    </span><br><span class="line">    oos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>反序列化</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\data.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取， 注意顺序要和序列化的时候保持一致，因为序列化数据的时候是按照顺序的</span></span><br><span class="line">System.out.println(ois.readInt());</span><br><span class="line">System.out.println(ois.readBoolean());</span><br><span class="line">System.out.println(ois.readChar());</span><br><span class="line">System.out.println(ois.readDouble());</span><br><span class="line">System.out.println(ois.readUTF());</span><br><span class="line">System.out.println(ois.readObject());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.关闭</span></span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212171041483.png" alt="image-20220212171041483"></p>
</li>
</ul>
<h3 id="29-5-标准输入输出流"><a href="#29-5-标准输入输出流" class="headerlink" title="29.5 标准输入输出流"></a>29.5 标准输入输出流</h3><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212180115375.png" alt="image-20220212180115375"><ul>
<li><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212180250016.png" alt="image-20220212180250016"></li>
</ul>
</li>
</ul>
<h3 id="29-6-转换流-InputStreamReader-和-OutputStreamWriter"><a href="#29-6-转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="29.6 转换流-InputStreamReader 和 OutputStreamWriter"></a>29.6 转换流-InputStreamReader 和 OutputStreamWriter</h3><ul>
<li><p><strong>正常读取</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//读取 e:\\a.txt 文件到程序</span></span><br><span class="line">    <span class="comment">//1. 创建字符输入流 BufferedReader [处理流]</span></span><br><span class="line">    <span class="comment">//2. 使用 BufferedReader 对象读取 a.txt</span></span><br><span class="line">    <span class="comment">//3. 默认情况下，读取文件是按照 utf-8 编码!!!!!!!</span></span><br><span class="line">    String filePath = <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filePath));</span><br><span class="line">    String s = br.readLine();</span><br><span class="line">    System.out.println(<span class="string">&quot;读取到的内容: &quot;</span> + s);</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果a.txt文件的编码不是utf-8，则直接使用字符输入流读取会出现乱码</strong>。</li>
</ul>
</li>
<li><p><strong>使用转换流</strong>：</p>
<ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212180709930.png" alt="image-20220212180709930"></p>
</li>
<li><p>```java<br>public static void main(String[] args) throws IOException {</p>
<pre><code>String filePath = &quot;e:\\a.txt&quot;;
BufferedReader br = new BufferedReader(new InputStreamReader(
    new FileInputStream(filePath), &quot;gbk&quot;));//指定输入流读取格式为gbk格式
String s = br.readLine();
System.out.println(&quot;读取内容=&quot; + s);
br.close();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ ```java</span><br><span class="line">  //使用输出转换流，指定编码格式为gbk格式</span><br><span class="line">  OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;d:\\a.txt&quot;), &quot;gbk&quot;);</span><br><span class="line">  osw.write(&quot;hello,韩顺平教育~&quot;);</span><br><span class="line">  osw.close();</span><br></pre></td></tr></table></figure></li>
<li><p>ANSI代表国标码，每国不同，此系统ANSI编码为gbk码</p>
</li>
</ul>
</li>
</ul>
<h3 id="29-7-打印流-PrintStream-和-PrintWriter"><a href="#29-7-打印流-PrintStream-和-PrintWriter" class="headerlink" title="29.7  打印流-PrintStream 和 PrintWriter"></a>29.7  打印流-PrintStream 和 PrintWriter</h3><ul>
<li><p>打印流只有输出流，没有输入流</p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212182559066.png" alt="image-20220212182559066"></p>
</li>
<li><p><strong>字节打印流PrintStream</strong>:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.直接指定位置打印：</span></span><br><span class="line">    PrintStream printStream = <span class="keyword">new</span> PrintStream(<span class="string">&quot;e:\\5.txt&quot;</span>);</span><br><span class="line">    printStream.print(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">    printStream.close();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.打印到显示器：</span></span><br><span class="line">    PrintStream out = System.out;</span><br><span class="line">    <span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    public void print(String s) &#123;</span></span><br><span class="line"><span class="comment">        if (s == null) &#123;</span></span><br><span class="line"><span class="comment">            s = &quot;null&quot;;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        write(s);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    out.print(<span class="string">&quot;john, hello&quot;</span>);</span><br><span class="line">    <span class="comment">//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出</span></span><br><span class="line">    out.write(<span class="string">&quot;韩顺平,你好&quot;</span>.getBytes());</span><br><span class="line">    out.close();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.修改默认打印位置</span></span><br><span class="line">    System.setOut(<span class="keyword">new</span> PrintStream(<span class="string">&quot;e:\\f1.txt&quot;</span>));<span class="comment">//修改默认输出位置，不再是显示器！！！！</span></span><br><span class="line">    <span class="comment">//我们可以去修改打印流输出的位置/设备</span></span><br><span class="line">    <span class="comment">//1. 输出修改成到 &quot;e:\\f1.txt&quot;</span></span><br><span class="line">    <span class="comment">//2. &quot;hello, 韩顺平教育~&quot; 就会输出到 e:\f1.txt</span></span><br><span class="line">    <span class="comment">//3. public static void setOut(PrintStream out) &#123;</span></span><br><span class="line">    <span class="comment">// 		checkIO();</span></span><br><span class="line">    <span class="comment">// 		setOut0(out); // native 方法，修改了 out</span></span><br><span class="line">    <span class="comment">// 	&#125;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;hello, 韩顺平教育~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符打印流PrintWriter</strong>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.打印在显示器</span></span><br><span class="line">    PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="comment">//System.out是字节流，PrintWriter有接收OutStream类型的构造器，因此可行</span></span><br><span class="line">    printWriter.println(<span class="string">&quot;Bin&quot;</span>);<span class="comment">//会打印在显示器上</span></span><br><span class="line">    printWriter.close();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.指定位置打印</span></span><br><span class="line">    PrintWriter printWriter1 = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;e:\\4.txt&quot;</span>);</span><br><span class="line">    printWriter1.print(<span class="string">&quot;Bin导在干嘛&quot;</span>);</span><br><span class="line">    printWriter1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="29-8-Properties-类"><a href="#29-8-Properties-类" class="headerlink" title="29.8  Properties 类"></a>29.8  Properties 类</h3><ul>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212202310002.png" alt="image-20220212202310002"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212202423428.png" alt="image-20220212202423428"></p>
</li>
<li><p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20220212202430918.png" alt="image-20220212202430918"></p>
<ul>
<li><p>```java<br>public static void main(String[] args) throws IOException {</p>
<pre><code>//使用 Properties 类来读取 mysql.properties 文件

//1. 创建 Properties 对象
Properties properties = new Properties();

//2. 加载指定配置文件
properties.load(new FileReader(&quot;src\\mysql.properties&quot;));

//3. 把 k-v 显示控制台
properties.list(System.out);

//4. 根据 key 获取对应的值
String user = properties.getProperty(&quot;user&quot;);
String pwd = properties.getProperty(&quot;pwd&quot;);
System.out.println(&quot;用户名=&quot; + user);
System.out.println(&quot;密码是=&quot; + pwd);
</code></pre>
<p>}</p>
<p>public class Properties03 {</p>
<pre><code>public static void main(String[] args) throws IOException &#123;
    //使用 Properties 类来创建 配置文件, 修改配置文件内容
    Properties properties = new Properties();
    //1.如果该文件没有 key 就是创建
    //2.如果该文件有 key ,就是修改
    properties.setProperty(&quot;charset&quot;, &quot;utf8&quot;);
    properties.setProperty(&quot;user&quot;, &quot;汤姆&quot;);//注意保存时，是中文的 unicode 码值
    properties.setProperty(&quot;pwd&quot;, &quot;888888&quot;);
    //将 k-v 存储文件中即可
    properties.store(new FileOutputStream(&quot;src\\mysql2.properties&quot;), null);
    System.out.println(&quot;保存配置文件成功~&quot;);
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">Properties 父类是 Hashtable ， 底层就是 Hashtable 核心方法</span><br><span class="line">//properties.setProperty()的时候调用此方法</span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();//value不能为空！！！</span><br><span class="line">    &#125;</span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;//如果 key 存在，就替换！！！！</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEntry(hash, key, value, index);//如果是新 k, 就 addEntry！！！</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在properties.setProperty()添加修改properties文件后，需要调用store方法才回存到文件中，否则只是在内存的properties对象中，而store方法的第二个参数代表注释，可以输入一个字符串，这个字符串会在properties文件的最上方，一般写null</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="番外：IDEA快捷键"><a href="#番外：IDEA快捷键" class="headerlink" title="番外：IDEA快捷键"></a>番外：IDEA快捷键</h1><ol>
<li><strong>删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d</strong></li>
</ol>
<ol start="2">
<li><strong>复制当前行, 自己配置 ctrl + alt + 向下光标</strong></li>
<li><strong>补全代码 alt + /</strong></li>
<li><strong>添加注释和取消注释 ctrl + /</strong> </li>
<li><strong>导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可</strong></li>
<li><strong>快速格式化代码 ctrl + alt + L</strong></li>
<li><strong>快速运行程序 自己定义 alt + R</strong></li>
<li><strong>生成构造器等 alt + insert [提高开发效率]</strong></li>
<li><strong>查看一个类的层级关系 ctrl + H [学习继承后，非常有用]</strong></li>
<li><strong>将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]</strong></li>
<li><strong>自动的分配变量名 , 通过 在后面加 .var</strong> </li>
<li><strong>重写父类方法的时候直接写方法名，会有提示直接生成这个方法</strong></li>
</ol>
<h1 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h1><h2 id="1-返回当前时间函数"><a href="#1-返回当前时间函数" class="headerlink" title="1. 返回当前时间函数"></a>1. 返回当前时间函数</h2><ul>
<li><p><code>long time = System.currentTimeMillis();</code>，返回当前时间，返回类型是<code>long</code>。</p>
<p><img src="https://gitee.com/YuFish-W/picture/raw/master/img/image-20211230161148251.png" alt="image-20211230161148251"></p>
<ul>
<li>静态方法，返回long类型</li>
</ul>
</li>
</ul>
<h2 id="2-getClass-函数"><a href="#2-getClass-函数" class="headerlink" title="2. getClass()函数"></a>2. getClass()函数</h2><ul>
<li><p><code>对象名.getClass()</code>返回对象的运行类型名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B a = <span class="keyword">new</span> Aa();</span><br><span class="line">System.out.println(a.getClass());<span class="comment">//这里会输出 &quot;class Aa&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-javap"><a href="#3-javap" class="headerlink" title="3. javap"></a>3. javap</h2><ul>
<li><strong>反编译指令，可以将<code>.class</code>文件转成<code>.java</code>文件</strong><ul>
<li><strong>javac指令是让<code>.java</code>文件转成<code>.class</code>文件</strong></li>
</ul>
</li>
</ul>
<h2 id="4-增强for循环"><a href="#4-增强for循环" class="headerlink" title="4. 增强for循环"></a>4. 增强for循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">78</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> key : a) &#123;</span><br><span class="line">    System.out.print(key + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;<span class="comment">//相当于从数组a一次取出元素给key，比传统方法更简洁因此叫增强for循环</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/22/JJ/" data-id="ckzy85b9q0000fclkbsif94tm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/12/02/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/22/JJ/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/12/02/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>